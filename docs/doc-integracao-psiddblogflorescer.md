# Documentação-Blog-Florescer-Humano&psicologodanieldantas

Status: Em andamento
Projeto: Blog-site Daniel Dantas (https://www.notion.so/Blog-site-Daniel-Dantas-1cf2ffa5939e808d9e89e0a2bce44630?pvs=21)

## **Documentação: Objetivos Estratégicos e Fundamentais - Blog Florescer Humano**

**Projeto:** Blog-site Daniel Dantas - Módulo "Florescer Humano"

**Status:** Definição Concluída

**Versão:** 1.0

**Data:** [Data Atual]

### 1. Introdução e Propósito

Este documento estabelece os objetivos estratégicos e fundamentais que norteiam a criação e o desenvolvimento contínuo do blog "Florescer Humano". Ele serve como a pedra angular para todas as decisões relacionadas a conteúdo, design, funcionalidades, experiência do usuário (UX) e otimização para mecanismos de busca (SEO). O propósito é definir claramente a **missão, visão, valores, público-alvo, tom de voz e metas específicas** do blog, garantindo um alinhamento consistente em todas as etapas do projeto e comunicando sua essência única.

### 2. Fundamento Inspirador: O Manifesto Poético

A concepção do blog "Florescer Humano" foi profundamente inspirada por uma visão poética e humanista, encapsulada no seguinte texto:

- **Título:** Sobre Flores, Jardins e Amores
- **Autor:** Daniel Dantas

> É preciso amar as flores, caminhar nos jardins
> 
> 
> Cultivar afetos, irrigar amores
> 
> É preciso vida para acolher a morte de cada dia
> 
> Nesse solo adubado, renascer em flores de si
> 
> Fertilidade dos sonhos que teimam em renascer
> 
> Cultivar vida, transcender, reviver, reinventar-se
> 
> É preciso uma poética dos cultivos e das colheitas
> 
> Consciência do que se planta e se colhe
> 
> É preciso um ativismo dos jardins
> 
> Pelas flores, amores e dores
> 
> Um ativismo das danças, flores e contemplações
> 
> Do que se busca ao se buscar nada
> 
> Do que se ganha ao simplesmente ser
> 
> Do sorriso que brota
> 
> Das sementes em terras áridas
> 
> Dos solos férteis de lágrimas e sonhos
> 
> Das flores que germinam, florescem e dão frutos
> 
> Dos pés na terra macia e húmida
> 
> Das raízes e do enraizar
> 
> Mas também é preciso lutar
> 
> E se saber pelo que se luta
> 
> Um ativismo dos cultivos dos grãos e raízes
> 
> E saber o que se é, e o que se busca
> 
> Da poesia que se quer cultivar
> 
> Das diferentes formas de amar
> 
> Das cirandas ao luar
> 
> Do pé enraizado
> 
> Do chão
> 
> Da firmeza e gentileza
> 
> Dos afetos e flores
> 
> E sim das flores. Flores, jardins e amores
> 
> E sim, é preciso cultivar
> 
> Tudo pelo que se vale a pena lutar
> 

Este poema serve como um manifesto, guiando o tom, os valores e a abordagem do blog, enfatizando o cultivo, o crescimento, a consciência, a beleza da experiência e a importância dos afetos.

### 3. Estrutura Técnica e Contexto no Site Principal

O blog "Florescer Humano" será implementado como um módulo específico dentro do site principal do Psicólogo Daniel Dantas.

- **Localização:** O blog residirá na subpasta psicologodanieldantas.com/blogflorescerhumano/.
- **Autonomia Organizacional:**
    - Todos os arquivos e pastas relacionados ao blog (código, componentes, estilos, assets) serão mantidos **dentro** da pasta blogflorescerhumano na estrutura do projeto (provavelmente em src/app/blogflorescerhumano/).
    - Componentes e arquivos específicos do blog usarão o sufixo "blog" (ex: ButtonBlog.tsx) para clara diferenciação e para evitar conflitos de nomenclatura com o site principal.
    - A estrutura do blog será autônoma, contendo seus próprios layouts, componentes e páginas específicas, garantindo modularidade e manutenção facilitada.
- **Integração:**
    - Apesar da autonomia organizacional, o blog se integrará visualmente e funcionalmente ao site principal quando necessário (ex: navegação de retorno, identidade visual consistente).
    - A URL seguirá o padrão psicologodanieldantas.com/blogflorescerhumano/[...].
- **Propósito da Estrutura:** Garantir organização, isolamento do conteúdo do blog, clareza na estrutura de URLs, boa prática de desenvolvimento modular e manutenção simplificada, ao mesmo tempo que permite uma experiência de usuário coesa para quem navega entre o site principal e o blog.

### 4. Definição Estratégica Central

### 4.1. Missão

- "A missão do blog "**Florescer Humano**" reside em **cultivar a compreensão e a vivência dos princípios do humanismo em todas as esferas da existência, oferecendo um jardim de reflexão, aprendizado e encontro para todos os corações, promovendo o diálogo e a exploração de diversas perspectivas sobre a experiência humana, temos um olhar especial para psicologia humanista, incluindo a abordagem centrada na pessoa e a focalização**. Mas também temos uma atenção **ao intercâmbio de conhecimentos com outras abordagens psicológicas como técnicas de mindfulness, neuropsicologia entre outras**. Busca-se **valorizar a inteireza do potencial humano**, a **beleza da experiência íntima**, a **autonomia de cada indivíduo**, a **dignidade inerente a cada ser** e o **incessante movimento de crescimento pessoal**. O propósito é **adubar o solo da consciência** através da disseminação da sabedoria da psicologia humanista, da análise dos fenômenos da vida sob a ótica humanista e do incentivo à formação de seres mais conscientes do que semeiam e colhem em suas jornadas. Almeja-se ser um espaço onde a poética dos cultivos e das colheitas se manifeste, nutrindo o renascer em flores de si."

### 4.2. Visão

- "A visão é **transformar o blog "Florescer Humano" em uma referência essencial no universo online para aqueles que anseiam por aprofundar a compreensão e a prática do humanismo, tornando-se um jardim fecundo de ideias e inspirações**. Ambiciona-se **criar uma comunidade engajada de leitores e colaboradores que se inspirem nos valores humanistas para cultivar vidas mais plenas e edificar societies mais justas e humanas, onde os afetos e as flores vicejem em abundância**. Deseja-se que o blog seja um **lumiar do ser**, iluminando as **sementes em terras áridas** e os **solos férteis de lágrimas e sonhos**, guiando o caminho para o pleno **florescer humano** em suas diversas dimensões, como um jardim cuidado com esmero e atenção."

### 4.3. Valores Fundamentais

Os seguintes valores guiarão a criação de conteúdo, a interação com a comunidade e a gestão geral do blog:

- **Valorização da Pessoa:** Acredita-se no **valor intrínseco, na dignidade fundamental e no potencial ilimitado** de cada ser humano, reconhecendo a beleza singular de cada flor em um vasto jardim.
- **Respeito pela Experiência Subjetiva:** Reconhece-se a **importância da perspectiva individual, dos sentimentos profundos, das emoções vívidas e dos significados pessoais**, como as inúmeras cores e fragrâncias que enriquecem um jardim.
- **Ênfase no Crescimento e na Auto-Realização:** Valoriza-se a **tendência natural ao desenvolvimento pessoal, à busca por sentido na existência e à concretização do potencial humano**, como o germinar, o desabrochar e o frutificar das plantas em seu ciclo.
- **Cultivo e Consciência:** Preza-se pela **consciência daquilo que se planta e se colhe ao longo da vida**, reconhecendo a importância de **cultivar os afetos, a resiliência diante dos desafios e um ativismo em prol dos jardins da alma**, pelas flores dos sentimentos e pelos amores que nutrem o ser.
- **Autenticidade e Transparência:** Busca-se **criar conteúdo genuíno, fundamentado em informação de qualidade e em opiniões expressas com clareza e respeito**, como a beleza pura e sem adornos de um jardim em sua essência.
- **Diálogo e Abertura:** Promove-se um **espaço de conversa respeitosa e acolhedora para as mais diversas perspectivas e níveis de conhecimento**, como um jardim que acolhe uma variedade de espécies.
- **Responsabilidade Social:** Acredita-se no **papel do humanismo na construção de comunidades mais engajadas, cooperativas e voltadas para o bem-estar coletivo**, um **ativismo dos jardins** em defesa das flores, dos amores e das dores da sociedade.
- **Ética e Integridade:** Compromete-se com a **produção de conteúdo ético, respeitoso e embasado em fontes confiáveis**, cuidando deste jardim com responsabilidade e zelo.

### 5. Público-Alvo: Definição e Priorização

O blog visa alcançar "todos os corações", mas para fins estratégicos de UX, SEO e conteúdo, definimos a seguinte ordem de prioridade:

1. **Pessoas em busca de autoconhecimento (Prioridade 1):** Indivíduos (leigos em psicologia formal) interessados em desenvolvimento pessoal, bem-estar, compreensão emocional, propósito, relacionamentos, lidando com desafios como ansiedade e estresse.
    - *Implicações:* **UX** deve ser intuitiva, acolhedora, inspiradora, com navegação simples por temas de interesse (ex: "Ansiedade", "Autocompaixão"). **Linguagem** acessível, evitando jargões. **Conteúdo** prático, inspirador, reflexivo, com histórias e ferramentas simples. **SEO** focado em keywords usadas por leigos ("como lidar com...", "dicas para bem-estar").
2. **Estudantes de Psicologia (Prioridade 2):** Alunos buscando aprofundar conhecimentos em humanismo, ACP, Focalização, história da psicologia, comparações teóricas.
    - *Implicações:* **UX** pode incluir seções/tags para conteúdo teórico/acadêmico. **Conteúdo** pode ser mais detalhado, com referências a teóricos (Rogers, Maslow). **SEO** inclui termos técnicos ("teorias humanistas", "fundamentos ACP").
3. **Profissionais da Área (Prioridade 3):** Psicólogos, terapeutas, coaches buscando atualização, reflexões clínicas, estudos de caso, integrações terapêuticas, informações sobre formações.
    - *Implicações:* **UX** facilita acesso a conteúdo avançado, discussões clínicas, informações sobre eventos/cursos. **Conteúdo** inclui reflexões sobre prática, ética, estudos de caso, pesquisas. **SEO** inclui termos avançados ("psicoterapia ACP avançada", "focalização clínica", "supervisão ACP").

**Consideração Geral:** Manter um equilíbrio, priorizando a linguagem e UX para P1 na interface principal, mas oferecendo caminhos claros (via categorias, tags, filtros) para o conteúdo mais específico de P2 e P3. A criação de *personas detalhadas* (documentada separadamente na AI) guiará o desenvolvimento.

### 6. Tom e Estilo de Conteúdo Predominante

O tom de voz do blog será uma combinação cuidadosa, priorizando:

1. **Inspirador:** Motivar os leitores em sua jornada de crescimento e autoconhecimento.
2. **Reflexivo:** Promover a introspecção, o questionamento e a conexão com a experiência subjetiva.
3. **Informativo:** Oferecer conhecimento, perspectivas e ferramentas de forma clara e acessível (especialmente para P1).
4. **Pessoal (Toques):** Incluir elementos da experiência do autor (Daniel Dantas), como o poema inicial e reflexões pessoais (na categoria "Florescer na Vida"), para criar conexão e autenticidade.
5. **Acadêmico (Secundário):** Oferecer conteúdo com rigor teórico e referências para P2 e P3, mas sempre buscando clareza e evitando jargões desnecessários na comunicação geral.

**Personalidade do Blog:** Acolhedor, sábio, encorajador, empático, autêntico, que valoriza a jornada individual.

### 7. Objetivos Específicos Detalhados

Para concretizar a Missão e a Visão, o blog perseguirá os seguintes objetivos específicos:

- **Produção de Conteúdo:**
    - Publicar **com regularidade** artigos de variados formatos (reflexões, análises, guias práticos, introduções acessíveis) que cultivem o entendimento do humanismo e da psicologia humanista (ACP, Focalização, Mindfulness).
    - Explorar a **aplicação dos princípios humanistas** em múltiplos domínios da vida (educação, saúde, trabalho, relações interpessoais, etc.).
    - Desenvolver uma seção de **reflexões** que expressem diferentes olhares dentro da perspectiva humanista, fomentando o pensamento crítico e a diversidade de ideias.
    - Criar conteúdo que **ressoe com as necessidades e desafios** do público interessado, oferecendo ferramentas e conhecimento para "nutrir seu próprio jardim interior".
- **Engajamento do Público e Comunidade:**
    - Atrair e envolver um **público plural**, com foco inicial em P1 ("cultivar vida, transcender, reviver, reinventar-se").
    - **Incentivar a participação** dos leitores através de comentários (via Giscus) e debates construtivos, irrigando as discussões.
    - Promover um **espaço de diálogo respeitoso** e acolhedor para diversas perspectivas.
    - (Futuro) Avaliar expansão para **redes sociais, podcast ou fórum** para fortalecer a comunidade.
- **Alcance e Visibilidade:**
    - **Otimizar a presença online** (SEO, potentially social media) para que mais pessoas encontrem este "jardim de ideias".
    - Estabelecer **laços de colaboração** com outros espaços, autores e instituições alinhadas ao humanismo para expandir o alcance da mensagem.
- **Gestão e Estratégia:**
    - **Acompanhar o desenvolvimento e o impacto** do conteúdo (via KPIs), observando o crescimento e a vitalidade do blog para aprimorar continuamente as estratégias.
    - Considerar a criação de um **informativo (newsletter)** para manter os leitores conectados, com foco nos temas centrais (psicologia humanista, ACP, mindfulness, focalização).
- **Integração Técnica e de UX:**
    - Garantir uma **transição fluida e intuitiva** entre o site principal psicologodanieldantas.com e a seção do blog blogflorescerhumano.
    - Otimizar a **estrutura de URLs e a navegação interna** dentro da pasta blogflorescerhumano para melhorar a UX e o SEO.
    - Manter uma **identidade visual e um tom de voz coesos** com o site principal, mas permitindo distinção clara do conteúdo do blog.

### 8. Estratégias de Conteúdo e Engajamento

### 8.1. Priorização Inicial de Tópicos

Com base na prioridade do público P1, o foco inicial do conteúdo será em:

- Reflexões acessíveis sobre temas do cotidiano (ansiedade, estresse, propósito) sob a ótica humanista.
- Conteúdo prático (ferramentas, técnicas simples de Mindfulness, ACP, Focalização) para desenvolvimento pessoal.
- Histórias de transformação e superação pessoal (na categoria "Florescer na Vida").
- Conteúdo que desmistifique a terapia e a figura do psicólogo humanista (facilitador).
- Explorações introdutórias acessíveis sobre psicologia humanista, ACP, Focalização e Mindfulness.

### 8.2. Propósito Específico do Conteúdo

Além de "cultivar a compreensão", o conteúdo buscará ativamente:

- **Inspirar ações** (de autocuidado, reflexão, busca por apoio).
- **Oferecer ferramentas práticas** para o autoconhecimento e bem-estar.
- **Promover discussões** construtivas nos comentários (Giscus).
- **Construir uma comunidade ativa** e engajada em torno dos valores humanistas.

### 8.3. Construção de Comunidade

- **Foco Inicial:** Comentários via **Giscus** (integrado ao GitHub, fácil moderação).
- **Engajamento:** Incentivar conversas com perguntas ao final dos posts.
- **Expansão Futura:** Considerar presença ativa em redes sociais, podcast e/ou fórum dedicado, conforme o crescimento do blog.
- **Feedback:** Convidar leitores engajados para fornecer feedback.

### 9. Estratégias de Sustentabilidade

### 9.1. Monetização (Alinhada aos Valores)

Para garantir a sustentabilidade do blog a longo prazo, serão consideradas as seguintes formas de receita, sempre com transparência e alinhamento ético:

- **Programas de Afiliados:** Links contextuais (com nofollow e identificação clara) para livros ou cursos relevantes.
- **Patrocínios Curated:** Parcerias selecionadas com marcas/instituições alinhadas aos valores humanistas, com publicidade limitada (ex: 1 banner estático/página) e identificação clara.
- **Eventos:** Workshops ou palestras (online/presenciais) relacionados aos temas do blog.
- **Conteúdo Pago:** Cursos online aprofundados, e-books temáticos (disponibilizados em plataformas acessíveis).
- **Doações:** Opções de contribuição voluntária (Pix, assinaturas recorrentes via plataformas como Apoia-se), apresentadas de forma visível mas não intrusiva.
- **Credibilidade:** Uso de depoimentos para construir confiança em produtos/cursos pagos.
- **CTAs:** Chamadas para Ação claras e persuasivas para cada forma de monetização.
- *(Referência: Documento ESTRATÉGIAS DE SUSTENTABILIDADE FINANCEIRA)*

### 10. Métricas de Sucesso (KPIs)

O sucesso do blog será medido através de indicadores chave de desempenho (KPIs), incluindo:

- **Tráfego do Site:** Visitantes únicos, visualizações de página, origem do tráfego (com foco no crescimento orgânico - SEO).
- **Engajamento do Usuário (UX):** Tempo médio na página, taxa de rejeição (baixa), profundidade de rolagem, compartilhamentos sociais.
- **Comunidade:** Qualidade e quantidade de comentários (Giscus), crescimento de seguidores nas redes sociais (se implementado), inscritos na newsletter.
- **SEO:** Ranking para palavras-chave relevantes, visibilidade orgânica.
- **Conversão (Monetização):** CTR em links de afiliados, receita de patrocínios, inscrições em cursos/eventos pagos, valor e número de doações (se implementadas).

### 11. Análise e Considerações Adicionais (Guia)

- **Foco no Nicho:** O claro foco no humanismo é uma força para SEO e atração de público específico.
- **Linguagem Inspiradora:** A linguagem figurada ("jardim", "cultivar") é um diferencial de identidade, mas deve ser equilibrada com termos claros e palavras-chave de SEO relevantes.
- **Potencial de Diversidade:** A abertura ao diálogo com outras abordagens (Mindfulness, Neuropsicologia) enriquece o conteúdo.
- **Priorização é Chave:** Manter o foco nos objetivos e no público P1 é fundamental para direcionar a criação de conteúdo e as decisões de UX/SEO.

### 12. Conclusão

Os objetivos detalhados nesta documentação formam a base estratégica e filosófica do blog "Florescer Humano". Eles orientarão todas as decisões futuras, desde a criação do menor componente de UI até a definição da estratégia de conteúdo a longo prazo, garantindo que o blog se mantenha fiel à sua missão de ser um espaço fértil para o crescimento e a compreensão humana.

# **Documentação da Arquitetura da Informação: Blog Florescer Humano**

**Projeto:** Blog-site Daniel Dantas - Módulo "Florescer Humano"

**URL Base:** psicologodanieldantas.com/blogflorescerhumano/

**Status:** Em Andamento

**Versão:** 1.0

**Data:** [Data Atual]

## 1. Introdução

### 1.1. O que é Arquitetura da Informação (AI)?

- A Arquitetura da Informação (AI) é a disciplina e a prática de organizar, estruturar e rotular o conteúdo de websites, intranets, comunidades online e software para apoiar a usabilidade e a encontrabilidade.
- No contexto do blog "Florescer Humano", a AI visa criar uma estrutura lógica e intuitiva que permita aos usuários navegar facilmente pelo conteúdo, encontrar informações relevantes e ter uma experiência significativa e enriquecedora.
- Uma AI bem definida é crucial para a **Experiência do Usuário (UX)**, pois facilita a jornada do usuário, e para a **Otimização para Mecanismos de Busca (SEO)**, pois ajuda os motores de busca a entender e indexar o conteúdo de forma eficaz.

### 1.2. Propósito desta Documentação

- Este documento detalha a Arquitetura da Informação planejada para o blog "Florescer Humano", que funcionará como um módulo dentro do site principal psicologodanieldantas.com.
- Serve como um guia para o desenvolvimento do blog, garantindo que a estrutura do conteúdo, a navegação e a rotulagem estejam alinhadas com os objetivos do blog, as necessidades do público-alvo e as melhores práticas de UX e SEO.
- Visa fornecer clareza sobre como o conteúdo será organizado e acessado, facilitando a colaboração entre as partes interessadas (desenvolvedores, criadores de conteúdo, etc.).

## 2. Objetivos do Blog e da AI

### 2.1. Objetivos Principais do Blog "Florescer Humano"

- **Missão:** Cultivar a compreensão e a vivência dos princípios do humanismo, com foco especial na psicologia humanista (ACP, Focalização) e diálogo com outras abordagens (Mindfulness, Neuropsicologia), oferecendo um "jardim de reflexão, aprendizado e encontro".
- **Visão:** Tornar-se uma referência online essencial para quem busca aprofundar a compreensão e prática do humanismo, criando uma comunidade engajada e guiando para o pleno "florescer humano".
- **Valores:** Valorização da Pessoa, Respeito pela Experiência Subjetiva, Ênfase no Crescimento e Auto-Realização, Cultivo e Consciência, Autenticidade e Transparência, Diálogo e Abertura, Responsabilidade Social, Ética e Integridade.
- **Inspiração:** Guiado pelo poema "Sobre Flores, Jardins e Amores" de Daniel Dantas, que evoca o cultivo de afetos, a resiliência e a busca pela autenticidade.

### 2.2. Objetivos da Arquitetura da Informação

- **Facilitar a Encontrabilidade:** Garantir que os usuários possam encontrar facilmente artigos e recursos sobre humanismo, psicologia humanista, autoconhecimento, bem-estar e outros temas abordados.
- **Melhorar a Navegabilidade:** Criar um sistema de navegação claro, consistente e intuitivo que permita aos usuários se moverem pelo blog sem esforço.
- **Apoiar a Compreensão:** Organizar o conteúdo de forma lógica para que os usuários possam entender a relação entre diferentes tópicos e construir conhecimento progressivamente.
- **Promover o Engajamento:** Estruturar o conteúdo de forma a incentivar a exploração, a leitura de múltiplos artigos e a interação (comentários, compartilhamentos).
- **Otimizar para SEO:** Utilizar estruturas de URL claras, rotulagem consistente com palavras-chave relevantes e uma organização que facilite a indexação pelos motores de busca.
- **Garantir Coesão com o Site Principal:** Assegurar uma transição fluida e uma identidade visual/tom de voz coesos entre o blog e o site psicologodanieldantas.com, embora o blog mantenha sua autonomia organizacional.
- **Suportar a Escalabilidade:** Criar uma estrutura flexível que possa acomodar o crescimento futuro do conteúdo sem comprometer a usabilidade.

## 3. Público-Alvo

### 3.1. Definição e Priorização

- A AI é projetada com foco nos seguintes públicos, em ordem de prioridade:
    1. **Pessoas em busca de autoconhecimento:** Indivíduos interessados em desenvolvimento pessoal, bem-estar emocional, encontrar propósito, lidar com ansiedade/estresse, e que buscam uma abordagem mais humana e reflexiva.
    2. **Estudantes de Psicologia:** Alunos que buscam aprofundar seus conhecimentos em psicologia humanista, ACP, Focalização e abordagens relacionadas, procurando fundamentos teóricos, históricos e aplicações práticas.
    3. **Profissionais da Área (Psicólogos, Terapeutas, etc.):** Profissionais que buscam atualização, reflexões sobre a prática clínica, estudos de caso, informações sobre formações e integração com outras abordagens.

### 3.2. Implicações da Priorização na AI

- **Linguagem e Rotulagem:** A linguagem utilizada nas categorias, títulos e navegação deve ser primariamente **acessível e inspiradora** para o público leigo (Prioridade 1). Termos técnicos podem ser usados em conteúdos específicos para Prioridades 2 e 3, mas a navegação principal deve ser clara para todos.
- **Estrutura de Conteúdo:** A organização deve facilitar o acesso a conteúdos práticos, reflexivos e introdutórios (para P1), mas também permitir a descoberta de conteúdos teóricos e aprofundados (para P2 e P3), possivelmente através de subcategorias ou seções dedicadas.
- **Navegação:** Deve ser **simples, intuitiva e acolhedora**. Categorias como "Ansiedade", "Propósito de Vida", "Autocompaixão" podem ser mais diretas para P1.
- **SEO:** As palavras-chave primárias devem refletir as buscas do público leigo ("como lidar com ansiedade", "autoconhecimento"), mas palavras-chave mais técnicas ("teoria ACP", "focalização Gendlin") também devem ser consideradas para P2 e P3.

## 4. Estratégia de Conteúdo (Impacto na AI)

### 4.1. Tipos de Conteúdo

- Artigos (reflexões, análises, guias práticos, introduções teóricas, estudos de caso).
- Poemas e textos pessoais (na categoria "Florescer na Vida").
- Materiais adicionais (e-books, guias, referências, vídeos, podcasts - na seção "Materiais").
- Conteúdo interativo (potencialmente enquetes, comentários via Giscus).

### 4.2. Tom de Voz Predominante

- **Inspirador, Reflexivo e Informativo**, com toques **Pessoais**.
- A AI deve refletir esse tom através de rótulos acolhedores e uma estrutura que convide à exploração e introspecção.
- Conteúdo mais **Acadêmico** será oferecido, mas mantendo a acessibilidade como princípio.

### 4.3. Temas Principais

- Humanismo, Psicologia Humanista (ACP, Focalização), Mindfulness, Neuropsicologia (diálogo), Autoconhecimento, Desenvolvimento Pessoal, Bem-Estar Emocional, Saúde Mental, Relacionamentos, Propósito de Vida, Autenticidade.
- A estrutura de categorias e subcategorias da AI deve refletir diretamente esses temas.

## 5. Sistemas de Organização

### 5.1. Esquema de Organização Principal: Hierárquico/Temático

- O blog será organizado primariamente por **temas**, representados pelas categorias principais. Esta estrutura hierárquica permite aos usuários navegar do geral para o específico.

### 5.2. Estrutura do Site (Mapa Textual Simplificado)

      `/ (psicologodanieldantas.com - Site Principal)
└── /blogflorescerhumano/ (Página Inicial do Blog)
    ├── /artigos/ (Listagem de Todos os Artigos - Pode ser a própria página inicial ou uma seção separada)
    ├── /[categoria]/
    │   ├── page.tsx (Página da Categoria - Lista artigos da categoria)
    │   └── [slug]/
    │       └── page.tsx (Página de Artigo Individual)
    ├── /categorias/ (Página listando/descrevendo as categorias)
    ├── /sobre/ (Página Sobre o Blog)
    ├── /materiais/ (Página com Recursos Adicionais)
    ├── /midias/ (Página com Recomendações de Mídias)
    ├── /contato/ (Página de Contato)
    ├── /politica-privacidade/ (Página de Política de Privacidade)
    └── /em-construcao/ (Página Padrão para Conteúdo Futuro)`

### 5.3. Categorias Principais

- A organização do conteúdo será baseada nas seguintes categorias principais, definidas para atender aos diferentes públicos e temas:
    1. **Autoconhecimento e Desenvolvimento Pessoal:**
        - **Função:** Central para o público prioritário (P1). Aborda a jornada de se conhecer melhor, crescimento, autoestima, propósito, etc., sob a ótica humanista.
        - **Conteúdo:** Reflexões, ferramentas práticas (inspiradas em ACP, Focalização, Mindfulness), histórias de transformação, desmistificação da terapia.
        - **SEO Keywords (Exemplos):** autoconhecimento, desenvolvimento pessoal, como se conhecer melhor, aumentar autoestima, propósito de vida, autocompaixão.
    2. **Psicologia Humanista e Abordagens Relacionadas:**
        - **Função:** Atende a todos os públicos, com níveis variados de profundidade. Explora os fundamentos teóricos e práticos das abordagens centrais do blog.
        - **Conteúdo:** Introduções acessíveis, fundamentos teóricos (Rogers, Maslow), conceitos chave (tendência atualizante, empatia), ACP, Focalização, Mindfulness, diálogos com Neuropsicologia.
        - **SEO Keywords (Exemplos):** psicologia humanista, abordagem centrada na pessoa, ACP, Carl Rogers, focalização Gendlin, mindfulness, Maslow hierarquia necessidades.
    3. **Bem-Estar Emocional e Saúde Mental:**
        - **Função:** Foco em questões práticas de bem-estar relevantes para P1.
        - **Conteúdo:** Lidar com ansiedade, estresse, angústia; regulação emocional; técnicas de mindfulness para bem-estar.
        - **SEO Keywords (Exemplos):** como lidar com ansiedade, aliviar estresse, regulação emocional, mindfulness para ansiedade, saúde mental.
    4. **Relacionamentos e Conexões Humanas:**
        - **Função:** Explora a aplicação dos princípios humanistas nas interações sociais.
        - **Conteúdo:** Comunicação autêntica, empatia, construção de conexões significativas, dificuldades relacionais.
        - **SEO Keywords (Exemplos):** relacionamentos saudáveis, comunicação interpessoal, empatia, conexão emocional, psicologia humanista relacionamentos.
    5. **Florescer na Vida:**
        - **Função:** Categoria mais inspiracional e pessoal, alinhada à metáfora do blog.
        - **Conteúdo:** Histórias de transformação, reflexões sobre potencial humano, poemas, diários, aplicação do humanismo em diferentes domínios (educação, trabalho).
        - **SEO Keywords (Exemplos):** florescer humano, crescimento pessoal, viver plenamente, autenticidade, sentido da vida, superação pessoal.

### 5.4. Subcategorias

- **Função:** Oferecer um nível mais granular de organização dentro das categorias principais, facilitando a navegação para tópicos específicos e atendendo às necessidades dos públicos P2 e P3.
- **Implementação:** Serão criadas conforme a necessidade e o volume de conteúdo em cada categoria principal.
- **Exemplos (Categoria: Psicologia Humanista):**
    - Fundamentos Teóricos da ACP
    - Pesquisas em Mindfulness
    - Aplicações da Focalização
    - Diálogos com a Neuropsicologia
- **Requisitos:** Devem ser tematicamente relevantes à categoria pai, ter nomes claros e descritivos (com keywords de SEO), e suportar a navegação intuitiva.

### 5.5. Tags

- **Função:** Complementar as categorias, permitindo uma organização mais flexível e multifacetada (esquema de organização por facetas). Conectam artigos sobre tópicos específicos que podem pertencer a diferentes categorias.
- **Implementação:** Cada artigo poderá ter múltiplas tags relevantes (ex: "ansiedade", "Carl Rogers", "mindfulness para iniciantes", "escrita terapêutica").
- **Uso na Navegação:** Haverá a possibilidade de filtrar a listagem de artigos por tags. Páginas de tags individuais podem ser consideradas futuramente.

## 6. Sistemas de Navegação

### 6.1. Navegação Global (Principal) - Navbar

- **Função:** Fornecer acesso consistente às principais seções do blog a partir de qualquer página.
- **Estrutura Proposta:**
    - Logo/Branding (Clicável do blog Florescer humano levando para home do blog) - Esquerda
    - Espaço de Respiro
    - Itens de Menu (Centro):
    
    - Ícone de Lupa (Abre campo de busca)
    - Início (Link para /blogflorescerhumano/)
    - Artigos (Link para listagem/página inicial do blog)
    - Categorias (Link para página de categorias ou menu dropdown)
    - Sobre (Link para /blogflorescerhumano/sobre/)
    - Materiais (Link para /blogflorescerhumano/materiais/)
    - Contato (Link para /blogflorescerhumano/contato/)
    
    - Botão transparente "← Site Daniel Dantas" (Link para psicologodanieldantas.com) - Extrema Direita
- **Responsividade:** A navbar se adaptará a diferentes tamanhos de tela, transformando-se em um menu "sanduíche" em dispositivos móveis.

### 6.2. Navegação Local

- **Função:** Permitir a navegação dentro de uma seção específica ou entre itens relacionados.
- **Implementação:**
    - **Páginas de Categoria:** Listagem dos artigos daquela categoria, com paginação se necessário.
    - **Páginas de Artigo:** Links para categoria(s) do artigo, tags associadas.
    - **Breadcrumbs (Opcional):** Podem ser implementados para mostrar a localização do usuário na hierarquia do site (ex: Início > Psicologia Humanista > Artigo sobre ACP).

### 6.3. Navegação Contextual

- **Função:** Conectar conteúdos relacionados, incentivando a exploração e aumentando o tempo de permanência.
- **Implementação:**
    - **Links Internos:** Dentro do corpo dos artigos, links para outros posts ou páginas relevantes do blog.
    - **Seção "Conteúdo Relacionado":** Ao final de cada artigo, sugestões de outros posts com temas similares (baseado em categoria, tags ou análise de conteúdo).

### 6.4. Navegação Suplementar

- **Função:** Fornecer acesso a informações secundárias ou rotas alternativas.
- **Implementação:**
    - **Rodapé (Footer):** Conterá links para "Política de Privacidade", "Contato", возможно "Mapa do Site", e link de retorno ao site principal.
    - **Mapa do Site (Opcional):** Uma página dedicada listando toda a estrutura de conteúdo do blog, útil para usuários e SEO.

## 7. Sistema de Rotulagem (Labeling)

- **Função:** Usar linguagem clara e consistente para representar o conteúdo nos menus, títulos, links e categorias.
- **Princípios:**
    - **Clareza:** Os rótulos devem ser fáceis de entender pelo público-alvo prioritário.
    - **Consistência:** Usar os mesmos termos para os mesmos conceitos em todo o blog.
    - **Foco no Usuário:** Usar a linguagem que o público-alvo utiliza (identificada na pesquisa de keywords).
    - **Otimização para SEO:** Incorporar palavras-chave relevantes nos rótulos de forma natural.
- **Exemplos:**
    - Nomes de Categorias (já definidos).
    - Títulos de Artigos (devem ser informativos e conter keywords).
    - Texto dos Links (ex: "Leia mais sobre Autoconhecimento" em vez de apenas "Clique aqui").

## 8. Sistema de Busca

- **Função:** Permitir que usuários encontrem conteúdo específico rapidamente, digitando palavras-chave. Essencial para a encontrabilidade.
- **Implementação:**
    - **Navbar:** Ícone de lupa que expande para um campo de busca.
    - **Página de Listagem de Artigos:** Campo de busca proeminente.
    - **Página de Resultados:** Apresentará os artigos relevantes para a busca, possivelmente com trechos destacados.
- **Tecnologia:** A busca pode ser implementada via Supabase (buscando no conteúdo dos artigos) ou utilizando serviços de busca externos se necessário futuramente.

## 9. Blueprints de Páginas Chave (Visão Geral da AI)

*(Esta seção descreve o propósito e os elementos essenciais de cada página principal do ponto de vista da AI, detalhando como elas contribuem para a organização e navegação).*

### 9.1. Página Inicial do Blog (/blogflorescerhumano/)

- **Função AI:** Porta de entrada principal, oferece visão geral, direciona para conteúdos específicos, estabelece o tom e o propósito do blog.
- **Elementos Essenciais (AI):** Navbar, Introdução/Poema, Declaração de Princípios (resumo/link), Barra de Pesquisa, Filtro/Links de Categorias em Destaque, Artigos em Destaque/Recentes (com imagem, título, resumo, categoria), Link para "Sobre", CTA para Newsletter, Link para Site Principal.

### 9.2. Listagem de Artigos (/blogflorescerhumano/ ou /blogflorescerhumano/artigos/)

- **Função AI:** Apresenta o inventário completo de artigos, facilita a descoberta e exploração de todo o conteúdo publicado.
- **Elementos Essenciais (AI):** Navbar, Título da Seção, Barra de Pesquisa, Filtros (Categorias, Tags, Data), Opções de Ordenação (Data, Popularidade), Grid/Lista de Artigos (com imagem, título, resumo, data, autor, categoria/tags), Paginação (se necessário), Rodapé.

### 9.3. Página de Artigo Individual (/blogflorescerhumano/[categoria]/[slug]/)

- **Função AI:** Apresenta o conteúdo detalhado de um artigo específico, ponto focal da leitura e engajamento.
- **Elementos Essenciais (AI):** Navbar, Título do Artigo, Metadados (Autor, Data, Categoria), Imagem de Destaque, Conteúdo Estruturado (headings, parágrafos, listas, imagens internas), Links Internos Contextuais, Tags, Informações sobre o Autor (breve), Seção "Conteúdo Relacionado", Comentários (Giscus), Botões de Compartilhamento Social, Rodapé.

### 9.4. Página de Categorias (/blogflorescerhumano/[categoria]/)

- **Função AI:** Agrupa e lista todos os artigos pertencentes a uma categoria específica, facilitando a exploração temática.
- **Elementos Essenciais (AI):** Navbar, Título da Categoria (com breve descrição opcional otimizada para SEO), Lista/Grid de Artigos da Categoria (similar à Listagem Geral, mas filtrada), Paginação (se necessário), Rodapé.

### 9.5. Página "Sobre" (/blogflorescerhumano/sobre/)

- **Função AI:** Apresenta a identidade, propósito, valores, abordagens teóricas e equipe do blog, construindo confiança e conexão.
- **Elementos Essenciais (AI):** Navbar, Título da Seção, Introdução, História/Poema, Declaração de Princípios (detalhada), Abordagens Teóricas (ACP, Focalização, etc.), Equipe/Colaboradores, Convite à Colaboração, Teóricos Principais, FAQ (opcional), Link para Contato, Rodapé.

### 9.6. Página "Materiais" (/blogflorescerhumano/materiais/)

- **Função AI:** Organiza e oferece acesso a recursos adicionais (e-books, guias, referências, etc.) que complementam os artigos.
- **Elementos Essenciais (AI):** Navbar, Título da Seção, Introdução/Descrição, Filtros/Organização (por tipo, por tema), Lista de Materiais (com título, descrição, imagem/ícone, link para acesso/download), Rodapé.

### 9.7. Página "Mídias" (/blogflorescerhumano/midias/)

- **Função AI:** Centraliza e organiza recomendações de mídias externas (podcasts, vídeos, playlists, canais, documentários).
- **Elementos Essenciais (AI):** Navbar, Título da Seção, Barra de Pesquisa (dentro da seção), Tabs/Filtros por Tipo de Mídia, Listagem de Mídias Recomendadas (com informações relevantes e links), Rodapé.

### 9.8. Página "Contato" (/blogflorescerhumano/contato/)

- **Função AI:** Fornece os canais para comunicação direta com o blog (dúvidas, sugestões, parcerias).
- **Elementos Essenciais (AI):** Navbar, Título da Seção, Informações de Contato (e-mail), Formulário de Contato Geral, Links/Formulários para Propostas de Parceria/Submissão (se aplicável), Link para FAQ (opcional), Rodapé.

### 9.9. Páginas Adicionais (Política de Privacidade, Em Construção)

- **Função AI:** Fornecer informações legais essenciais e gerenciar expectativas sobre conteúdo futuro, mantendo a consistência da estrutura e navegação.
- **Elementos Essenciais (AI):** Navbar, Conteúdo Específico da Página (texto legal ou aviso de construção), Rodapé.

## 10. Implementação Técnica (Next.js, Supabase, Giscus)

### 10.1. Estrutura de Pastas (src/app/blogflorescerhumano/)

- A estrutura de pastas seguirá a organização definida no Mapa do Site, utilizando o App Router do Next.js.
- **[categoria]/[slug]/page.tsx:** Rota dinâmica para artigos individuais.
- **[categoria]/page.tsx:** Rota dinâmica para páginas de categoria.
- **components/:** Componentes React específicos do blog (organizados por Article, UI, GiscusComments, etc.).
- **hooks/data/:** Hooks customizados para buscar dados do Supabase (useSupabaseArticle, useSupabaseArticles).
- **services/supabase/:** Funções para interagir com o Supabase (buscar/salvar artigos, categorias, etc.).
- **layout.tsx:** Layout principal do blog, incluindo Navbar e Footer.
- **page.tsx:** Componente da Página Inicial do Blog.
- Outras pastas (styles, templates, utils) conforme necessário.

### 10.2. Estrutura de URL

- URLs serão semânticas e refletirão a estrutura hierárquica, incluindo categorias e slugs otimizados para SEO.
- Exemplo: psicologodanieldantas.com/blogflorescerhumano/autoconhecimento/entendendo-a-autoestima

### 10.3. Integração com Supabase

- Supabase será utilizado para gerenciar o conteúdo principal: artigos, categorias, subcategorias, autores, tags, assinantes da newsletter.
- Os serviços (services/supabase/) encapsularão as chamadas à API do Supabase.
- Os hooks (hooks/data/) facilitarão o acesso e gerenciamento do estado desses dados nos componentes.

### 10.4. Integração com Giscus

- Giscus será utilizado para o sistema de comentários, eliminando a necessidade de gerenciar comentários no Supabase.
- O componente GiscusComments.tsx será responsável por renderizar e configurar o Giscus nas páginas de artigo.

### 10.5. Imagens

- Imagens de capa dos artigos serão armazenadas em /public/blogflorescerhumano/.
- O componente next/image será utilizado para otimização e renderização.

## 11. Considerações de SEO na AI

- **Pesquisa de Palavras-chave:** Informa a rotulagem de categorias, tags e a criação de conteúdo.
- **Estrutura de URL:** URLs claras, curtas e com palavras-chave.
- **Rotulagem:** Uso consistente de palavras-chave nos títulos (H1, title tag), headings (H2, H3), nomes de categorias e links.
- **Linkagem Interna:** A estrutura hierárquica e a navegação contextual (links internos, conteúdo relacionado) ajudam a distribuir a autoridade da página (link juice) e a indicar a relevância do conteúdo aos motores de busca.
- **Organização do Conteúdo:** Agrupar conteúdo por temas (categorias) ajuda os motores de busca a entenderem a especialidade do blog.
- **Sitemap:** Um sitemap XML deve ser gerado e submetido aos motores de busca para facilitar a indexação.

## 12. Considerações de UX na AI

- **Encontrabilidade:** A principal meta da AI. Uma boa estrutura, navegação e busca garantem que os usuários encontrem o que precisam.
- **Usabilidade:** Navegação intuitiva, rotulagem clara e consistência reduzem a carga cognitiva do usuário.
- **Compreensão:** A organização lógica do conteúdo ajuda os usuários a entenderem os temas e a relação entre eles.
- **Confiança e Credibilidade:** Uma estrutura organizada e profissional, juntamente com páginas como "Sobre" e "Contato", constrói confiança.
- **Acessibilidade:** A estrutura de headings e a rotulagem clara também beneficiam a acessibilidade para usuários de leitores de tela.

## 13. Manutenção e Escalabilidade

- A estrutura modular (/blogflorescerhumano/) facilita a manutenção isolada do blog.
- A organização por categorias e o uso de rotas dinâmicas permitem adicionar novo conteúdo facilmente sem quebrar a estrutura existente.
- A separação clara entre componentes, serviços e hooks promove a reutilização e a manutenção do código.
- A AI deve ser revisada periodicamente à medida que o blog cresce, para garantir que continue atendendo às necessidades dos usuários e aos objetivos do negócio.

---

Esta documentação fornece uma base sólida para o desenvolvimento da Arquitetura da Informação do blog "Florescer Humano". Ela deve ser usada como referência contínua durante as fases de design, desenvolvimento e criação de conteúdo, e pode ser atualizada conforme necessário.

# **Estrutura Detalhada de Arquivos e Pastas (Next.js App Router)**

Okay, vamos expandir a estrutura do site definida na Arquitetura da Informação para uma representação de arquivos e pastas mais detalhada, seguindo as melhores práticas de organização para um projeto Next.js (com App Router), React, e considerando a integração com Supabase e Giscus.

Esta estrutura visa a **modularidade**, **clareza**, **manutenção** e **escalabilidade**, mantendo o blog "Florescer Humano" como um módulo bem definido dentro do site principal.

---

## **Estrutura Detalhada de Arquivos e Pastas (Next.js App Router)**

```sql
      .
├── public/                     # Arquivos estáticos
│   ├── psicologodanieldantas/ # Imagens e assets do site principal
│   │   └── ...
│   └── blogflorescerhumano/    # Imagens de capa e assets específicos do blog
│       ├── importancia-da-empatia.png
│       ├── mindfulness-autorregulacao.png
│       └── ...
├── src/
│   ├── app/                    # Diretório principal do App Router
│   │   ├── layout.tsx          # Layout RAIZ do site (psicologodanieldantas.com)
│   │   ├── page.tsx            # Página inicial do site (psicologodanieldantas.com)
│   │   ├── global.css          # Estilos globais do site
│   │   └── blogflorescerhumano/  # === MÓDULO DO BLOG FLORESCER HUMANO ===
│   │       │
│   │       ├── layout.tsx        # Layout específico para TODO o blog (NavbarBlog, FooterBlog, Contextos?)
│   │       ├── page.tsx          # Página inicial DO BLOG (/blogflorescerhumano) - Lista artigos, categorias etc.
│   │       ├── loading.tsx       # UI de carregamento para a página inicial do blog
│   │       ├── error.tsx         # UI de erro para a página inicial do blog
│   │       ├── not-found.tsx     # UI 404 específica para o blog
│   │       │
│   │       ├── categorias/       # Rota estática para listar/descrever categorias
│   │       │   ├── page.tsx      # Componente da página que lista/descreve as categorias
│   │       │   └── loading.tsx   # UI de carregamento para a listagem de categorias
│   │       │
│   │       ├── [categoria]/      # Rota dinâmica para páginas de categoria individual
│   │       │   ├── page.tsx      # Componente que busca e lista artigos de UMA categoria (params.categoria)
│   │       │   ├── loading.tsx   # UI de carregamento para a página de categoria
│   │       │   ├── error.tsx     # UI de erro para a página de categoria
│   │       │   └── [slug]/       # Rota dinâmica para páginas de artigo individual
│   │       │       ├── page.tsx  # Componente que busca e exibe UM artigo (params.categoria, params.slug)
│   │       │       ├── loading.tsx # UI de carregamento para a página do artigo
│   │       │       └── error.tsx # UI de erro para a página do artigo
│   │       │
│   │       ├── sobre/
│   │       │   └── page.tsx      # Componente da página "Sobre"
│   │       │
│   │       ├── materiais/
│   │       │   └── page.tsx      # Componente da página "Materiais"
│   │       │
│   │       ├── midias/
│   │       │   └── page.tsx      # Componente da página "Mídias"
│   │       │
│   │       ├── contato/
│   │       │   └── page.tsx      # Componente da página "Contato" (provavelmente 'use client')
│   │       │
│   │       ├── politica-privacidade/
│   │       │   └── page.tsx      # Componente da página "Política de Privacidade"
│   │       │
│   │       ├── em-construcao/
│   │       │   └── page.tsx      # Componente da página "Em Construção"
│   │       │
│   │       ├── components/       # Componentes React específicos do Blog
│   │       │   ├── Article/      # Componentes relacionados a Artigos
│   │       │   │   ├── ArticleCardBlog.tsx      # Card para listagem de artigos
│   │       │   │   ├── ArticleDetailBlog.tsx    # Componente principal para exibir o detalhe do artigo
│   │       │   │   ├── ArticleListBlog.tsx      # Componente para renderizar a lista/grid de artigos
│   │       │   │   └── ArticleMetadataBlog.tsx  # Exibe metadados (autor, data, categoria)
│   │       │   │
│   │       │   ├── Category/     # Componentes relacionados a Categorias
│   │       │   │   ├── CategoryLabelBlog.tsx    # Label/Tag para exibir a categoria de um artigo
│   │       │   │   └── CategoryListBlog.tsx     # Componente para listar categorias (ex: na sidebar ou página /categorias)
│   │       │   │
│   │       │   ├── UI/           # Componentes de UI genéricos, mas ESPECÍFICOS do blog
│   │       │   │   ├── ButtonBlog.tsx         # Botão com estilo do blog
│   │       │   │   ├── SearchBarBlog.tsx      # Barra de busca
│   │       │   │   ├── PaginationBlog.tsx     # Componente de paginação
│   │       │   │   ├── FilterDropdownBlog.tsx # Dropdown para filtros
│   │       │   │   └── ...
│   │       │   │
│   │       │   ├── GiscusComments.tsx # Componente para integrar comentários Giscus ('use client')
│   │       │   ├── NewsletterFormBlog.tsx # Formulário de inscrição na newsletter ('use client')
│   │       │   ├── ContactFormBlog.tsx    # Formulário de contato ('use client')
│   │       │   └── AuthorInfoBlog.tsx     # Componente para exibir informações do autor
│   │       │
│   │       ├── hooks/            # Hooks customizados específicos do Blog
│   │       │   ├── data/         # Hooks para buscar e gerenciar dados (Supabase)
│   │       │   │   ├── useSupabaseArticle.ts    # Hook para buscar um artigo específico
│   │       │   │   ├── useSupabaseArticles.ts   # Hook para buscar múltiplos artigos (com filtros/paginação)
│   │       │   │   └── useSupabaseCategories.ts # Hook para buscar categorias
│   │       │   └── ui/           # Hooks relacionados a interações de UI (opcional)
│   │       │       └── useSearchFilter.ts     # Ex: Lógica de estado para filtros de busca
│   │       │
│   │       ├── services/         # Lógica de interação com APIs/Bancos de Dados
│   │       │   └── supabase/     # Funções específicas para interagir com Supabase
│   │       │       ├── articleService.ts      # Funções: getArticles, getArticleBySlug, getArticlesByCategory, etc.
│   │       │       ├── categoryService.ts     # Funções: getCategories, getCategoryBySlug
│   │       │       ├── tagService.ts          # Funções: getTags, getArticlesByTag
│   │       │       ├── authorService.ts       # Funções: getAuthorById
│   │       │       └── newsletterService.ts   # Funções: subscribeToNewsletter
│   │       │
│   │       ├── styles/           # Estilos específicos do Blog (CSS Modules, SCSS, etc.)
│   │       │   ├── blog-globals.css
│   │       │   ├── article-detail.module.css
│   │       │   └── ...
│   │       │
│   │       ├── templates/        # Templates de página reutilizáveis
│   │       │   ├── ArticleTemplateBlog.tsx    # Estrutura padrão para página de artigo
│   │       │   ├── CategoryTemplateBlog.tsx   # Estrutura padrão para página de categoria
│   │       │   └── StaticPageTemplateBlog.tsx # Estrutura padrão para páginas estáticas (Sobre, Contato...)
│   │       │
│   │       └── utils/            # Funções utilitárias específicas do Blog
│   │           ├── helpers.ts      # Funções gerais (formatação de data, etc.)
│   │           ├── seoUtils.ts     # Funções para gerar metadados dinâmicos
│   │           └── supabaseUtils.ts  # Funções auxiliares para interagir com Supabase (opcional)
│   │
│   ├── components/             # Componentes REUTILIZÁVEIS em TODO o site (Navbar Principal, Footer Principal)
│   │   ├── Navbar.tsx
│   │   └── Footer.tsx
│   ├── lib/                      # Bibliotecas, clientes de API, etc. GLOBAIS do site
│   │   └── supabaseClient.ts     # Configuração do cliente Supabase GLOBAL (usado pelo blog)
│   └── types/                    # Definições de tipos TypeScript GLOBAIS
│       ├── index.ts
│       └── supabase.ts           # Tipos gerados pelo Supabase CLI (se usar)
│
├── .env.local                # Variáveis de ambiente (Supabase URL/Key)
├── next.config.js            # Configurações do Next.js
├── tsconfig.json             # Configurações do TypeScript
└── package.json              # Dependências do projeto
```

---

### **Explicação da Estrutura e Boas Práticas:**

1. **Modularidade (Módulo do Blog):**
    - Todo o código específico do blog está contido dentro de src/app/blogflorescerhumano/. Isso facilita a manutenção, o desenvolvimento isolado e evita conflitos com o restante do site psicologodanieldantas.com.
    - Componentes de UI globais (Navbar.tsx, Footer.tsx) ficam fora do módulo do blog, em src/components/, para serem reutilizados em todo o site.
    - A configuração do cliente Supabase (supabaseClient.ts) pode ficar em src/lib/ para ser acessível globalmente, pois outros módulos do site podem precisar dela.
2. **Roteamento (App Router):**
    - A estrutura de pastas dentro de blogflorescerhumano/ mapeia diretamente as URLs (ex: /blogflorescerhumano/sobre/ é definido por src/app/blogflorescerhumano/sobre/page.tsx).
    - **Rotas Dinâmicas ([categoria], [slug]):** Permitem criar páginas programaticamente para cada categoria e artigo, buscando dados com base nos parâmetros da URL (params).
    - **page.tsx:** Define a UI principal de cada rota. Geralmente são Server Components (RSCs) que podem buscar dados diretamente (usando async/await).
    - **layout.tsx:** Define a UI compartilhada para um segmento de rota e seus filhos. O layout.tsx dentro de blogflorescerhumano/ envolve todas as páginas do blog.
    - **loading.tsx, error.tsx, not-found.tsx:** Convenções do Next.js para lidar com estados de carregamento, erros e páginas não encontradas de forma granular e com boa UX.
3. **Organização de Componentes:**
    - **components/ (dentro do blog):** Contém subpastas por funcionalidade (Article/, Category/) ou tipo (UI/). Isso melhora a encontrabilidade e a coesão.
    - **Nomenclatura:** Usar o sufixo Blog (ex: ButtonBlog.tsx) evita colisões de nomes com componentes do site principal e deixa claro o escopo do componente.
    - **Server vs. Client Components:** Componentes que precisam de interatividade, estado (useState) ou hooks de ciclo de vida (useEffect) devem ser marcados com 'use client' no topo do arquivo (ex: GiscusComments.tsx, NewsletterFormBlog.tsx, ContactFormBlog.tsx). Componentes puramente de apresentação ou que buscam dados no servidor permanecem como RSCs (Server Components).
4. **Gerenciamento de Dados (Supabase):**
    - **services/supabase/:** Centraliza toda a lógica de interação com o Supabase. Funções como getArticles retornam os dados ou erros. Isso desacopla a lógica de dados dos componentes.
    - **hooks/data/:** Hooks customizados (useSupabaseArticle, etc.) podem encapsular a chamada aos serviços e o gerenciamento do estado dos dados (embora em RSCs, a busca seja direta). Podem ser mais úteis em Client Components ou para lógica de estado compartilhada.
    - **Tipagem:** Usar TypeScript e definir tipos claros para os dados retornados pelo Supabase (em src/types/ ou gerados automaticamente) é crucial para a robustez.
5. **Estilos (styles/):**
    - Manter estilos específicos do blog isolados. CSS Modules (*.module.css) é uma boa prática para evitar conflitos de classes CSS.
6. **Templates (templates/):**
    - Componentes que definem a estrutura/layout geral de tipos de página (artigo, categoria). Eles recebem dados como props e organizam os componentes menores (ArticleDetailBlog, ArticleListBlog, etc.). Isso promove a reutilização do layout.
7. **Utilitários (utils/):**
    - Funções puras e reutilizáveis que não se encaixam em outras categorias (formatação, validação, cálculos, etc.).
8. **Variáveis de Ambiente (.env.local):**
    - Armazena chaves de API e URLs do Supabase de forma segura. Usar o prefixo NEXT_PUBLIC_ para variáveis que precisam ser acessadas no *browser*.

### **Próximos Passos na Implementação:**

1. Criar a estrutura de pastas conforme definido acima.
2. Configurar o cliente Supabase (supabaseClient.ts) e as variáveis de ambiente.
3. Definir os esquemas das tabelas no Supabase (artigos, categorias, etc.).
4. Implementar as funções básicas nos services/supabase/.
5. Começar a construir os page.tsx e layout.tsx principais do blog, buscando dados dos serviços.
6. Desenvolver os componentes reutilizáveis em components/.
7. Integrar o Giscus no template/componente de artigo.
8. Implementar os formulários (Contato, Newsletter) como Client Components.
9. Adicionar estilos e refinar a UX.

Esta estrutura expandida fornece um roteiro claro e organizado para construir o blog "Florescer Humano" de forma robusta e alinhada com as melhores práticas modernas de desenvolvimento web.

# **Documentação do Esquema de Banco de Dados Supabase para o Blog "Florescer Humano"**

### 1. Introdução

Este documento descreve a estrutura do banco de dados PostgreSQL gerenciado pelo Supabase, projetado para suportar o conteúdo e as funcionalidades do blog "Florescer Humano". O esquema visa organizar os dados de forma eficiente, segura e escalável, alinhando-se com a Arquitetura da Informação e os requisitos funcionais definidos para o blog.

### 2. Princípios e Convenções Gerais

- **Segurança (RLS):** A segurança é primordial. **Row Level Security (RLS)** será habilitada para *todas* as tabelas. Políticas específicas definirão quem pode acessar (ler) e modificar (escrever) os dados em cada tabela, garantindo que apenas usuários/roles autorizados possam interagir com os dados.
- **Chaves Primárias:** Utilizamos bigint generated by default as identity como chave primária padrão. Isso fornece um identificador numérico único e auto-incremental para cada registro.
- **Timestamps:** As colunas data_criacao e data_atualizacao usam o tipo timestamptz (timestamp with time zone) para registrar informações temporais precisas. A coluna data_atualizacao é atualizada automaticamente em cada operação UPDATE através de um trigger e uma função auxiliar (trigger_set_timestamp).
- **Slugs:** Colunas chamadas slug são usadas para criar identificadores únicos e amigáveis para URLs (ex: /categorias/autoconhecimento, /artigos/autoconhecimento/entendendo-a-autoestima). Eles são essenciais para SEO e roteamento no Next.js. Geralmente possuem uma restrição UNIQUE.
- **Gerenciamento de Imagens:** Conforme definido, as imagens (capas de artigos, fotos de autores) **não são armazenadas no banco de dados**. Elas residem na pasta /public/ do projeto Next.js. As colunas *_arquivo (ex: imagem_capa_arquivo, foto_arquivo) no banco de dados armazenam **apenas o nome do arquivo** correspondente (ex: "meu-artigo.png"). A aplicação front-end é responsável por construir o caminho completo para exibir a imagem (ex: /blogflorescerhumano/meu-artigo.png).
- **Relacionamentos:** Chaves estrangeiras (references) são usadas para estabelecer e impor relacionamentos entre tabelas (ex: um artigo pertence a uma categoria e um autor). As cláusulas ON DELETE definem o comportamento quando um registro referenciado é excluído (cascade: exclui registros dependentes; restrict: impede a exclusão se houver dependentes; set null: define a chave estrangeira como nula).
- **Validação:** Restrições CHECK são usadas para garantir que os dados em certas colunas atendam a critérios específicos (ex: status em artigos, formato de email em newsletter_assinantes).

### 3. Detalhamento das Tabelas

### 3.1. categorias

- **Propósito:** Armazena as categorias temáticas principais do blog (ex: "Autoconhecimento", "Psicologia Humanista"). Essencial para a organização e navegação primária.
- **Colunas Chave:**
    - id: Identificador único da categoria.
    - nome: Nome da categoria exibido ao usuário (único).
    - slug: Identificador para URL (único).
    - descricao: Texto opcional descrevendo a categoria.
- **Relacionamentos:** Referenciada por subcategorias e artigos.
- **RLS:** Leitura pública, escrita restrita.

### 3.2. subcategorias

- **Propósito:** Permite uma classificação mais específica dentro de uma categoria principal (ex: "Mindfulness" dentro de "Bem-Estar Emocional").
- **Colunas Chave:**
    - id: Identificador único da subcategoria.
    - nome: Nome da subcategoria.
    - slug: Identificador para URL (único).
    - categoria_id: Chave estrangeira que liga à tabela categorias (define a categoria pai).
    - descricao: Texto opcional.
- **Relacionamentos:** Refere-se a categorias. Referenciada por artigos.
- **RLS:** Leitura pública, escrita restrita.

### 3.3. autores

- **Propósito:** Guarda informações sobre os autores dos artigos. Inicialmente pode conter apenas Daniel Dantas, mas permite adicionar outros colaboradores.
- **Colunas Chave:**
    - id: Identificador único do autor.
    - nome: Nome do autor.
    - biografia: Texto sobre o autor.
    - foto_arquivo: **Nome do arquivo** da foto do autor (localizada na pasta /public/).
    - perfil_academico_url: Link opcional para perfil externo.
- **Relacionamentos:** Referenciada por artigos.
- **RLS:** Leitura pública, escrita restrita.

### 3.4. tags

- **Propósito:** Permite etiquetar artigos com tópicos específicos que podem atravessar múltiplas categorias (ex: "Carl Rogers", "Resiliência"). Facilita a descoberta de conteúdo relacionado de forma flexível.
- **Colunas Chave:**
    - id: Identificador único da tag.
    - nome: Nome da tag (único).
    - slug: Identificador para URL/filtro (único).
- **Relacionamentos:** Associada a artigos através da tabela de junção artigos_tags.
- **RLS:** Leitura pública, escrita restrita.

### 3.5. artigos

- **Propósito:** Tabela central que armazena cada post individual do blog. Contém o conteúdo principal e metadados essenciais.
- **Colunas Chave:**
    - id: Identificador único do artigo.
    - titulo: Título principal do artigo.
    - slug: Identificador único para a URL do artigo.
    - conteudo: O corpo principal do artigo (texto, Markdown, HTML ou JSONB).
    - resumo: Pequeno trecho para pré-visualizações e SEO.
    - imagem_capa_arquivo: **Nome do arquivo** da imagem de capa (localizada em /public/blogflorescerhumano/).
    - categoria_id: Link para a categoria principal do artigo.
    - subcategoria_id: Link opcional para a subcategoria.
    - autor_id: Link para o autor do artigo.
    - data_publicacao: Data/hora em que o artigo deve se tornar visível publicamente. Permite agendamento.
    - status: Controla a visibilidade ('rascunho', 'publicado', 'arquivado').
- **Relacionamentos:** Refere-se a categorias, subcategorias, autores. Associada a tags via artigos_tags.
- **RLS:** Política complexa necessária. Leitura pública apenas para artigos com status = 'publicado' e data_publicacao no passado. Acesso a rascunhos/arquivados restrito. Escrita restrita.

### 3.6. artigos_tags

- **Propósito:** Tabela de junção que implementa a relação muitos-para-muitos entre artigos e tags. Permite que um artigo tenha múltiplas tags e uma tag seja usada em múltiplos artigos.
- **Colunas Chave:**
    - artigo_id: Chave estrangeira para artigos.
    - tag_id: Chave estrangeira para tags.
    - (artigo_id, tag_id): Chave primária composta, garantindo unicidade da associação.
- **Relacionamentos:** Liga artigos e tags.
- **RLS:** Acesso de leitura deve espelhar o acesso ao artigo correspondente. Escrita restrita.

### 3.7. newsletter_assinantes

- **Propósito:** Armazena os endereços de e-mail de usuários que optaram por receber a newsletter. Contém dados pessoais sensíveis.
- **Colunas Chave:**
    - id: Identificador único do assinante.
    - email: Endereço de e-mail (único, com validação de formato).
    - status_confirmacao: Indica se o e-mail foi confirmado (para Double Opt-In).
    - token_confirmacao: Token temporário para o processo de confirmação.
    - data_confirmacao: Timestamp da confirmação.
- **Relacionamentos:** Nenhuma chave estrangeira direta para outras tabelas de conteúdo.
- **RLS:** **Extremamente restrita.** Nenhuma leitura ou escrita pública direta permitida. Operações devem ser feitas via funções seguras ou APIs de backend. Acesso de leitura restrito a administradores.

### 4. Objetos Auxiliares

- **Função trigger_set_timestamp() e Triggers Associados:**
    - **Propósito:** Automatizam a atualização da coluna data_atualizacao em tabelas como categorias, subcategorias, autores e artigos sempre que um registro é modificado (via UPDATE). Isso garante que se tenha um registro preciso da última modificação sem a necessidade de atualizar manualmente o campo na aplicação.

### 5. Conclusão

Este esquema de banco de dados fornece uma fundação sólida para o "Blog Florescer Humano". Ele organiza o conteúdo de maneira lógica, permite flexibilidade através de tags, gerencia informações de autores e categorias, e inclui uma estrutura para a funcionalidade de newsletter, ao mesmo tempo em que considera as melhores práticas de segurança e o gerenciamento de imagens fora do banco de dados. Os próximos passos essenciais incluem a implementação deste esquema no Supabase, a habilitação rigorosa do RLS e a definição das políticas de segurança apropriadas para cada tabela.

```jsx
-- ## TABELAS PRINCIPAIS DE CONTEÚDO ##

CREATE TABLE categorias (
  id bigint generated by default as identity primary key,
  nome text not null unique,
  slug text not null unique,
  descricao text,
  data_criacao timestamptz default now() not null,
  data_atualizacao timestamptz default now() not null
);

CREATE TABLE subcategorias (
  id bigint generated by default as identity primary key,
  nome text not null,
  slug text not null unique,
  categoria_id bigint not null references categorias(id) on delete cascade,
  descricao text,
  data_criacao timestamptz default now() not null,
  data_atualizacao timestamptz default now() not null
);

CREATE TABLE autores (
  id bigint generated by default as identity primary key,
  nome text not null,
  biografia text,
  foto_arquivo text,
  perfil_academico_url text,
  data_criacao timestamptz default now() not null,
  data_atualizacao timestamptz default now() not null
);

CREATE TABLE tags (
  id bigint generated by default as identity primary key,
  nome text not null unique,
  slug text not null unique,
  data_criacao timestamptz default now() not null
);

CREATE TABLE artigos (
  id bigint generated by default as identity primary key,
  titulo text not null,
  slug text not null unique,
  conteudo text not null,
  resumo text,
  imagem_capa_arquivo text,
  categoria_id bigint not null references categorias(id) on delete restrict,
  subcategoria_id bigint references subcategorias(id) on delete set null,
  autor_id bigint not null references autores(id) on delete restrict,
  data_publicacao timestamptz,
  status text not null default 'rascunho' check (status in ('rascunho', 'publicado', 'arquivado')),
  data_criacao timestamptz default now() not null,
  data_atualizacao timestamptz default now() not null
);

CREATE TABLE artigos_tags (
  artigo_id bigint not null references artigos(id) on delete cascade,
  tag_id bigint not null references tags(id) on delete cascade,
  primary key (artigo_id, tag_id)
);

-- ## TABELA DE FUNCIONALIDADES ADICIONAIS ##

CREATE TABLE newsletter_assinantes (
  id bigint generated by default as identity primary key,
  email text not null unique check (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'),
  data_inscricao timestamptz default now() not null,
  status_confirmacao text not null default 'pendente' check (status_confirmacao in ('pendente', 'confirmado')),
  token_confirmacao text unique,
  data_confirmacao timestamptz
);

-- ## Funções Auxiliares (Opcional, mas recomendado para `data_atualizacao`) ##

create or replace function trigger_set_timestamp()
returns trigger as $$
begin
  new.data_atualizacao = now();
  return new;
end;
$$ language plpgsql;

-- Triggers
create trigger set_timestamp_categorias before update on categorias for each row execute procedure trigger_set_timestamp();
create trigger set_timestamp_subcategorias before update on subcategorias for each row execute procedure trigger_set_timestamp();
create trigger set_timestamp_autores before update on autores for each row execute procedure trigger_set_timestamp();
create trigger set_timestamp_artigos before update on artigos for each row execute procedure trigger_set_timestamp();

```

Okay, vamos criar uma documentação detalhada sobre como gerenciar a segurança das suas tabelas Supabase usando **Row Level Security (RLS)**, focando especificamente no esquema que definimos para o blog "Florescer Humano".

---

## **Documentação: Gerenciando Segurança com Row Level Security (RLS) no Supabase**

### 1. O que é Row Level Security (RLS)?

Row Level Security (RLS) é um recurso fundamental do PostgreSQL (o banco de dados por trás do Supabase) que permite controlar **quais linhas (rows)** em uma tabela um usuário específico pode acessar ou modificar (inserir, atualizar, deletar).

Em vez de apenas controlar o acesso à tabela inteira (GRANT/REVOKE), RLS permite definir regras (chamadas **Políticas**) baseadas nas características da linha ou no usuário que está tentando acessá-la.

**Por que é crucial para o seu blog?**

- **Segurança Granular:** Garante que usuários anônimos (visitantes do blog) só possam ler artigos publicados, enquanto administradores ou editores possam gerenciar rascunhos e outros conteúdos.
- **Proteção de Dados:** Impede o acesso não autorizado a dados sensíveis, como a lista de assinantes da newsletter.
- **Força a Autorização no Banco:** As regras são aplicadas diretamente no banco de dados, oferecendo uma camada de segurança robusta, mesmo que haja falhas na lógica da sua aplicação front-end ou back-end.
- **Integração com Supabase Auth:** O Supabase facilita o uso de RLS, fornecendo funções úteis dentro das políticas para identificar o usuário autenticado (auth.uid(), auth.role(), auth.jwt(), etc.).

### 2. Habilitando RLS nas Tabelas

**Passo Fundamental:** Antes de criar qualquer política, você **PRECISA** habilitar RLS para cada tabela que deseja proteger.

1. **Acesse o Painel Supabase:** Vá para o seu projeto no Supabase.
2. **Navegue até Autenticação:** No menu lateral esquerdo, clique em "Authentication".
3. **Acesse a Aba Policies:** Dentro da seção de Autenticação, clique na aba "Policies".
4. **Selecione a Tabela:** Você verá uma lista das suas tabelas. Encontre a tabela para a qual deseja habilitar RLS (ex: artigos).
5. **Clique em "Enable RLS":** Haverá um botão ou toggle para habilitar RLS naquela tabela específica. Clique nele.
6. **Confirme:** Pode ser necessário confirmar a ação.

**IMPORTANTE:** Quando você habilita RLS em uma tabela sem nenhuma política definida, o comportamento padrão é **NEGAR TODO O ACESSO** (SELECT, INSERT, UPDATE, DELETE) para todos os usuários, exceto superusuários do banco. Isso é uma medida de segurança "fail-safe". Portanto, **após habilitar RLS, você deve criar políticas para permitir o acesso desejado.**

**Recomendação:** Habilite RLS para **TODAS** as tabelas que criamos (categorias, subcategorias, autores, tags, artigos, artigos_tags, newsletter_assinantes).

### 3. Entendendo as Políticas RLS

Uma política RLS é basicamente uma regra SQL associada a uma tabela que define as condições para permitir uma operação específica (SELECT, INSERT, UPDATE, DELETE) para um determinado role (ou para public, que inclui usuários anônimos e autenticados).

Componentes de uma Política:

- **Nome:** Um nome descritivo para a política (ex: "Permitir leitura pública de artigos publicados").
- **Tabela:** A tabela à qual a política se aplica (ex: artigos).
- **Comando:** A operação SQL que a política controla (SELECT, INSERT, UPDATE, DELETE, ou ALL).
- **Role:** O(s) role(s) aos quais a política se aplica (ex: public, authenticated, anon, ou roles customizados).
- **USING (Expressão):** Uma expressão SQL que retorna boolean. É avaliada para **linhas existentes** na tabela. Se a expressão retornar true para uma linha, a operação (SELECT, UPDATE, DELETE) é permitida naquela linha para o role especificado.
- **WITH CHECK (Expressão):** Uma expressão SQL que retorna boolean. É avaliada para **linhas que estão sendo inseridas ou atualizadas**. Se a expressão retornar true, a operação (INSERT, UPDATE) é permitida. Garante que novas linhas ou modificações cumpram a regra.

**Como Supabase usa Roles:**

- anon: Representa usuários não autenticados que usam a chave anon da API.
- authenticated: Representa usuários autenticados (logados) que usam a chave anon da API.
- service_role: Representa acesso com a chave service_role (geralmente usada no backend), que **ignora** as políticas RLS por padrão. Use com cuidado!
- (Você pode criar roles customizados no PostgreSQL se precisar de granularidade maior, mas anon e authenticated cobrem muitos casos).

### 4. Padrões Comuns de Políticas RLS

Vamos ver alguns exemplos de políticas comuns que aplicaremos ao nosso blog:

**a) Leitura Pública:** Permitir que qualquer pessoa (anônima ou autenticada) leia os dados.

```sql
      -- Exemplo: Permitir leitura pública de categorias
CREATE POLICY "Permitir leitura publica de categorias"
ON categorias
FOR SELECT -- Aplica-se apenas à operação SELECT
USING (true); -- A condição é sempre verdadeira, permitindo ver todas as linhas
```

**b) Leitura Autenticada:** Permitir que apenas usuários logados leiam os dados.

```sql
      -- Exemplo (Não aplicável diretamente ao nosso schema público, mas ilustrativo)
-- CREATE POLICY "Permitir leitura apenas para usuários logados"
-- ON alguma_tabela_privada
-- FOR SELECT
-- USING (auth.role() = 'authenticated'); -- Permite SELECT se o role do usuário for 'authenticated'
```

IGNORE_WHEN_COPYING_START

content_copy  download  Use code [with caution](https://support.google.com/legal/answer/13505487). SQL

IGNORE_WHEN_COPYING_END

**c) Leitura Pública Condicional:** Permitir que qualquer pessoa leia *apenas algumas* linhas que atendam a certas condições.

```sql
      -- Exemplo: Permitir leitura pública de artigos publicados e dentro da data
CREATE POLICY "Permitir leitura publica de artigos publicados"
ON artigos
FOR SELECT
USING (
  status = 'publicado' AND                  -- A linha deve ter status 'publicado'
  data_publicacao IS NOT NULL AND           -- A data de publicação não pode ser nula
  data_publicacao <= now()                  -- A data de publicação deve ser no passado ou agora
);
```

IGNORE_WHEN_COPYING_START

content_copy  download  Use code [with caution](https://support.google.com/legal/answer/13505487). SQL

IGNORE_WHEN_COPYING_END

**d) Escrita Restrita (Ex: Apenas Editores/Admins):** Permitir operações de escrita apenas para usuários com um role específico (ou ID específico). *Nota: Supabase por padrão não tem roles 'editor' ou 'admin'. Você precisaria gerenciar isso, talvez com uma tabela de usuários/roles customizada ou usando metadados no auth.users.* Uma abordagem simples é restringir ao role authenticated e confiar que apenas usuários confiáveis (você, colaboradores) terão contas e acesso à interface de gerenciamento.

```sql
      -- Exemplo SIMPLIFICADO: Permitir escrita em categorias APENAS para usuários logados
-- (Pressupõe que SÓ usuários confiáveis podem se logar e acessar a interface de admin)
CREATE POLICY "Permitir escrita em categorias para usuarios logados"
ON categorias
FOR ALL -- Aplica-se a INSERT, UPDATE, DELETE
USING (auth.role() = 'authenticated')     -- Condição para UPDATE/DELETE (só pode modificar/deletar se estiver logado)
WITH CHECK (auth.role() = 'authenticated'); -- Condição para INSERT/UPDATE (só pode inserir/modificar se estiver logado)

-- Abordagem mais robusta envolveria verificar um role customizado ou ID específico.
```

IGNORE_WHEN_COPYING_START

content_copy  download  Use code [with caution](https://support.google.com/legal/answer/13505487). SQL

IGNORE_WHEN_COPYING_END

**e) Políticas Super Restritas (Ex: Newsletter):** Bloquear quase todo o acesso direto.

```sql
      -- Exemplo: Política para newsletter_assinantes
-- 1. Bloquear TODA leitura via API pública
CREATE POLICY "Bloquear leitura publica de assinantes"
ON newsletter_assinantes
FOR SELECT
USING (false); -- Nenhuma linha satisfaz 'false', bloqueando SELECTs públicos

-- 2. Bloquear TODA escrita direta via API pública (INSERT/UPDATE/DELETE)
-- (Não é estritamente necessário se não houver política de INSERT/UPDATE/DELETE, mas explícito)
CREATE POLICY "Bloquear escrita publica de assinantes"
ON newsletter_assinantes
FOR ALL -- INSERT, UPDATE, DELETE
USING (false)
WITH CHECK (false);

-- NOTA: A inserção de novos assinantes DEVE ser feita através de:
--   a) Uma Edge Function do Supabase que use a 'service_role' key (que ignora RLS).
--   b) Uma API backend sua que use a 'service_role' key.
--   c) Funções PostgreSQL com `SECURITY DEFINER` (mais avançado).
```

IGNORE_WHEN_COPYING_START

content_copy  download  Use code [with caution](https://support.google.com/legal/answer/13505487). SQL

IGNORE_WHEN_COPYING_END

### 5. Aplicando Políticas ao Esquema do Blog "Florescer Humano"

Aqui está um conjunto sugerido de políticas iniciais para o seu esquema. **Adapte conforme sua necessidade de roles específicos (admin/editor) se for o caso.**

```sql
      -- HABILITE RLS EM TODAS AS TABELAS PRIMEIRO!

-- === Políticas para Tabelas de Conteúdo Público ===

-- categorias, subcategorias, autores, tags: Leitura pública, escrita restrita a usuários logados (simplificado)
-- (Repetir para cada tabela: categorias, subcategorias, autores, tags)
CREATE POLICY "Permitir leitura publica" ON categorias FOR SELECT USING (true);
CREATE POLICY "Permitir escrita para logados" ON categorias FOR ALL USING (auth.role() = 'authenticated') WITH CHECK (auth.role() = 'authenticated');

CREATE POLICY "Permitir leitura publica" ON subcategorias FOR SELECT USING (true);
CREATE POLICY "Permitir escrita para logados" ON subcategorias FOR ALL USING (auth.role() = 'authenticated') WITH CHECK (auth.role() = 'authenticated');

CREATE POLICY "Permitir leitura publica" ON autores FOR SELECT USING (true);
CREATE POLICY "Permitir escrita para logados" ON autores FOR ALL USING (auth.role() = 'authenticated') WITH CHECK (auth.role() = 'authenticated');

CREATE POLICY "Permitir leitura publica" ON tags FOR SELECT USING (true);
CREATE POLICY "Permitir escrita para logados" ON tags FOR ALL USING (auth.role() = 'authenticated') WITH CHECK (auth.role() = 'authenticated');

-- artigos: Leitura pública condicional, escrita restrita a usuários logados (simplificado)
CREATE POLICY "Permitir leitura publica de artigos publicados" ON artigos FOR SELECT USING (status = 'publicado' AND data_publicacao IS NOT NULL AND data_publicacao <= now());
CREATE POLICY "Permitir escrita para logados" ON artigos FOR ALL USING (auth.role() = 'authenticated') WITH CHECK (auth.role() = 'authenticated');
-- Opcional: Permitir que usuários logados (editores) vejam rascunhos
-- CREATE POLICY "Permitir leitura de rascunhos para logados" ON artigos FOR SELECT USING (auth.role() = 'authenticated');

-- artigos_tags: Acesso espelha 'artigos', escrita restrita
-- (Política de SELECT aqui pode ser complexa se precisar verificar o status do artigo relacionado)
-- Abordagem simples: Permitir leitura se logado (assumindo que a API filtra quais artigos mostrar)
CREATE POLICY "Permitir leitura para logados" ON artigos_tags FOR SELECT USING (auth.role() = 'authenticated');
-- Abordagem mais segura (requer consulta):
-- CREATE POLICY "Permitir leitura se artigo publico" ON artigos_tags FOR SELECT
-- USING (
--  EXISTS (
--    SELECT 1 FROM artigos a
--    WHERE a.id = artigos_tags.artigo_id
--    AND a.status = 'publicado'
--    AND a.data_publicacao IS NOT NULL
--    AND a.data_publicacao <= now()
--  )
-- );
CREATE POLICY "Permitir escrita para logados" ON artigos_tags FOR ALL USING (auth.role() = 'authenticated') WITH CHECK (auth.role() = 'authenticated');

-- === Políticas para Tabelas Sensíveis ===

-- newsletter_assinantes: SEM acesso público direto
CREATE POLICY "Bloquear leitura publica" ON newsletter_assinantes FOR SELECT USING (false);
CREATE POLICY "Bloquear escrita publica" ON newsletter_assinantes FOR ALL USING (false) WITH CHECK (false);
-- (Lembre-se: Operações nesta tabela via backend/functions com service_role)
-- Opcional: Permitir que um admin leia
-- CREATE POLICY "Permitir leitura para admin" ON newsletter_assinantes FOR SELECT USING (auth.role() = 'admin'); -- Requer role 'admin'
```

IGNORE_WHEN_COPYING_START

content_copy  download  Use code [with caution](https://support.google.com/legal/answer/13505487). SQL

IGNORE_WHEN_COPYING_END

### 6. Como Criar as Políticas no Supabase

1. **Use o SQL Editor:**
    - Vá para a seção "SQL Editor" no painel do Supabase.
    - Clique em "+ New query".
    - Cole os comandos CREATE POLICY desejados.
    - Execute a query. Repita para todas as políticas.
2. **Use a Interface Gráfica (para políticas simples):**
    - Vá para "Authentication" -> "Policies".
    - Selecione a tabela.
    - Clique em "+ New Policy".
    - Escolha "Create policy from scratch" ou um template.
    - Preencha os campos: Nome, Target roles, Command, USING expression, WITH CHECK expression.
    - Clique em "Review" e depois "Save policy".

### 7. Testando Suas Políticas RLS

**É VITAL TESTAR SUAS POLÍTICAS!**

1. **SQL Editor com Impersonificação:**
    - No SQL Editor, você pode executar queries como se fosse um usuário específico. Use set role ou configure a sessão para simular anon ou authenticated.
    - Exemplo:
        
        ```sql
              -- Simular usuário anônimo
        set role anon;
        select * from artigos; -- Deve retornar apenas artigos publicados
        
        -- Simular usuário autenticado (sem role específico)
        set role authenticated;
        select * from artigos; -- Deve retornar publicados (e rascunhos se a política opcional existir)
        insert into categorias (nome, slug) values ('Teste', 'teste'); -- Deve funcionar
        select * from newsletter_assinantes; -- NÃO DEVE RETORNAR NADA
        
        -- Voltar ao normal
        reset role;
        ```
        
        IGNORE_WHEN_COPYING_START
        
        content_copy  download  Use code [with caution](https://support.google.com/legal/answer/13505487). SQL
        
        IGNORE_WHEN_COPYING_END
        
2. **Testes de API:**
    - Use ferramentas como Postman, curl, ou a própria biblioteca cliente do Supabase (supabase-js) no seu console do navegador/Node.js.
    - Faça chamadas à API **sem** um token de autenticação (simula anon). Verifique se você só vê dados públicos.
    - Faça chamadas à API **com** um token JWT de um usuário logado (simula authenticated). Verifique o acesso permitido.
    - Tente realizar operações de escrita proibidas e verifique se elas falham com um erro de permissão.

### 8. Boas Práticas e Considerações

- **Comece Restritivo:** É mais seguro começar negando todo o acesso (habilitando RLS) e depois adicionar permissões explícitas com políticas USING (true) ou condições específicas.
- **Teste Exaustivamente:** Teste todos os cenários de usuário (anônimo, logado, diferentes roles se houver) e todas as operações (SELECT, INSERT, UPDATE, DELETE).
- **Performance:** Políticas muito complexas, especialmente aquelas com subconsultas (EXISTS), podem impactar o desempenho. Monitore suas queries e adicione índices onde necessário.
- **Funções PostgreSQL:** Para lógica de política complexa ou reutilizável, considere criar funções PostgreSQL e chamá-las dentro das expressões USING ou WITH CHECK. Use SECURITY DEFINER com cautela para funções que precisam de privilégios elevados (como inserir na tabela de newsletter).
- **Separação de Interesses:** Mantenha a lógica de *autorização* (quem pode fazer o quê) nas políticas RLS. A lógica de *negócios* deve permanecer na sua aplicação ou em funções do banco de dados.
- **Documente Suas Políticas:** Mantenha um registro do propósito de cada política.

Ótima pergunta! É fundamental entender *quando* e *por que* aplicar RLS. Mesmo com o seu fluxo de trabalho específico (sem login no blog, gerenciamento via dashboard Supabase), a resposta é:

**Sim, você ainda precisa de RLS, e ela continua sendo crucial, principalmente para proteger o ACESSO DE LEITURA da sua aplicação front-end.**

Vamos detalhar o porquê:

1. **Sua Aplicação Front-end (Next.js) Precisa Ler Dados:**
    - Para exibir os artigos, categorias, autores, etc., no seu blog florescerhumano.danieldantas.com, sua aplicação Next.js **precisará se conectar ao Supabase para buscar (SELECT) esses dados**.
    - Essa conexão do front-end **utilizará a chave pública de API do Supabase (a anon key)**. Essa chave é considerada segura para expor no código do navegador.
2. **RLS Controla o que a anon key Pode Ver:**
    - **Sem RLS:** Se você desabilitar RLS, qualquer pessoa com a sua anon key (que está no código do seu site) poderia, teoricamente, ler **TODAS** as linhas de **TODAS** as tabelas, incluindo:
        - Artigos com status = 'rascunho'.
        - Artigos com data_publicacao futura.
        - **Toda a tabela newsletter_assinantes**, expondo os e-mails dos seus assinantes! (Gravíssimo!)
        - Quaisquer outros dados que você possa adicionar no futuro.
    - **Com RLS:** Você define políticas que dizem explicitamente o que a anon key (ou seja, qualquer visitante do seu site através da aplicação Next.js) tem permissão para ler. Por exemplo:
        - Na tabela artigos: "Permitir SELECT apenas se status = 'publicado' E data_publicacao <= now()". Isso garante que rascunhos e posts agendados não sejam lidos pela API pública.
        - Na tabela newsletter_assinantes: "Permitir SELECT apenas se false". Isso **bloqueia completamente** qualquer tentativa de leitura dessa tabela usando a anon key.
3. **Gerenciamento via Dashboard vs. Acesso via API:**
    - Quando **VOCÊ** acessa o Supabase através do painel de controle (dashboard) ou do SQL Editor, você está autenticado como um **usuário do projeto Supabase** (com seu login e senha do Supabase). Suas permissões dentro do dashboard são diferentes e geralmente mais elevadas (você é o dono/admin do projeto). Você *consegue* ver e editar rascunhos e outros dados diretamente ali.
    - Quando a **APLICAÇÃO FRONT-END** acessa o Supabase, ela usa a anon key, que tem privilégios muito menores e **está sujeita às regras RLS** que você definir.
4. **Defesa em Profundidade:**
    - RLS atua como uma camada de segurança essencial no nível do banco de dados. Mesmo que haja uma falha lógica ou uma vulnerabilidade na sua aplicação front-end no futuro, RLS impede o acesso não autorizado aos dados na fonte.

**Em Resumo:**

Você precisa de RLS não para controlar o login *no seu blog* (pois não haverá), nem primariamente para controlar o *seu* acesso via dashboard, mas sim para **controlar rigorosamente o que a sua aplicação front-end Next.js (usando a chave pública anon) pode ler do banco de dados Supabase**. É a principal linha de defesa para garantir que apenas dados públicos sejam expostos aos visitantes do seu site e que dados sensíveis (como e-mails da newsletter) permaneçam completamente inacessíveis via API pública.

Portanto, habilite RLS em todas as tabelas e defina as políticas de SELECT (leitura) cuidadosamente, especialmente a política de bloqueio total de leitura para newsletter_assinantes e a política condicional para artigos. As políticas de escrita (INSERT, UPDATE, DELETE) também são importantes para garantir que a anon key não possa modificar dados acidentalmente.

---

Ao seguir estas etapas e aplicar as políticas sugeridas (adaptando-as se necessário), você garantirá um nível robusto de segurança para os dados do seu blog "Florescer Humano" diretamente na camada do banco de dados Supabase.

# Tabelas comentadas

```sql
Perfeito! Entendi a necessidade de adicionar comentários mais 
detalhados diretamente no código SQL para explicar por que cada 
tabela e coluna existe e como elas se encaixam na arquitetura 
geral do blog, especialmente considerando a decisão de usar a pasta 
public para imagens.

Aqui está a versão reescrita dos esquemas SQL, com comentários explicativos expandidos para cada tabela e coluna relevante:

Definição dos Esquemas das Tabelas Supabase (SQL) - Imagens na Pasta public (Com Comentários Detalhados)

Observações Importantes:

RLS (Row Level Security): ESSENCIAL habilitar RLS para TODAS as tabelas. As políticas de segurança devem ser definidas cuidadosamente após a criação das tabelas para controlar o acesso (leitura pública para conteúdo publicado, escrita restrita a administradores/editores, acesso ultra-restrito a dados de newsletter).
Tipos de Dados: bigint generated by default as identity para chaves primárias auto-incrementais; timestamptz para timestamps com fuso horário; text para strings de comprimento variável; jsonb como alternativa para conteúdo estruturado; check para validação de dados em colunas específicas.
Índices: Recomenda-se criar índices em colunas frequentemente usadas em cláusulas WHERE ou JOIN (ex: slug, status, categoria_id, autor_id, data_publicacao) para otimizar o desempenho das consultas. Supabase cria índices para chaves primárias e estrangeiras automaticamente.

Imagens na Pasta public: As colunas foto_arquivo (autores) e imagem_capa_arquivo (artigos) não armazenam a imagem em si. Elas armazenam apenas o nome do arquivo (ex: "meu-artigo.png") que reside na pasta /public/ do projeto Next.js. A aplicação front-end será responsável por construir o caminho completo (ex: /blogflorescerhumano/meu-artigo.png) para exibir a imagem usando next/image.

```

```sql

-- ## TABELAS PRINCIPAIS DE CONTEÚDO ##

-- Tabela: categorias
-- Propósito: Armazena as categorias principais do blog, usadas para organizar
--            os artigos tematicamente e facilitar a navegação do usuário.
CREATE TABLE categorias (
  id bigint generated by default as identity primary key, -- Identificador único da categoria.
  nome text not null unique,                              -- Nome da categoria exibido ao usuário (ex: "Autoconhecimento"). Deve ser único.
  slug text not null unique,                              -- Versão do nome amigável para URLs (ex: "autoconhecimento"). Deve ser único e usado nas rotas dinâmicas.
  descricao text,                                         -- Descrição opcional da categoria (pode ser usada em páginas de categoria ou para SEO).
  data_criacao timestamptz default now() not null,        -- Timestamp de quando a categoria foi criada.
  data_atualizacao timestamptz default now() not null     -- Timestamp da última atualização da categoria (atualizado automaticamente via trigger).
);
-- Comentário: Estrutura base da organização temática do blog.
-- RLS: Habilitar. Política padrão: Leitura pública (SELECT permitido para todos). Escrita (INSERT, UPDATE, DELETE) restrita a roles específicas (ex: 'authenticated', 'admin').
-- Índices: Recomendado índice em 'slug' para buscas rápidas por URL.

-- Tabela: subcategorias
-- Propósito: Permite uma organização mais granular dentro de uma categoria principal,
--            oferecendo um segundo nível de classificação temática.
CREATE TABLE subcategorias (
  id bigint generated by default as identity primary key, -- Identificador único da subcategoria.
  nome text not null,                                     -- Nome da subcategoria exibido ao usuário (ex: "Mindfulness"). Não precisa ser único globalmente, mas idealmente único dentro de uma categoria pai.
  slug text not null unique,                              -- Versão do nome amigável para URLs (ex: "mindfulness"). Deve ser único globalmente para evitar conflitos de rota.
  categoria_id bigint not null references categorias(id) on delete cascade, -- Chave estrangeira ligando à categoria pai. 'on delete cascade' significa que se a categoria pai for deletada, todas as suas subcategorias também serão (cuidado com esta opção, 'on delete restrict' ou 'on delete set null' podem ser mais seguros dependendo do caso de uso).
  descricao text,                                         -- Descrição opcional da subcategoria.
  data_criacao timestamptz default now() not null,        -- Timestamp de criação.
  data_atualizacao timestamptz default now() not null     -- Timestamp da última atualização (atualizado automaticamente via trigger).
);
-- Comentário: Aprofunda a organização do conteúdo.
-- RLS: Habilitar. Política padrão: Leitura pública. Escrita restrita.
-- Índices: Recomendado índice em 'slug' e 'categoria_id'.

-- Tabela: autores
-- Propósito: Armazena informações sobre os autores dos artigos, permitindo
--            atribuição e criação de páginas de perfil de autor (se necessário).
CREATE TABLE autores (
  id bigint generated by default as identity primary key, -- Identificador único do autor.
  nome text not null,                                     -- Nome completo do autor.
  biografia text,                                         -- Texto descritivo sobre o autor.
  foto_arquivo text,                                      -- **APENAS o nome do arquivo** da foto do autor (ex: "daniel-dantas.jpg"). A imagem reside em /public/psidanieldantas/ ou /public/blogflorescerhumano/. A aplicação constrói o path completo.
  perfil_academico_url text,                              -- URL opcional para um perfil externo (Lattes, LinkedIn, etc.).
  data_criacao timestamptz default now() not null,        -- Timestamp de criação.
  data_atualizacao timestamptz default now() not null     -- Timestamp da última atualização (atualizado automaticamente via trigger).
);
-- Comentário: Essencial para atribuição de conteúdo. A coluna 'foto_arquivo' é a chave para vincular o registro ao arquivo de imagem estático.
-- RLS: Habilitar. Política padrão: Leitura pública. Escrita restrita.

-- Tabela: tags
-- Propósito: Permite uma organização flexível e multifacetada dos artigos,
--            agrupando posts por tópicos específicos que podem cruzar categorias.
CREATE TABLE tags (
  id bigint generated by default as identity primary key, -- Identificador único da tag.
  nome text not null unique,                              -- Nome da tag exibido (ex: "Carl Rogers"). Deve ser único.
  slug text not null unique,                              -- Versão do nome amigável para URLs/filtros (ex: "carl-rogers"). Deve ser único.
  data_criacao timestamptz default now() not null        -- Timestamp de criação.
);
-- Comentário: Complementa as categorias para melhor descoberta de conteúdo.
-- RLS: Habilitar. Política padrão: Leitura pública. Escrita restrita.
-- Índices: Recomendado índice em 'slug'.

```

```sql
-- Tabela: artigos
-- Propósito: Tabela central do blog, armazena o conteúdo principal de cada post.
CREATE TABLE artigos (
  id bigint generated by default as identity primary key, -- Identificador único do artigo.
  titulo text not null,                                   -- Título principal do artigo, exibido na página e usado em metadados (SEO).
  slug text not null unique,                              -- Identificador único para a URL do artigo (ex: "entendendo-a-autoestima"). Essencial para rotas dinâmicas e SEO.
  conteudo text not null,                                 -- Conteúdo principal do artigo. Pode ser Markdown, HTML, ou texto simples. Considerar 'jsonb' se usar um editor baseado em blocos (ex: Editor.js, Tiptap) para armazenar conteúdo estruturado.
  resumo text,                                            -- Pequeno trecho ou resumo do artigo, usado em listagens (cards) e metadados (SEO meta description).
  imagem_capa_arquivo text,                               -- **APENAS o nome do arquivo** da imagem de capa (ex: "importancia-empatia.png"). A imagem reside em /public/blogflorescerhumano/. A aplicação constrói o path completo.
  categoria_id bigint not null references categorias(id) on delete restrict, -- Chave estrangeira para a categoria principal. 'on delete restrict' impede que uma categoria seja deletada se houver artigos nela.
  subcategoria_id bigint references subcategorias(id) on delete set null, -- Chave estrangeira opcional para a subcategoria. 'on delete set null' define o campo como nulo se a subcategoria for deletada.
  autor_id bigint not null references autores(id) on delete restrict, -- Chave estrangeira para o autor. 'on delete restrict' impede que um autor seja deletado se tiver artigos associados.
  data_publicacao timestamptz,                            -- Data e hora em que o artigo deve se tornar público. Permite agendar publicações e manter artigos como rascunhos. Se for nulo, pode ser considerado não publicado ainda.
  status text not null default 'rascunho'                 -- Status do artigo, controla sua visibilidade.
    check (status in ('rascunho', 'publicado', 'arquivado')), -- Restrição para garantir que o status seja um dos valores permitidos.
  data_criacao timestamptz default now() not null,        -- Timestamp de quando o registro do artigo foi criado no banco.
  data_atualizacao timestamptz default now() not null     -- Timestamp da última atualização do artigo (atualizado automaticamente via trigger).
);
-- Comentário: Coração do conteúdo do blog. A combinação de 'status' e 'data_publicacao' controla a visibilidade pública.
-- RLS: Habilitar. Política de leitura pública complexa: SELECT permitido para todos APENAS SE (status = 'publicado' AND data_publicacao IS NOT NULL AND data_publicacao <= now()). Política de leitura para rascunhos/arquivados restrita a autores/admins. Escrita (INSERT, UPDATE, DELETE) restrita.
-- Índices: Recomendados índices em 'slug', 'status', 'data_publicacao', 'categoria_id', 'subcategoria_id', 'autor_id'.

-- Tabela: artigos_tags
-- Propósito: Tabela de junção (linking table) para implementar a relação
--            muitos-para-muitos entre artigos e tags.
CREATE TABLE artigos_tags (
  artigo_id bigint not null references artigos(id) on delete cascade, -- Chave estrangeira para o artigo. 'on delete cascade' remove a associação se o artigo for deletado.
  tag_id bigint not null references tags(id) on delete cascade,       -- Chave estrangeira para a tag. 'on delete cascade' remove a associação se a tag for deletada.
  primary key (artigo_id, tag_id)                                    -- Chave primária composta para garantir que a combinação artigo/tag seja única.
);
-- Comentário: Permite que um artigo tenha várias tags e uma tag seja associada a vários artigos.
-- RLS: Habilitar. Política de leitura deve geralmente espelhar a política de leitura da tabela 'artigos' (só mostrar associações de artigos públicos). Escrita restrita.

```

```sql

-- ## TABELA DE FUNCIONALIDADES ADICIONAIS ##

-- Tabela: newsletter_assinantes
-- Propósito: Armazena os endereços de e-mail dos usuários que se inscreveram
--            na newsletter. Requer tratamento cuidadoso devido à privacidade.
CREATE TABLE newsletter_assinantes (
  id bigint generated by default as identity primary key, -- Identificador único do assinante.
  email text not null unique                              -- Endereço de e-mail do assinante. Deve ser único.
    check (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'), -- Validação básica do formato do e-mail.
  data_inscricao timestamptz default now() not null,      -- Timestamp de quando o usuário se inscreveu.
  status_confirmacao text not null default 'pendente'     -- Status da confirmação do e-mail (para implementar Double Opt-In).
    check (status_confirmacao in ('pendente', 'confirmado')), -- Garante que o status seja um dos valores permitidos.
  token_confirmacao text unique,                          -- Token único enviado por e-mail para o usuário confirmar a inscrição. Nulo após confirmação.
  data_confirmacao timestamptz                            -- Timestamp de quando o usuário confirmou o e-mail.
);
-- Comentário: Dados sensíveis. Implementar Double Opt-In é recomendado para conformidade e qualidade da lista.
-- RLS: Habilitar. **POLÍTICAS EXTREMAMENTE RESTRITAS**. Nenhuma leitura pública. Escrita (INSERT) permitida apenas via funções seguras (Security Definer) ou API Keys de backend, NUNCA diretamente pelo cliente anônimo. Leitura (SELECT) restrita a administradores ou roles específicas de backend.

-- ## Funções Auxiliares (Opcional, mas recomendado para `data_atualizacao`) ##

-- Função: trigger_set_timestamp
-- Propósito: Atualiza automaticamente o campo 'data_atualizacao' para o timestamp
--            atual sempre que uma linha em uma tabela associada for atualizada.
create or replace function trigger_set_timestamp()
returns trigger as $$
begin
  -- Define o valor da coluna 'data_atualizacao' da linha que está sendo atualizada (NEW)
  -- para o timestamp atual da transação (now()).
  new.data_atualizacao = now();
  -- Retorna a linha modificada para que a operação UPDATE prossiga.
  return new;
end;
$$ language plpgsql;

-- Triggers: Associam a função 'trigger_set_timestamp' ao evento UPDATE
--           nas tabelas que possuem a coluna 'data_atualizacao'.
--           Isso garante que o timestamp seja atualizado automaticamente.

create trigger set_timestamp_categorias
before update on categorias -- Antes de cada UPDATE na tabela 'categorias'
for each row             -- Para cada linha que for atualizada
execute procedure trigger_set_timestamp(); -- Execute a função definida acima.

create trigger set_timestamp_subcategorias
before update on subcategorias
for each row
execute procedure trigger_set_timestamp();

create trigger set_timestamp_autores
before update on autores
for each row
execute procedure trigger_set_timestamp();

create trigger set_timestamp_artigos
before update on artigos
for each row
execute procedure trigger_set_timestamp();

```

# Primeiras Tabalas de Exemplo no banco de dados:

```sql
-- Script SQL para Povoar as Tabelas do Blog "Florescer Humano" (Exemplo)

-- Observações:
-- 1. IDs: Os IDs são definidos como 'bigint generated by default as identity', então o banco de dados os gerará automaticamente.
--    Não precisamos especificá-los nos inserts, a menos que queiramos referenciá-los em tabelas dependentes logo em seguida.
--    Para simplicidade e clareza neste exemplo, vamos assumir que sabemos os IDs gerados (1, 2, 3...) para criar os relacionamentos.
--    Em um script real, você pode usar `RETURNING id` nos inserts para capturar os IDs gerados.
-- 2. Datas: Usamos `now()` para datas de criação/atualização. Para `data_publicacao`, definimos uma data no passado para que os artigos sejam visíveis com as políticas RLS.
-- 3. Imagens: As colunas `foto_arquivo` e `imagem_capa_arquivo` contêm apenas NOMES de arquivos. As imagens reais devem existir em `public/blogflorescerhumano/` ou `public/psicologodanieldantas/`.

-- ## Povoar Tabela: categorias ##
INSERT INTO categorias (nome, slug, descricao) VALUES
('Autoconhecimento e Desenvolvimento Pessoal', 'autoconhecimento-desenvolvimento-pessoal', 'Explore ferramentas e reflexões para sua jornada de crescimento interior.'),
('Psicologia Humanista e Abordagens Relacionadas', 'psicologia-humanista-abordagens', 'Aprofunde-se nos conceitos e práticas da Psicologia Humanista, ACP, Focalização e Mindfulness.'),
('Bem-Estar Emocional e Saúde Mental', 'bem-estar-emocional-saude-mental', 'Conteúdos sobre como lidar com emoções, estresse, ansiedade e cultivar a saúde mental.'),
('Relacionamentos e Conexões Humanas', 'relacionamentos-conexoes-humanas', 'Reflexões sobre a importância e a dinâmica das relações interpessoais.'),
('Florescer na Vida', 'florescer-na-vida', 'Espaço para inspiração, histórias, poemas e reflexões sobre a busca por sentido e autenticidade.');

-- ## Povoar Tabela: subcategorias ##
-- Assumindo que 'Psicologia Humanista...' é a categoria com id=2
INSERT INTO subcategorias (nome, slug, categoria_id, descricao) VALUES
('Abordagem Centrada na Pessoa (ACP)', 'abordagem-centrada-pessoa-acp', 2, 'Princípios e práticas da ACP de Carl Rogers.'),
('Focalização (Focusing)', 'focalizacao-focusing', 2, 'Explore a técnica de Eugene Gendlin para acessar a sabedoria corporal.'),
('Mindfulness e Atenção Plena', 'mindfulness-atencao-plena', 2, 'Práticas de atenção plena e sua integração com a psicologia humanista.'),
('Diálogos Interdisciplinares', 'dialogos-interdisciplinares', 2, 'Conexões da psicologia humanista com filosofia, neurociência e artes.');

-- ## Povoar Tabela: autores ##
INSERT INTO autores (nome, biografia, foto_arquivo, perfil_academico_url) VALUES
('Daniel Dantas', 'Psicólogo clínico com abordagem humanista, focado em ACP, Focalização e Mindfulness. Autor do blog Florescer Humano.', 'daniel-dantas-profile.jpg', 'https://www.linkedin.com/in/danieldantaspsi/');
-- Adicione outros autores se necessário

-- ## Povoar Tabela: tags ##
INSERT INTO tags (nome, slug) VALUES
('Carl Rogers', 'carl-rogers'),
('Empatia', 'empatia'),
('Congruência', 'congruencia'),
('Aceitação Incondicional', 'aceitacao-incondicional'),
('Felt Sense', 'felt-sense'),
('Eugene Gendlin', 'eugene-gendlin'),
('Mindfulness para Iniciantes', 'mindfulness-iniciantes'),
('Ansiedade', 'ansiedade'),
('Autocompaixão', 'autocompaixao'),
('Propósito de Vida', 'proposito-vida'),
('Relacionamento Terapêutico', 'relacionamento-terapeutico'),
('Técnicas Práticas', 'tecnicas-praticas'),
('Para Estudantes', 'para-estudantes'),
('Prática Clínica', 'pratica-clinica'),
('Criatividade', 'criatividade');

-- ## Povoar Tabela: artigos ##
-- Assumindo IDs: Categoria 1='Autoconhecimento...', 2='Psicologia Humanista...', 3='Bem-Estar...', 4='Relacionamentos...', 5='Florescer...'
-- Assumindo IDs: Subcategoria 1='ACP', 2='Focalização', 3='Mindfulness'
-- Assumindo ID: Autor 1='Daniel Dantas'
INSERT INTO artigos (titulo, slug, conteudo, resumo, imagem_capa_arquivo, categoria_id, subcategoria_id, autor_id, data_publicacao, status) VALUES
(
  'A Importância da Empatia nas Relações Humanas',
  'importancia-empatia-relacoes-humanas',
  '<p>A empatia, a capacidade de se colocar no lugar do outro, é fundamental...</p> (Conteúdo completo em HTML ou Markdown)',
  'Entenda por que a empatia é crucial para construir conexões mais profundas e significativas em todas as áreas da vida.',
  'importancia-empatia-image-blog.png',
  4, -- Relacionamentos e Conexões Humanas
  NULL,
  1, -- Daniel Dantas
  '2023-10-26 10:00:00+00', -- Data no passado
  'publicado'
),
(
  'Introdução à Abordagem Centrada na Pessoa (ACP)',
  'introducao-abordagem-centrada-pessoa-acp',
  '<h1>O que é ACP?</h1><p>Desenvolvida por Carl Rogers, a ACP parte do princípio...</p> (Conteúdo completo)',
  'Conheça os fundamentos da Abordagem Centrada na Pessoa de Carl Rogers e sua visão otimista sobre o potencial humano.',
  'acp-rogers-capa-blog.jpg',
  2, -- Psicologia Humanista...
  1, -- ACP
  1, -- Daniel Dantas
  '2023-11-15 09:00:00+00',
  'publicado'
),
(
  '5 Exercícios Simples de Mindfulness para o Dia a Dia',
  'exercicios-simples-mindfulness-dia-a-dia',
  '<p>Mindfulness não precisa ser complicado. Aqui estão 5 práticas que você pode incorporar...</p> (Conteúdo completo)',
  'Aprenda exercícios práticos e rápidos de atenção plena para reduzir o estresse e aumentar a presença no cotidiano.',
  'mindfulness-exercicios-blog.webp',
  3, -- Bem-Estar Emocional...
  3, -- Mindfulness
  1, -- Daniel Dantas
  '2024-01-10 14:30:00+00',
  'publicado'
),
(
  'Cultivando a Autocompaixão: Um Caminho Gentil',
  'cultivando-autocompaixao-caminho-gentil',
  '<p>Ser gentil consigo mesmo, especialmente em momentos difíceis, é essencial...</p> (Conteúdo completo)',
  'Descubra o que é autocompaixão e como práticas simples podem transformar sua relação consigo mesmo.',
  'autocompaixao-blog.jpg',
  1, -- Autoconhecimento...
  NULL,
  1, -- Daniel Dantas
  '2024-02-01 11:00:00+00',
  'publicado'
),
(
  'Rascunho: Explorando a Focalização', -- Artigo não publicado
  'rascunho-explorando-focalizacao',
  '<p>Conteúdo inicial sobre Focalização...</p>',
  'Um olhar sobre a técnica de Gendlin.',
  NULL, -- Sem imagem ainda
  2, -- Psicologia Humanista...
  2, -- Focalização
  1, -- Daniel Dantas
  NULL, -- Sem data de publicação
  'rascunho' -- Status rascunho
);

-- ## Povoar Tabela: artigos_tags ##
-- Assumindo IDs dos artigos criados acima: 1, 2, 3, 4, 5
-- Assumindo IDs das tags criadas acima
INSERT INTO artigos_tags (artigo_id, tag_id) VALUES
(1, 2), -- Artigo 1 (Empatia) -> Tag Empatia
(1, 11), -- Artigo 1 (Empatia) -> Tag Relacionamento Terapêutico (se aplicável ao contexto)
(2, 1), -- Artigo 2 (ACP) -> Tag Carl Rogers
(2, 2), -- Artigo 2 (ACP) -> Tag Empatia
(2, 3), -- Artigo 2 (ACP) -> Tag Congruência
(2, 4), -- Artigo 2 (ACP) -> Tag Aceitação Incondicional
(2, 13), -- Artigo 2 (ACP) -> Tag Para Estudantes
(3, 7), -- Artigo 3 (Mindfulness) -> Tag Mindfulness para Iniciantes
(3, 8), -- Artigo 3 (Mindfulness) -> Tag Ansiedade
(3, 12), -- Artigo 3 (Mindfulness) -> Tag Técnicas Práticas
(4, 9), -- Artigo 4 (Autocompaixão) -> Tag Autocompaixão
(4, 12); -- Artigo 4 (Autocompaixão) -> Tag Técnicas Práticas
-- Nenhuma tag para o artigo 5 (rascunho) ainda.

-- ## Povoar Tabela: newsletter_assinantes ##
INSERT INTO newsletter_assinantes (email, status_confirmacao, token_confirmacao, data_confirmacao) VALUES
('usuario.confirmado@email.com', 'confirmado', NULL, now() - interval '2 day'), -- Assinante confirmado há 2 dias
('usuario.pendente@email.com', 'pendente', 'token_unico_para_confirmacao_123abc', NULL), -- Assinante aguardando confirmação
('outro.confirmado@provider.net', 'confirmado', NULL, now() - interval '1 month'); -- Assinante confirmado há 1 mês

-- Fim do Script de Exemplo --
```

# **Guia Completo e Definitivo de Alimentação do Banco de Dados - Blog Florescer Humano (Supabase)**

**Versão:** 3.0 (Completa: GUI + SQL + Detalhes)

**Data:** [Data Atual]

### 1. Introdução

### 1.1. Propósito Deste Guia

Bem-vindo(a)! Este é o manual **completo e definitivo** para adicionar, editar e gerenciar todo o conteúdo do blog "Florescer Humano" armazenado no banco de dados Supabase. Se você precisa criar um novo artigo, adicionar uma categoria, atualizar informações de um autor ou associar tags, este guia mostrará como fazer isso passo a passo.

Ele foi elaborado para ser o mais **didático e claro** possível, cobrindo **dois métodos principais** de interação com o banco de dados:

1. **Via Interface Gráfica (Supabase Studio):** O método **visual, recomendado e mais seguro** para o gerenciamento diário do conteúdo, feito diretamente no seu navegador. Ideal para autores e editores.
2. **Via Scripts SQL:** Um método técnico, usando a linguagem SQL, mais adequado para desenvolvedores, administradores, ou para tarefas específicas como povoamento inicial, migrações ou operações em massa.

Nosso objetivo é que, ao final da leitura, você se sinta **totalmente confiante e seguro(a)** para trabalhar com os dados que dão vida ao blog, utilizando o método mais apropriado para sua necessidade e nível de conhecimento técnico.

### 1.2. Para Quem é Este Guia?

Este guia é destinado a **qualquer pessoa** responsável por interagir com os dados do blog:

- **Autores e Editores de Conteúdo:** Devem focar principalmente no **Método 1 (Interface Gráfica - Seção 4)**. As explicações são voltadas para um uso intuitivo e seguro no dia a dia.
- **Administradores do Site e Desenvolvedores:** Podem utilizar ambos os métodos. O **Método 2 (SQL - Seção 5)** oferece mais poder e flexibilidade para tarefas técnicas. A compreensão de ambas as abordagens é útil.

Não é pré-requisito ser um expert em banco de dados para usar a interface gráfica, mas **seguir as instruções com atenção é crucial** para manter a qualidade, a consistência e a integridade do conteúdo e do site.

### 1.3. Métodos de Alimentação: GUI vs. SQL

- **Interface Gráfica (Supabase Studio - Método 1):**
    - **Vantagens:** Visual, intuitivo ("planilha online"), menos propenso a erros graves, não exige conhecimento de SQL, ideal para tarefas pontuais (1 artigo, 1 categoria).
    - **Desvantagens:** Pode ser lento para operações em massa, menos flexível para lógicas complexas.
- **Scripts SQL (Método 2):**
    - **Vantagens:** Poderoso, rápido para operações em massa, permite lógica complexa, ótimo para automação e povoamento inicial.
    - **Desvantagens:** Requer conhecimento de SQL, maior risco de erros se não usado com cuidado (um DELETE sem WHERE pode apagar tudo!), menos visual.

**Recomendação:** Para o dia a dia (criar, editar artigos), **use a Interface Gráfica**. Para configurações iniciais, migrações ou atualizações em lote, **considere o SQL (com supervisão ou por um desenvolvedor)**.

### 1.4. Ferramentas e Pré-requisitos

- **Geral:**
    - **Acesso à Conta Supabase:** Login e senha válidos para o projeto psicologodanieldantas.com no Supabase.
    - **Navegador Web:** Qualquer navegador moderno (Chrome, Firefox, etc.).
- **Para Método 1 (GUI):**
    - **Conteúdo Preparado:** Texto do artigo (idealmente já formatado em Markdown ou HTML, conforme definido para o projeto), resumo, título, nome exato do arquivo de imagem de capa (que já deve estar na pasta public/), informações de categoria/tags/autor.
- **Para Método 2 (SQL):**
    - **SQL Editor:** Acesso ao SQL Editor dentro do painel Supabase ou um cliente SQL externo (DBeaver, pgAdmin, etc.).
    - **Conhecimento Básico de SQL:** Entender comandos como INSERT, UPDATE, DELETE e a importância da cláusula WHERE.
    - **Script SQL:** O arquivo .sql contendo os comandos a serem executados.

---

### 2. Acessando o Banco de Dados (Supabase Studio)

Estes passos são para acessar a interface gráfica onde você gerenciará os dados visualmente.

1. **Login no Supabase:** Abra seu navegador e acesse [supabase.com](https://www.google.com/url?sa=E&q=https%3A%2F%2Fsupabase.com%2F). Faça login usando suas credenciais (e-mail e senha ou método de login configurado).
2. **Selecione o Projeto Correto:** Após o login, você verá seu painel de projetos. Clique no cartão ou nome do projeto associado ao site psicologodanieldantas.com.
3. **Navegue até o "Table Editor":** Dentro do projeto, olhe o menu de navegação na lateral esquerda. Procure por um ícone que se assemelha a uma grade ou planilha. Geralmente, ele está rotulado como **Table Editor**. Clique nele.
4. **Explore a Interface:**
    - **Painel Esquerdo:** Você verá uma lista das "Tabelas" do seu banco de dados (artigos, categorias, tags, etc.). Cada tabela armazena um tipo específico de informação.
    - **Painel Direito:** Ao clicar em uma tabela no painel esquerdo, o painel direito exibirá os dados contidos naquela tabela, em um formato semelhante a uma planilha. Cada linha representa um registro (um artigo, uma categoria), e cada coluna representa um campo de informação (título, slug, status).

---

### 3. Entendendo as Tabelas Principais e Suas Funções

Antes de começar a adicionar ou editar, é fundamental entender o propósito de cada tabela principal com a qual você interagirá.

- **categorias**:
    - **Propósito:** Define as grandes seções temáticas do blog. Pense nelas como os capítulos principais de um livro.
    - **Exemplos:** "Autoconhecimento", "Psicologia Humanista", "Bem-Estar Emocional".
    - **Relação:** Um artigo pertence a **UMA** categoria principal.
- **subcategorias (Opcional):**
    - **Propósito:** Permite subdividir uma categoria principal para maior especificidade.
    - **Exemplos:** Dentro de "Psicologia Humanista", você pode ter subcategorias como "ACP", "Focalização", "Mindfulness".
    - **Relação:** Uma subcategoria pertence a **UMA** categoria principal. Um artigo **PODE** pertencer a **UMA** subcategoria (além da sua categoria principal).
- **autores**:
    - **Propósito:** Armazena os dados das pessoas que escrevem os artigos.
    - **Campos:** Nome, biografia, nome do arquivo da foto (foto_arquivo), link para perfil.
    - **Relação:** Um artigo é escrito por **UM** autor.
- **tags**:
    - **Propósito:** São etiquetas ou palavras-chave que descrevem tópicos específicos abordados em um artigo. Permitem agrupar artigos de forma flexível, cruzando categorias.
    - **Exemplos:** "Carl Rogers", "Ansiedade", "Resiliência", "Técnicas Práticas", "Para Estudantes".
    - **Relação:** Um artigo pode ter **VÁRIAS** tags.
- **artigos**:
    - **Propósito:** **Esta é a tabela central do blog!** Contém o conteúdo de cada post individual.
    - **Campos Principais:** Título (titulo), Identificador de URL (slug), Conteúdo Principal (conteudo), Resumo (resumo), Nome do arquivo da imagem de capa (imagem_capa_arquivo), Status de publicação (status), Data para publicação (data_publicacao), e as conexões (categoria_id, subcategoria_id, autor_id).
- **artigos_tags**:
    - **Propósito:** É uma tabela "ponte" ou "de junção". Sua única função é conectar artigos a tags, permitindo a relação "muitos-para-muitos" (um artigo -> muitas tags; uma tag -> muitos artigos).
    - **Campos:** artigo_id, tag_id. Cada linha representa uma única associação entre um artigo e uma tag.
    - **Interação:** Você geralmente não precisará editar esta tabela diretamente se a interface de edição de artigos permitir selecionar múltiplas tags.

### 3.1. Tabelas que Você **NUNCA** Deve Modificar Diretamente!

Para a segurança e funcionamento do site, é **CRUCIAL** que você **NÃO ACESSE, MODIFIQUE ou EXCLUA** dados das seguintes tabelas:

- **newsletter_assinantes**: Contém dados privados (e-mails) dos assinantes. O acesso e a modificação são restritos por segurança (RLS) e devem ser feitos apenas por mecanismos automatizados e seguros (como uma função backend para inscrição). **Acessar ou vazar esses dados é uma violação grave de privacidade.**
- **Qualquer tabela começando com auth.** (ex: auth.users, auth.schemas): São tabelas internas do sistema de autenticação do Supabase.
- **Qualquer tabela começando com storage.** (ex: storage.objects, storage.buckets): São tabelas internas do sistema de armazenamento de arquivos do Supabase (embora as imagens do blog estejam na pasta public/, o Supabase pode usar o Storage para outras coisas).
- **Qualquer tabela começando com pg_ ou em esquemas como pg_catalog, information_schema**: São tabelas e esquemas internos do sistema PostgreSQL. Modificá-las pode corromper seu banco de dados.
- **Qualquer outra tabela que não esteja listada na seção "Tabelas Principais"**: Se uma tabela aparecer e você não souber o que é, não mexa nela.

**Em resumo: Mantenha o foco nas tabelas categorias, subcategorias, autores, tags, artigos e, se necessário manualmente, artigos_tags.**

---

### 4. Método 1: Gerenciando Conteúdo via Interface Gráfica (GUI - Recomendado)

Este é o passo a passo detalhado para usar o Supabase Studio (Table Editor) no seu dia a dia.

### 4.1. Como Adicionar um Novo Artigo (A Tarefa Mais Comum)

Siga estes passos com **máxima atenção** para garantir que seu artigo seja criado corretamente e apareça como esperado no site.

1. **Abra a Tabela artigos:** No painel esquerdo do Table Editor, clique na tabela artigos. Você verá as colunas e os artigos já existentes (se houver).
2. **Inicie a Inserção:** No canto superior direito da área de dados, localize e clique no botão **"+ Insert row"**. Isso abrirá uma janela de formulário (ou adicionará uma linha editável na tabela) para você inserir os dados do novo artigo.
3. **Preencha os Campos Detalhadamente:**
    - id (Coluna id):
        - **Ação:** **NÃO DIGITE NADA AQUI!** Deixe este campo completamente em branco ou como estiver (pode mostrar "(empty)" ou um placeholder).
        - **Por quê?** Este é o identificador numérico único do artigo. O Supabase o gerará automaticamente quando você salvar. Tentar inserir um ID manualmente pode causar erros.
    - titulo (Coluna titulo) - **Obrigatório:**
        - **Ação:** Digite o título principal e completo do seu artigo, exatamente como você quer que ele apareça no site.
        - **Exemplo Prático:** Explorando o Conceito de "Felt Sense" na Focalização
        - **Importância:** É o título principal (H1) da página do artigo e crucial para SEO.
    - slug (Coluna slug) - **Obrigatório e CRÍTICO:**
        - **O quê é?** É a parte "amigável" do endereço URL que identifica unicamente este artigo. Fica depois de /blogflorescerhumano/[categoria]/.
        - **Ação:** Crie o slug a partir do título, seguindo **RIGOROSAMENTE** estas regras:
            1. Converta todo o título para **letras minúsculas**.
            2. Substitua **TODOS os espaços** por **hífens (-)**.
            3. **Remova** toda a acentuação (á, é, í, ó, ú, â, ê, ô, à, ç, etc.).
            4. **Remova** quaisquer outros caracteres especiais (,, ?, !, :, ;, (, ), ").
            5. Certifique-se de que **não há hífens duplicados** (--). Se houver, substitua por um único hífen.
            6. **Verifique se é ÚNICO!** O sistema dará um erro se você tentar salvar um slug que já existe em outro artigo. Se o slug gerado for muito comum, adicione algo distintivo no final (ex: -com-exemplos, -guia-completo).
        - **Exemplo Prático:** Para o título Explorando o Conceito de "Felt Sense" na Focalização, o slug seria: explorando-o-conceito-de-felt-sense-na-focalizacao
        - **Importância:** É usado diretamente na URL. Mudar o slug de um artigo já publicado quebrará todos os links existentes para ele. **Crie com cuidado na primeira vez!**
    - conteudo (Coluna conteudo) - **Obrigatório:**
        - **Ação:** Cole aqui o corpo principal e completo do seu artigo.
        - **Formato:** Verifique com o administrador qual o formato esperado:
            - **Markdown:** Um formato de texto simples com marcações (ex: # Título, **negrito**, *itálico*, [link](url)).
            - **HTML:** Código HTML completo (ex: <h1>Título</h1>, <p>Parágrafo</p>, <b>negrito</b>).
            - **Texto Simples:** Apenas o texto, sem formatação.
        - **Colar Corretamente:** Se estiver colando de um editor como Word ou Google Docs, cole como "texto simples" para evitar formatações indesejadas, e depois aplique a formatação Markdown/HTML necessária.
        - **Exemplo Prático (Markdown):**
            
            ```sql
                  # Explorando o "Felt Sense"
            
            O conceito de *felt sense*, cunhado por Eugene Gendlin, é central 
            na prática da Focalização...
            
            ## Como Acessar o Felt Sense?
            
            1.  **Preparação:** Encontre um lugar tranquilo...
            2.  **Sensação Corporal:** Volte sua atenção para o corpo...
            
            Para saber mais, veja [este link](https://...).
            ```
            
    - resumo (Coluna resumo) - **Altamente Recomendado:**
        - **Ação:** Escreva um parágrafo curto (idealmente 1-2 frases, máx 160 caracteres) que resuma a ideia principal do artigo.
        - **Exemplo Prático:** Entenda o que é o "felt sense" de Eugene Gendlin e como essa sensação corporal sutil é a chave para o processo terapêutico da Focalização.
        - **Importância:** Aparece nos cards de listagem do blog e é frequentemente usado pelo Google como descrição nos resultados de busca (SEO).
    - imagem_capa_arquivo (Coluna imagem_capa_arquivo) - **MUITO IMPORTANTE:**
        - **Ação:** Digite **EXATAMENTE** o nome do arquivo da imagem de capa (incluindo a extensão .jpg, .png, .webp, etc.) que **JÁ FOI ENVIADO** para a pasta public/blogflorescerhumano/ no código do site.
        - **NÃO FAÇA UPLOAD DA IMAGEM AQUI!** Este campo é apenas o *ponteiro* para o arquivo existente.
        - **Verificação CRUCIAL:** Antes de salvar, confirme se:
            1. A imagem com esse nome existe na pasta public/blogflorescerhumano/.
            2. O nome digitado aqui é **idêntico** (maiúsculas/minúsculas importam em alguns sistemas).
        - **Exemplo Prático:** felt-sense-focalizacao-capa.webp
        - **Se não houver imagem:** Deixe o campo em branco (NULL).
    - categoria_id (Coluna categoria_id) - **Obrigatório:**
        - **Ação:** Clique neste campo. A interface do Supabase **deve apresentar um menu dropdown, um botão de busca ou um seletor** que lista os **NOMES** das categorias já existentes na tabela categorias. Selecione a categoria principal à qual este artigo pertence.
        - **NÃO DIGITE O NÚMERO DIRETAMENTE** a menos que não haja outra opção e você tenha consultado o id correto na tabela categorias. Usar o seletor visual é mais seguro.
        - **Exemplo Prático:** Na lista, clique em "Psicologia Humanista e Abordagens Relacionadas".
    - subcategoria_id (Coluna subcategoria_id) - **Opcional:**
        - **Ação:** Similar à categoria_id. Se o artigo pertencer a uma subcategoria específica (que já deve existir na tabela subcategorias), selecione-a no dropdown/seletor.
        - **Se não aplicável:** Deixe o campo em branco (NULL).
        - **Exemplo Prático:** Selecione "Focalização (Focusing)".
    - autor_id (Coluna autor_id) - **Obrigatório:**
        - **Ação:** Similar à categoria_id. Selecione o nome do autor do artigo no dropdown/seletor, buscando na tabela autores.
        - **Exemplo Prático:** Selecione "Daniel Dantas".
    - data_publicacao (Coluna data_publicacao) - **Importante para Visibilidade:**
        - **Ação:** Use o **calendário e seletor de hora** que a interface oferece.
        - **Para Publicar Agora:** Selecione a data e hora atuais, ou qualquer data/hora no passado.
        - **Para Agendar:** Selecione uma data e hora **no futuro**. O artigo só ficará visível no site após esse momento (combinado com o status 'publicado').
        - **Para Rascunho:** Pode deixar em branco (NULL) ou definir uma data futura, mas o status é o controle principal.
        - **Fuso Horário:** Verifique se o fuso horário está correto (geralmente UTC ou o fuso configurado no Supabase/PostgreSQL).
    - status (Coluna status) - **Obrigatório e CRUCIAL:**
        - **Ação:** Use o **menu dropdown** para selecionar o estado atual do artigo:
            - publicado: Torna o artigo visível no site (se data_publicacao permitir). **Use apenas quando o artigo estiver finalizado e revisado.**
            - rascunho: Salva o artigo no banco, mas ele **NÃO** aparecerá no site público. **Use este enquanto estiver escrevendo ou revisando.**
            - arquivado: Marca o artigo como inativo (geralmente não visível no site), mas o mantém no banco para referência futura.
        - **Exemplo Prático:** Selecione rascunho inicialmente. Mude para publicado apenas quando tudo estiver pronto.
    - data_criacao, data_atualizacao (Colunas data_criacao, data_atualizacao):
        - **Ação:** **IGNORAR.** O sistema preenche e atualiza estes campos automaticamente. Não modifique.
4. **Salvar o Novo Artigo:** Após preencher **cuidadosamente** todos os campos obrigatórios e recomendados, encontre e clique no botão **"Save"** (ou um ícone de checkmark/salvar).
5. **Verificar:** A interface deve confirmar que a linha foi salva. A nova linha aparecerá na tabela artigos. Você pode rolar ou usar filtros para encontrá-la e verificar os dados. **Anote o id gerado** se precisar associar tags manualmente.

### 4.2. Como Associar Tags a um Artigo (via GUI)

Associar tags corretas ajuda os usuários a encontrar conteúdo relacionado.

- **Método 1: Edição Direta no Artigo (Verifique a Interface)**
    1. **Encontre e Edite o Artigo:** Na tabela artigos, localize a linha do artigo que você deseja etiquetar e entre no modo de edição (clique duplo ou botão de editar).
    2. **Procure o Campo de Tags:** Verifique se existe um campo específico para Tags (pode estar rotulado como tags ou ser uma seção separada relacionada).
    3. **Selecione as Tags:** Idealmente, este campo será um **multi-selecionador** (checkboxes, campo de busca que permite adicionar múltiplos itens). Selecione todas as tags relevantes que **já existem** na tabela tags.
    4. **Salve as Alterações:** Clique em "Save" no formulário do artigo. A interface do Supabase (se configurada para isso) cuidará de criar/remover as linhas necessárias na tabela artigos_tags automaticamente.
- **Método 2: Edição Manual na Tabela artigos_tags (Se o Método 1 não existir)**
    1. **Obtenha os IDs:**
        - Anote o id do artigo (da tabela artigos). *Exemplo: O artigo sobre Felt Sense tem id = 6.*
        - Vá para a tabela tags e anote os ids de todas as tags que você quer associar. *Exemplo: 'Felt Sense' tem id=5, 'Eugene Gendlin' tem id=6, 'Técnicas Práticas' tem id=12.*
    2. **Abra a Tabela artigos_tags:** Clique nela no painel esquerdo.
    3. **Insira a Primeira Associação:**
        - Clique "+ Insert row".
        - No campo artigo_id, digite o ID do artigo (Ex: 6).
        - No campo tag_id, digite o ID da primeira tag (Ex: 5).
        - Clique "Save".
    4. **Insira as Demais Associações:**
        - **Repita** o passo 3 para cada tag adicional.
        - Exemplo: "+ Insert row", artigo_id = 6, tag_id = 6, "Save".
        - Exemplo: "+ Insert row", artigo_id = 6, tag_id = 12, "Save".
    5. **Verifique:** Agora você terá múltiplas linhas na tabela artigos_tags com o mesmo artigo_id (6), mas com tag_ids diferentes (5, 6, 12).

### 4.3. Como Adicionar uma Nova Categoria, Tag ou Autor (via GUI)

O processo para adicionar esses itens de suporte é mais simples que o de artigos.

1. **Selecione a Tabela Correta:** No painel esquerdo, clique na tabela desejada: categorias, tags ou autores.
2. **Inicie a Inserção:** Clique no botão **"+ Insert row"**.
3. **Preencha os Campos:**
    - id: **Deixe em branco** (automático).
    - nome (Obrigatório): O nome que será exibido no site.
        - *Exemplo (Categoria):* Filosofia e Existencialismo
        - *Exemplo (Tag):* Fenomenologia
        - *Exemplo (Autor):* Colaborador Convidado
        - **Unicidade:** Para categorias e tags, o nome deve ser **único**.
    - slug (Obrigatório para categorias e tags): Crie o identificador de URL seguindo as regras (minúsculas, hífens, sem acentos/especiais, único).
        - *Exemplo (Categoria):* filosofia-existencialismo
        - *Exemplo (Tag):* fenomenologia
    - descricao (Opcional para categorias e subcategorias): Uma breve descrição do que a categoria/subcategoria abrange. Pode ser usada no site.
    - categoria_id (**Apenas para subcategorias** - Obrigatório): Use o dropdown/seletor para escolher a categoria principal à qual esta subcategoria pertence.
    - **Campos de autores:**
        - biografia: Um texto sobre o autor.
        - foto_arquivo: **APENAS o nome do arquivo** da foto (ex: colaborador-convidado.jpg) que está na pasta public/.
        - perfil_academico_url: Link opcional para Lattes, LinkedIn, etc.
    - data_criacao, data_atualizacao: Ignorar (automático).
4. **Salve:** Clique no botão **"Save"**.

### 4.4. Como Editar um Artigo (ou Categoria, Tag, Autor) (via GUI)

Precisa corrigir um erro de digitação, atualizar um conteúdo, mudar o status ou adicionar uma tag?

1. **Abra a Tabela Correta:** Selecione a tabela (artigos, categorias, etc.) onde o item que você quer editar reside.
2. **Localize a Linha:** Use a rolagem, filtros (ícone de funil) ou a busca (ícone de lupa) na interface do Table Editor para encontrar a linha específica. Você pode filtrar por titulo, slug, id, etc.
3. **Entre no Modo de Edição:** A forma exata pode variar ligeiramente:
    - **Clique Duplo:** Muitas vezes, clicar duas vezes diretamente na célula que você quer alterar permite a edição.
    - **Botão de Edição:** Pode haver um ícone de lápis no início ou fim da linha, ou que aparece ao passar o mouse sobre a linha. Clicar nele pode abrir um formulário de edição para toda a linha.
4. **Modifique os Valores:** Altere o conteúdo dos campos necessários. Lembre-se das regras e cuidados para cada campo (especialmente slug, status, *_arquivo, *_id).
5. **Salve as Alterações:**
    - Se editou diretamente na célula, clicar fora dela ou pressionar Enter geralmente salva (verifique se há confirmação visual).
    - Se usou um formulário de edição, clique no botão "Save" ou "Update".
6. **Verifique:** Confirme se os dados foram atualizados corretamente na tabela. A coluna data_atualizacao deverá mostrar um timestamp recente.

---

### 5. Método 2: Gerenciando Conteúdo via Scripts SQL (Avançado)

Este método é para usuários com conhecimento de SQL ou para tarefas específicas supervisionadas por um desenvolvedor. **Use com extrema cautela.**

### 5.1. Quando Usar SQL?

- **Povoamento Inicial:** Carregar dados base (categorias, tags, autores, primeiros artigos) de forma rápida e programática.
- **Migração de Dados:** Importar conteúdo de outra plataforma.
- **Operações em Massa:** Atualizar ou deletar múltiplos registros que seguem um padrão específico.
- **Consistência Garantida:** Scripts garantem que as mesmas operações sejam executadas da mesma forma sempre.
- **Automação:** Scripts podem ser integrados em processos automatizados.

### 5.2. Ferramenta Principal: SQL Editor do Supabase

A maneira mais integrada de rodar SQL no seu projeto Supabase.

1. **Acesso:** No painel Supabase, clique no ícone **SQL Editor** (<>) no menu esquerdo.
2. **Nova Query:** Clique no botão **"+ New query"**.
3. **Escreva ou Cole:** Digite seus comandos SQL ou cole um script preparado na área de texto principal.
4. **Execução:** Clique no botão **"RUN"** (geralmente um ícone de play).
5. **Resultados e Mensagens:** Os resultados da sua query (se for um SELECT) ou mensagens de sucesso/erro aparecerão no painel inferior. **Leia atentamente as mensagens de erro!**

### 5.3. Exemplo Prático: Povoamento Inicial com o Script Fornecido

O script SQL que você compartilhou é um exemplo perfeito de povoamento inicial. Vamos analisá-lo em blocos para entender a lógica:

```sql
      -- Script SQL para Povoar as Tabelas do Blog "Florescer Humano" (Exemplo)

-- Observações Iniciais (Importantes!)
-- IDs: São auto-gerados. O script assume IDs sequenciais (1, 2, 3...) para criar
--      relacionamentos. Em produção, use `RETURNING id` ou consulte antes.
-- Datas: `now()` pega a hora atual. `data_publicacao` no passado para visibilidade.
-- Imagens: `*_arquivo` = APENAS nome do arquivo na pasta /public/.

-- Bloco 1: Inserir Categorias
INSERT INTO categorias (nome, slug, descricao) VALUES
('Autoconhecimento e Desenvolvimento Pessoal', 'autoconhecimento-desenvolvimento-pessoal', '...'),
('Psicologia Humanista e Abordagens Relacionadas', 'psicologia-humanista-abordagens', '...');
-- ... (mais categorias)
-- Explicação: Adiciona as linhas iniciais na tabela 'categorias'.

-- Bloco 2: Inserir Subcategorias (Depende do ID da Categoria Pai)
-- Assumindo que 'Psicologia Humanista...' obteve id=2 na inserção anterior.
INSERT INTO subcategorias (nome, slug, categoria_id, descricao) VALUES
('Abordagem Centrada na Pessoa (ACP)', 'abordagem-centrada-pessoa-acp', 2, '...'),
('Focalização (Focusing)', 'focalizacao-focusing', 2, '...');
-- ... (mais subcategorias)
-- Explicação: Adiciona subcategorias, ligando-as à categoria pai correta via 'categoria_id'.

-- Bloco 3: Inserir Autores
INSERT INTO autores (nome, biografia, foto_arquivo, perfil_academico_url) VALUES
('Daniel Dantas', 'Psicólogo clínico...', 'daniel-dantas-profile.jpg', 'https://...');
-- Explicação: Adiciona o(s) autor(es) inicial(is).

-- Bloco 4: Inserir Tags
INSERT INTO tags (nome, slug) VALUES
('Carl Rogers', 'carl-rogers'),
('Empatia', 'empatia'),
('Ansiedade', 'ansiedade');
-- ... (mais tags)
-- Explicação: Adiciona as tags iniciais que serão usadas nos artigos.

-- Bloco 5: Inserir Artigos (Depende dos IDs de Categoria, Subcategoria, Autor)
-- Assumindo IDs gerados: Categoria 4='Relacionamentos...', Autor 1='Daniel Dantas'
INSERT INTO artigos (titulo, slug, conteudo, resumo, imagem_capa_arquivo, categoria_id, subcategoria_id, autor_id, data_publicacao, status) VALUES
(
  'A Importância da Empatia nas Relações Humanas',        -- titulo
  'importancia-empatia-relacoes-humanas',              -- slug (ÚNICO!)
  '<p>A empatia...</p>',                                -- conteudo (Markdown/HTML)
  'Entenda por que a empatia é crucial...',              -- resumo
  'importancia-empatia-image-blog.png',                -- imagem_capa_arquivo (Nome exato!)
  4,                                                   -- categoria_id (ID de 'Relacionamentos...')
  NULL,                                                -- subcategoria_id (Sem subcategoria)
  1,                                                   -- autor_id (ID de 'Daniel Dantas')
  '2023-10-26 10:00:00+00',                            -- data_publicacao (Passado para ser visível)
  'publicado'                                          -- status ('publicado' ou 'rascunho')
);
-- ... (mais artigos, incluindo exemplos com status 'rascunho' e data_publicacao NULL)
-- Explicação: Cria os posts, ligando-os aos IDs corretos de categoria/autor e definindo visibilidade.

-- Bloco 6: Associar Tags aos Artigos (Depende dos IDs de Artigos e Tags)
-- Assumindo IDs gerados: Artigo 1='Empatia', Artigo 2='ACP'
-- Assumindo IDs gerados: Tag 2='Empatia', Tag 1='Carl Rogers', Tag 13='Para Estudantes'
INSERT INTO artigos_tags (artigo_id, tag_id) VALUES
(1, 2),   -- Liga Artigo 1 à Tag 2
(2, 1),   -- Liga Artigo 2 à Tag 1
(2, 2),   -- Liga Artigo 2 à Tag 2
(2, 13);  -- Liga Artigo 2 à Tag 13
-- Explicação: Cria as conexões na tabela 'artigos_tags'. Cada linha é uma ligação.

-- Bloco 7: (Opcional/Exemplo) Povoar Newsletter
-- CUIDADO: Geralmente não se insere assinantes manualmente assim.
INSERT INTO newsletter_assinantes (email, status_confirmacao, ...) VALUES ...
```

IGNORE_WHEN_COPYING_START

content_copy  download  Use code [with caution](https://support.google.com/legal/answer/13505487). SQL

IGNORE_WHEN_COPYING_END

**Como Executar:** Copie o bloco de código SQL relevante (ou o script inteiro para povoamento inicial) e cole no SQL Editor do Supabase, depois clique em "RUN". Observe as mensagens de sucesso ou erro.

### 5.4. Exemplo Prático: Edição com UPDATE (SQL)

O comando UPDATE modifica dados em linhas *existentes*.

```sql
      -- Cenário: Mudar o status do artigo com slug 'importancia-empatia-relacoes-humanas'
-- de 'publicado' para 'rascunho'.

UPDATE artigos -- Qual tabela modificar
SET
  status = 'rascunho', -- Qual coluna mudar e para qual valor
  data_atualizacao = now() -- Boa prática atualizar o timestamp de modificação
WHERE
  slug = 'importancia-empatia-relacoes-humanas'; -- CONDIÇÃO CRÍTICA: Qual(is) linha(s) modificar?

-- Cenário: Corrigir um typo no nome da tag com id = 9
UPDATE tags
SET
  nome = 'Autocompaixão Corrigida', -- Novo nome
  slug = 'autocompaixao-corrigida', -- IMPORTANTE: Atualizar o slug também!
  data_atualizacao = now()          -- Atualizar timestamp (se a tabela tiver)
WHERE
  id = 9; -- CONDIÇÃO: Apenas a tag com id=9
```

IGNORE_WHEN_COPYING_START

content_copy  download  Use code [with caution](https://support.google.com/legal/answer/13505487). SQL

IGNORE_WHEN_COPYING_END

**AVISO:** A cláusula WHERE é **ABSOLUTAMENTE ESSENCIAL** no UPDATE. Se você esquecer o WHERE, o comando SET será aplicado a **TODAS AS LINHAS** da tabela, o que pode ser desastroso.

### 5.5. Exemplo Prático: Remoção com DELETE (SQL) - **MUITO CUIDADO!**

O comando DELETE remove linhas inteiras da tabela. **Use com extrema precaução, pois a ação é geralmente irreversível.**

```sql
      -- Cenário: Deletar PERMANENTEMENTE a tag com o slug 'tag-obsoleta'

DELETE FROM tags -- De qual tabela remover
WHERE slug = 'tag-obsoleta'; -- CONDIÇÃO CRÍTICA: Qual(is) linha(s) remover?

-- Cenário: Deletar um artigo específico pelo ID (Ex: ID 5, que era um rascunho)
DELETE FROM artigos
WHERE id = 5; -- Remove apenas o artigo com id=5
```

IGNORE_WHEN_COPYING_START

content_copy  download  Use code [with caution](https://support.google.com/legal/answer/13505487). SQL

IGNORE_WHEN_COPYING_END

**AVISO GRAVÍSSIMO:** Assim como no UPDATE, se você esquecer a cláusula WHERE no DELETE, você apagará **TODO O CONTEÚDO DA TABELA**. Faça backups e tenha certeza absoluta antes de rodar um DELETE. É geralmente mais seguro mudar o status de um artigo para arquivado do que deletá-lo permanentemente.

---

### 6. Campos Importantes e Cuidados Especiais (Resumo Detalhado)

Esta é uma checklist rápida dos pontos mais críticos ao alimentar o banco:

- **id**: **NUNCA** preencha ou modifique manualmente. Deixe o sistema gerar.
- **slug**:
    - **Regras:** Minúsculas, hífens (-) no lugar de espaços, sem acentos ou caracteres especiais.
    - **Unicidade:** Deve ser **ÚNICO** dentro da sua tabela (artigos, categorias, tags).
    - **Permanência:** **EVITE** alterar o slug de um item (especialmente artigo) após ele ter sido publicado e indexado. Crie corretamente da primeira vez.
- **status (Tabela artigos)**:
    - publicado: Visível no site (se data_publicacao OK).
    - rascunho: Salvo, mas não visível. **Use como padrão durante a criação/edição.**
    - arquivado: Inativo, não visível.
- **data_publicacao (Tabela artigos)**:
    - Define *quando* um artigo com status publicado se torna visível.
    - Use o seletor de data/hora na GUI.
    - Formato SQL: 'AAAA-MM-DD HH:MM:SS+ZZ' (Ex: '2024-03-15 10:00:00+00').
- **_arquivo (Colunas de Imagem/Foto)**:
    - **Conteúdo:** Deve conter **APENAS O NOME DO ARQUIVO**, incluindo a extensão (ex: minha-linda-imagem.jpg).
    - **Localização do Arquivo Real:** A imagem correspondente DEVE existir na pasta public/ apropriada (public/blogflorescerhumano/ para capas de artigos, public/psicologodanieldantas/ ou outra pasta para fotos de autor).
    - **Consistência:** O nome no banco deve ser **IDÊNTICO** ao nome do arquivo na pasta public/.
- **_id (Colunas de Relacionamento - ex: categoria_id, autor_id, tag_id em artigos_tags)**:
    - **GUI:** Use sempre o **dropdown/seletor visual** para escolher o item relacionado pelo nome. A interface cuidará de inserir o ID numérico correto.
    - **SQL:** Você precisa fornecer o **id NUMÉRICO correto** do registro na tabela relacionada (ex: o id da categoria, não o nome dela). Consulte a tabela relacionada se necessário.
- **artigos_tags (Tabela de Junção)**:
    - Cada linha representa **UMA** ligação entre UM artigo e UMA tag.
    - Para ligar um artigo a 3 tags, você precisará de 3 linhas nesta tabela, todas com o mesmo artigo_id, mas cada uma com um tag_id diferente.

---

### 7. Segurança e Boas Práticas (Fundamental!)

Seguir estas práticas minimiza riscos e garante a qualidade do blog:

- **Prefira a Interface Gráfica (GUI):** Para o gerenciamento diário de conteúdo, a GUI (Supabase Studio) é mais segura e intuitiva.
- **SQL com Responsabilidade:** Use SQL apenas se souber o que está fazendo ou sob supervisão. Teste scripts complexos em ambiente de desenvolvimento antes da produção, se possível.
- **FOCO nas Tabelas de Conteúdo:** Limite suas interações às tabelas categorias, subcategorias, autores, tags, artigos, artigos_tags.
- **NUNCA TOQUE NO SISTEMA:** Evite a todo custo tabelas auth.*, storage.*, pg_*, e **NUNCA** manipule newsletter_assinantes diretamente (risco de violação de privacidade e LGPD/GDPR).
- **Slugs são (Quase) Permanentes:** Defina slugs cuidadosamente e evite mudá-los após a publicação para não quebrar links e prejudicar o SEO.
- **Verificação Dupla de Imagens:** Sempre confira se o nome do arquivo no campo *_arquivo corresponde EXATAMENTE ao arquivo na pasta public/.
- **Workflow de Publicação:** Crie artigos como rascunho. Revise o conteúdo, as imagens, as tags, a categoria. Somente então mude o status para publicado e defina a data_publicacao.
- **Relacionamentos Corretos:** Verifique se selecionou a categoria, subcategoria (se houver) e autor corretos antes de salvar um artigo.
- **BACKUPS:** O Supabase geralmente faz backups automáticos. No entanto, antes de executar operações SQL de grande impacto (UPDATE ou DELETE em muitas linhas), considere fazer um backup manual ou garantir que um backup recente exista.
- **Em Caso de Dúvida, PARE e PERGUNTE!** É sempre melhor perguntar ao administrador (Daniel Dantas) ou ao desenvolvedor responsável do que arriscar fazer algo errado que possa afetar o site ou a segurança dos dados.

---

### 8. Solução de Problemas Comuns

Encontrou um erro ou algo não funciona como esperado? Verifique estes pontos:

- **Erro "Unique constraint violation" (Interface ou SQL):**
    - **Causa:** Tentativa de salvar um valor que já existe em uma coluna que deve ser única (geralmente slug em artigos/categorias/tags, ou nome em categorias/tags).
    - **Solução:** Verifique o valor que você está tentando inserir e modifique-o para que seja único (ex: crie um slug ligeiramente diferente).
- **Erro "Not-null constraint violation" (Interface ou SQL):**
    - **Causa:** Você deixou em branco um campo que é obrigatório (definido como NOT NULL no banco).
    - **Solução:** Revise o formulário ou o comando INSERT e preencha todos os campos obrigatórios. Consulte a estrutura da tabela se não tiver certeza de quais são (geralmente titulo, slug, conteudo, categoria_id, autor_id, status para artigos).
- **Artigo Não Aparece no Site:**
    - **Checklist:**
        1. O status na tabela artigos está como publicado?
        2. A data_publicacao está definida para **agora ou uma data/hora no passado**? (Se estiver no futuro, está agendado).
        3. A categoria_id e autor_id estão preenchidos corretamente e apontam para registros válidos?
        4. (Avançado) Verifique se há algum erro no console do navegador ou nos logs do servidor Next.js que possa indicar um problema ao buscar/renderizar o artigo.
- **Imagem Não Aparece no Site:**
    - **Checklist:**
        1. O nome do arquivo no campo imagem_capa_arquivo (ou foto_arquivo) na tabela artigos (ou autores) está **EXATAMENTE** igual ao nome do arquivo na pasta public/? (Verifique maiúsculas/minúsculas, extensão).
        2. O arquivo de imagem correspondente foi **realmente enviado** para a pasta correta (public/blogflorescerhumano/ ou outra) no projeto do site?
        3. O caminho da imagem no código do site (no componente que a exibe) está sendo construído corretamente (ex: /blogflorescerhumano/ + nome do arquivo)?
- **Erro de Sintaxe SQL (Ao usar SQL Editor):**
    - **Causa:** Você digitou um comando SQL incorretamente (palavra-chave errada, vírgula faltando, aspas desbalanceadas, etc.).
    - **Solução:** Leia a mensagem de erro do PostgreSQL cuidadosamente. Ela geralmente indica a linha e a posição do erro. Revise a sintaxe do seu comando comparando com os exemplos ou com a documentação SQL.

---

### 9. Onde Obter Ajuda

Se você seguiu este guia, verificou a solução de problemas e ainda está com dificuldades, ou se tem alguma dúvida sobre um procedimento específico:

- **Contato Principal:** Entre em contato com **Daniel Dantas**.
- **Contato Técnico:** Se for um problema mais técnico, Daniel Dantas pode direcioná-lo ao desenvolvedor responsável pelo site.

**Não hesite em pedir ajuda!** É melhor esclarecer uma dúvida do que cometer um erro que possa impactar o blog.

---

# **Documentação Adicional: Arquitetura da Informação - Requisitos Não Cumpridos Formalmente**

**Projeto:** Blog-site Daniel Dantas - Módulo "Florescer Humano"

**Status:** Planejamento AI (Refinamento Pendente)

**Versão:** 1.0 (Suplemento)

**Data:** [Data Atual]

### 1. Introdução

Esta documentação complementa a "Documentação da Arquitetura da Informação: Blog Florescer Humano" principal. O objetivo aqui é detalhar os passos e requisitos do processo de criação da AI que foram identificados como **não formalmente cumpridos** ou **parcialmente cumpridos** durante nossa fase inicial de planejamento e discussão.

Embora a AI base definida seja robusta, a execução formal destes passos adicionais pode **validar, refinar e otimizar** ainda mais a estrutura, garantindo uma maior adequação às necessidades reais dos usuários e maximizando a eficácia do blog em alcançar seus objetivos. Estes passos são recomendados como parte de um processo de design centrado no usuário e podem ser implementados em fases posteriores ou conforme a disponibilidade de recursos.

### 2. Personas Detalhadas

### 2.1. O que são e Por que são Importantes

- **O que são:** Personas são representações semi-fictícias, mas baseadas em dados (ou conhecimento do público), dos seus usuários ideais. Elas vão além da simples segmentação (P1, P2, P3), dando um rosto, nome, história, motivações, objetivos e pontos de dor a esses segmentos.
- **Por que são Importantes:**
    - **Empatia:** Ajudam a equipe (você, desenvolvedores, futuros colaboradores) a se colocar no lugar do usuário real ao tomar decisões sobre conteúdo, design e funcionalidade.
    - **Foco no Usuário:** Mantêm as necessidades do usuário no centro do processo de design e desenvolvimento.
    - **Tomada de Decisão:** Servem como um critério para avaliar se uma nova ideia de conteúdo, funcionalidade ou mudança na AI realmente atende às necessidades de pelo menos um dos públicos-alvo.
    - **Alinhamento:** Criam um entendimento compartilhado sobre para quem o blog está sendo construído.
    - **Refinamento da AI:** Ajudam a escolher rótulos (labeling) mais eficazes, priorizar categorias e definir fluxos de navegação que ressoem com as expectativas e o conhecimento prévio de cada persona.

### 2.2. Como Implementar (Passo a Passo Sugerido)

1. **Coleta de Dados/Conhecimento:** Reúna informações sobre seus públicos-alvo (P1, P2, P3). Inicialmente, isso pode ser baseado no seu conhecimento como psicólogo, nas interações que já teve, e nos objetivos do blog. Em fases futuras, pesquisas (questionários, entrevistas) podem aprofundar esse entendimento.
2. **Identificação de Padrões:** Analise os dados e procure por padrões de comportamento, necessidades, objetivos e dores comuns dentro de cada segmento prioritário (P1, P2, P3).
3. **Criação dos Perfis de Persona:** Crie 1 a 2 personas detalhadas para cada segmento prioritário (foco inicial em P1). Inclua:
    - **Nome Fictício e Foto:** Para humanizar a persona.
    - **Demografia Básica:** Idade, ocupação, localização (se relevante).
    - **Contexto e Cenário:** Uma breve história sobre sua vida, desafios e relação com os temas do blog (autoconhecimento, psicologia).
    - **Objetivos:** O que essa persona espera alcançar ao visitar o blog "Florescer Humano"? (ex: "Entender minha ansiedade", "Aprender técnicas de mindfulness", "Encontrar material sobre ACP para a faculdade").
    - **Necessidades:** O que ela precisa do blog para atingir seus objetivos? (ex: "Linguagem clara", "Exemplos práticos", "Referências confiáveis", "Navegação fácil").
    - **Dores (Pain Points):** Quais frustrações ela enfrenta ao buscar esse tipo de informação online? (ex: "Jargão técnico excessivo", "Conteúdo superficial", "Dificuldade em encontrar fontes confiáveis").
    - **Comportamento Online/Tecnológico:** É familiarizada com blogs? Usa mais celular ou desktop?
    - **Citação Chave:** Uma frase que capture a essência da persona em relação ao blog.
4. **Compartilhamento e Refinamento:** Compartilhe as personas criadas para garantir alinhamento. Refine-as à medida que aprender mais sobre seu público.

### 2.3. Exemplo Aplicado ao "Florescer Humano"

- **Persona P1 (Esboço):** "Mariana Silva, 32 anos, Designer Gráfica". Sente-se ansiosa e desconectada, buscando autoconhecimento e formas práticas de bem-estar. Objetivo: Encontrar artigos inspiradores e técnicas simples (como mindfulness) que possa aplicar no dia a dia. Dor: Acha muitos conteúdos de psicologia intimidadores ou "clichês". Necessita: Linguagem acolhedora, exemplos práticos, navegação intuitiva por temas como "Ansiedade" e "Autocompaixão".
- **Persona P2 (Esboço):** "João Pedro, 20 anos, Estudante de Psicologia (2º ano)". Curioso sobre abordagens humanistas, especialmente ACP. Objetivo: Encontrar explicações claras sobre conceitos de Rogers e Maslow, entender a aplicação prática e talvez referências para trabalhos. Dor: Dificuldade em conectar a teoria com a prática. Necessita: Conteúdo organizado por abordagem/autor, links para fontes, talvez glossário.
- **Persona P3 (Esboço):** "Dr. Ricardo Almeida, 45 anos, Psicoterapeuta". Já trabalha com abordagem humanista, busca aprofundamento e reflexões sobre a prática. Objetivo: Ler análises de caso, discussões sobre desafios clínicos, integração com outras técnicas (Focalização). Dor: Falta de espaços online com discussões clínicas humanistas de qualidade em português. Necessita: Conteúdo aprofundado, referências a pesquisas recentes, seção de materiais/referências.

### 2.4. Benefícios Esperados

- Melhor direcionamento na criação de conteúdo, garantindo relevância.
- Validação da estrutura de categorias e subcategorias (elas atendem aos objetivos das personas?).
- Escolha de rótulos e linguagem mais eficazes na navegação.
- Priorização de funcionalidades futuras baseadas nas necessidades reais.

### 3. Mapeamento Explícito de Jornadas do Usuário

### 3.1. O que é e Por que é Importante

- **O que é:** O mapeamento da jornada do usuário é a visualização das etapas que um usuário (representado por uma persona) percorre para atingir um objetivo específico no seu blog. Ele detalha ações, pensamentos, emoções e pontos de contato em cada etapa.
- **Por que é Importante:**
    - **Visão Holística:** Mostra a experiência completa do usuário, não apenas interações isoladas.
    - **Identificação de Gargalos:** Revela onde os usuários podem encontrar dificuldades, se sentir confusos ou frustrados na navegação ou na busca por informação (problemas na AI).
    - **Otimização de Fluxos:** Ajuda a identificar oportunidades para tornar a jornada mais suave, eficiente e agradável.
    - **Validação da AI na Prática:** Testa se a estrutura de categorias, a busca e a navegação realmente funcionam para cenários de uso comuns.
    - **Alinhamento:** Garante que todos entendam como os usuários realmente interagem com o blog para alcançar seus objetivos.

### 3.2. Como Implementar (Passo a Passo Sugerido)

1. **Escolha a Persona e o Cenário/Objetivo:** Selecione uma das personas criadas (ex: Mariana) e um objetivo específico que ela teria no blog (ex: "Encontrar informações introdutórias sobre como a Focalização pode ajudar com a ansiedade").
2. **Defina as Etapas da Jornada:** Liste as principais fases que a persona passaria para atingir o objetivo. Ex: Descoberta (chegou via Google/Rede Social), Exploração Inicial (navega na homepage/menu), Busca/Navegação Específica (usa busca ou categorias), Consumo de Conteúdo (lê o artigo), Ação Seguinte (lê artigo relacionado, comenta, sai).
3. **Detalhe Cada Etapa:** Para cada etapa, descreva:
    - **Ações do Usuário:** O que a persona faz concretamente? (ex: "Clica na categoria 'Psicologia Humanista'", "Digita 'Focalização ansiedade' na busca", "Rola a página do artigo").
    - **Pontos de Contato:** Com quais elementos da interface ela interage? (ex: Menu, Barra de Busca, Card de Artigo, Título H2, Botão de Compartilhar).
    - **Pensamentos do Usuário:** O que ela pode estar pensando? (ex: "Será que encontro algo prático aqui?", "Essa categoria parece muito teórica", "Gostei deste artigo, tem mais sobre isso?").
    - **Emoções do Usuário:** Como ela pode estar se sentindo? (ex: Curiosa, Confusa, Aliviada, Inspirada, Frustrada).
    - **Pontos de Dor:** Onde a experiência falha ou causa atrito? (ex: "Busca não retornou resultados relevantes", "Navegação entre categorias confusa", "Linguagem muito técnica no início").
4. **Identifique Oportunidades:** Com base nos pontos de dor e na análise da jornada, identifique oportunidades para melhorar a AI, o conteúdo ou o design (ex: "Melhorar rótulos das categorias", "Adicionar filtro por nível de dificuldade", "Otimizar resultados da busca", "Incluir mais links internos relevantes").
5. **Visualize (Opcional):** Crie um diagrama visual da jornada (timeline ou fluxograma).

### 3.3. Exemplo Aplicado ao "Florescer Humano"

- **Jornada:** João Pedro (Estudante) buscando a diferença entre ACP e Psicanálise.
    - *Etapa 1 (Busca):* Digita "diferença ACP Psicanálise" no Google. Encontra um artigo do blog.
    - *Etapa 2 (Consumo):* Lê o artigo. Acha útil, mas quer aprofundar nos conceitos da ACP.
    - *Etapa 3 (Navegação):* Clica na categoria "Psicologia Humanista" associada ao artigo.
    - *Etapa 4 (Exploração Categoria):* Vê a lista de artigos. *Pensamento/Dor:* "Muitos títulos, não sei qual foca nos fundamentos de Rogers". *Oportunidade:* Adicionar subcategorias como "Fundamentos Teóricos da ACP" ou tags mais específicas.
    - *Etapa 5 (Nova Busca/Saída):* Usa a busca interna ou sai do site.

### 3.4. Benefícios Esperados

- Identificação e correção de problemas de usabilidade na navegação e estrutura da AI.
- Fluxos de tarefas mais eficientes para os usuários.
- Melhor compreensão de como diferentes públicos interagem com o conteúdo.
- Insights para otimizar a apresentação do conteúdo e CTAs (Chamadas para Ação).

### 4. Validação Formal da Arquitetura (Ex: Card Sorting)

### 4.1. O que é e Por que é Importante

- **O que é:** Card Sorting é uma técnica de pesquisa UX onde os participantes organizam tópicos (escritos em "cartões", físicos ou digitais) em grupos que fazem sentido para eles. Pode ser:
    - **Aberto:** Os participantes criam seus próprios nomes para os grupos.
    - **Fechado:** Os participantes organizam os tópicos em categorias predefinidas.
- **Por que é Importante:**
    - **Validação da Estrutura:** Testa se a estrutura de categorias e subcategorias definida na AI corresponde aos modelos mentais dos usuários reais.
    - **Refinamento de Rótulos:** O Card Sorting Aberto revela a linguagem que os usuários usam naturalmente para descrever os grupos de conteúdo, ajudando a refinar os nomes das categorias/subcategorias.
    - **Identificação de Conteúdo Ambíguo:** Mostra quais tópicos são difíceis de categorizar pelos usuários.
    - **Baseado em Dados:** Fornece dados qualitativos e quantitativos para justificar decisões sobre a organização do conteúdo, em vez de depender apenas da intuição.

### 4.2. Como Implementar (Passo a Passo Sugerido)

1. **Prepare os Cartões:** Crie uma lista de tópicos representativos do conteúdo planejado para o blog (cerca de 30-60 tópicos é um bom número). Use títulos de artigos planejados, conceitos chave, temas específicos. Ex: "Técnicas de respiração mindfulness", "Conceito de Tendência Atualizante (Rogers)", "Como lidar com a autocrítica", "História da Psicologia Humanista", "Poema: Sobre Flores...", "Diferenças ACP vs Behaviorismo".
2. **Escolha o Método:** Decida entre Card Sorting Aberto (para descobrir a estrutura ideal) ou Fechado (para validar uma estrutura existente). Aberto é geralmente melhor nas fases iniciais. Decida se será moderado (você guia o participante) ou não moderado, e se usará ferramentas online (ex: OptimalSort, Maze) ou cartões físicos.
3. **Recrute Participantes:** Recrute um número representativo de participantes de cada segmento do seu público-alvo (P1, P2, P3). Cerca de 5-10 participantes por segmento podem fornecer bons insights.
4. **Conduza as Sessões:** Explique claramente a tarefa ao participante. No Aberto: "Agrupe estes cartões de forma que faça sentido para você e depois dê um nome a cada grupo". No Fechado: "Coloque cada cartão na categoria predefinida onde você esperaria encontrá-lo". Observe o processo, peça para "pensarem em voz alta" (se moderado), mas evite influenciar.
5. **Analise os Resultados:** Procure por padrões: Quais cartões foram frequentemente agrupados juntos? Quais nomes de grupos surgiram no Aberto? Quais categorias foram mais consistentes/confusas no Fechado? Use ferramentas de análise (matrizes de similaridade, dendrogramas) se disponíveis.
6. **Refine a AI:** Use os insights da análise para ajustar sua estrutura de categorias, subcategorias e a nomenclatura (rótulos) na AI do blog.

### 4.3. Exemplo Aplicado ao "Florescer Humano"

- Realizar um Card Sorting Aberto com participantes de P1, P2 e P3 usando tópicos chave.
- *Análise:* Verificar se os grupos criados pelos participantes se alinham com as categorias planejadas ("Autoconhecimento", "Psicologia Humanista", etc.). Observar se os nomes dados pelos participantes (especialmente P1) são mais intuitivos que os rótulos atuais. Identificar se tópicos como "Focalização" são consistentemente agrupados ou se causam confusão.

### 4.4. Benefícios Esperados

- Confirmação (ou correção) da estrutura de categorias baseada em como os usuários pensam.
- Rótulos de navegação mais claros e intuitivos.
- Redução da probabilidade de usuários se perderem ou não encontrarem o conteúdo desejado.
- Maior confiança na arquitetura da informação definida.

### 5. Diagrama Visual da Arquitetura da Informação

### 5.1. O que é e Por que é Importante

- **O que é:** Uma representação gráfica (fluxograma, mapa mental, diagrama de blocos) da estrutura do site, mostrando as páginas principais, seções, categorias e as relações hierárquicas e de navegação entre elas.
- **Por que é Importante:**
    - **Visão Geral Clara:** Oferece uma compreensão rápida e visual de toda a estrutura do blog, mais fácil de absorver do que apenas texto.
    - **Comunicação:** Facilita a comunicação da AI para designers, desenvolvedores e outras partes interessadas.
    - **Identificação de Fluxos e Hierarquia:** Torna explícitas as relações entre as páginas e os principais caminhos de navegação.
    - **Planejamento de Design/Desenvolvimento:** Serve como um blueprint visual para as fases de design de interface e desenvolvimento técnico (mapeamento de rotas).

### 5.2. Como Implementar (Passo a Passo Sugerido)

1. **Escolha uma Ferramenta:** Utilize uma ferramenta de diagramação online (Miro, Figma, FigJam, Lucidchart, Draw.io) ou mesmo papel e caneta.
2. **Defina o Nível de Detalhe:** Decida se o diagrama mostrará apenas as páginas principais e categorias, ou se incluirá subcategorias e tipos de conteúdo específicos.
3. **Comece pelo Topo:** Inicie com a página inicial do blog (/blogflorescerhumano/).
4. **Mapeie as Seções Principais:** Adicione blocos/nós para cada item da navegação principal (Artigos, Categorias, Sobre, Materiais, Contato, etc.).
5. **Detalhe as Hierarquias:** Mostre como as categorias se ramificam em subcategorias (se aplicável) e como ambas levam às páginas de artigos individuais. Use linhas ou setas para indicar os links de navegação.
6. **Use Convenções Visuais:** Utilize formas, cores ou estilos consistentes para representar diferentes tipos de páginas ou níveis hierárquicos.
7. **Adicione Anotações (Opcional):** Inclua breves notas no diagrama para explicar decisões específicas ou fluxos importantes.
8. **Mantenha Atualizado:** Atualize o diagrama se a AI for modificada durante o processo.

### 5.3. Exemplo Aplicado ao "Florescer Humano"

- Criar um diagrama que mostre o nó raiz (/blogflorescerhumano/) conectado aos nós da Navbar (Artigos, Categorias, Sobre, etc.).
- O nó Categorias se conecta a nós individuais para cada categoria principal (ex: "Autoconhecimento").
- Cada nó de categoria principal se conecta a um nó genérico "Página de Artigo" ou a nós de subcategorias, se definidos.
- Indicar visualmente a presença da busca e do link de retorno ao site principal.

### 5.4. Benefícios Esperados

- Compreensão rápida e compartilhada da estrutura completa do blog.
- Facilita a identificação de inconsistências ou complexidades na navegação.
- Serve como referência visual clara para as equipes de design e desenvolvimento.
- Ajuda a garantir que todas as seções planejadas estejam representadas na estrutura final.

### 6. Conclusão

A execução formal destes passos adicionais – criação de personas detalhadas, mapeamento de jornadas do usuário, validação via Card Sorting e criação de um diagrama visual – representa um investimento na qualidade e na eficácia da Arquitetura da Informação do blog "Florescer Humano". Embora a AI atual seja sólida, estas técnicas oferecem oportunidades valiosas para refinar a estrutura com base em uma compreensão mais profunda e validada das necessidades e comportamentos dos usuários finais, garantindo que o "jardim de reflexão, aprendizado e encontro" seja verdadeiramente acolhedor e fácil de navegar para todos os públicos.

---

## **Simulação 1 Documentação Conclusiva da Arquitetura da Informação (AI) - Blog Florescer Humano**

**Projeto:** Blog-site Daniel Dantas - Módulo "Florescer Humano"

**Status:** Documentação AI Concluída (Fase de Planejamento Final)

**Versão:** 1.1

**Data:** [Data Atual]

### 1. Introdução e Propósito

Esta documentação representa a conclusão do planejamento da Arquitetura da Informação (AI) para o módulo do blog "Florescer Humano", a ser hospedado em psicologodanieldantas.com/blogflorescerhumano/. Ela consolida todas as definições anteriores sobre objetivos, público, conteúdo e estrutura, e **integra os resultados de uma simulação dos passos de refinamento da AI** (Criação de Personas Detalhadas, Mapeamento de Jornadas do Usuário, Validação por Card Sorting e Descrição do Diagrama Visual).

O propósito deste documento final é servir como um **guia abrangente e validado (através de simulação)** para as próximas fases de design de interface (UI), design de experiência do usuário (UX) e desenvolvimento técnico. Ele detalha a organização do conteúdo, os sistemas de navegação, a rotulagem e a estrutura técnica subjacente, garantindo que o blog seja intuitivo, encontrável (bom para SEO), fácil de usar e eficaz em cumprir sua missão de "cultivar a compreensão e a vivência dos princípios do humanismo".

Embora as etapas de refinamento (personas, jornadas, card sorting) tenham sido simuladas com base no conhecimento atual do projeto, este exercício permitiu antecipar necessidades, identificar potenciais pontos de atrito e refinar a AI para melhor atender aos diversos públicos-alvo.

### 2. Simulação de Personas Detalhadas

Para aprofundar o entendimento do público-alvo e guiar as decisões da AI, simulamos a criação das seguintes personas detalhadas, baseadas nos segmentos priorizados:

- **Persona P1: Mariana - A Buscadora Consciente (32 anos, Designer Gráfica)**
    - **Contexto:** Vivencia ansiedade e desconexão devido às pressões da vida moderna. Busca ativamente autoconhecimento, equilíbrio e propósito de forma autêntica, mas sente-se intimidada por jargões psicológicos complexos ou abordagens superficiais de autoajuda.
    - **Objetivos no Blog:** (1) Encontrar artigos inspiradores e reflexivos sobre seus sentimentos (ansiedade, busca por sentido). (2) Descobrir técnicas práticas e acessíveis (Mindfulness, autocompaixão) para o dia a dia. (3) Sentir-se acolhida em um espaço que valoriza a experiência subjetiva.
    - **Necessidades da AI:** Navegação clara por temas emocionais (Categorias: "Bem-Estar Emocional", "Autoconhecimento"). Linguagem acessível nos rótulos. Fácil acesso a artigos práticos (Tags: "Técnicas Práticas", "Para Iniciantes"). Categoria "Florescer na Vida" (poemas, histórias) é atraente.
    - **Dores:** Frustração com conteúdo superficial ou excessivamente técnico. Dificuldade em encontrar um caminho claro em sites com muita informação desorganizada.
- **Persona P2: João Pedro - O Estudante Curioso (20 anos, Estudante de Psicologia)**
    - **Contexto:** No início do curso, interessado em psicologia humanista (especialmente ACP de Rogers). Busca entender os fundamentos teóricos, comparações com outras escolas e aplicações básicas.
    - **Objetivos no Blog:** (1) Encontrar explicações claras sobre conceitos chave (tendência atualizante, empatia). (2) Entender as bases da ACP e Focalização. (3) Acessar referências para trabalhos acadêmicos. (4) Ver como o humanismo se posiciona frente a outras abordagens.
    - **Necessidades da AI:** Categoria "Psicologia Humanista" bem estruturada (Subcategorias: "Teoria ACP", "Focalização", "Autores"). Tags específicas para conceitos ("Empatia Rogers", "Hierarquia Maslow"). Seção "Materiais" com referências. Artigos com tag "Comparativo".
    - **Dores:** Dificuldade em achar material humanista de qualidade em português. Falta de conexão clara entre teoria e exemplos.
- **Persona P3: Dr. Ricardo - O Terapeuta Reflexivo (45 anos, Psicoterapeuta Humanista)**
    - **Contexto:** Profissional experiente buscando aprimoramento, reflexão sobre a prática e integração de técnicas como Focalização e Mindfulness de forma ética e fundamentada.
    - **Objetivos no Blog:** (1) Ler reflexões sobre prática clínica humanista (relação terapêutica, ética, desafios). (2) Encontrar discussões sobre integração de técnicas (ACP + Focalização). (3) Acessar estudos de caso ou análises complexas (se disponíveis). (4) Manter-se atualizado sobre eventos/publicações relevantes (via "Materiais").
    - **Necessidades da AI:** Conteúdo claramente identificado por nível (Tags: "Avançado", "Prática Clínica"). Filtros por nível de audiência. Seção "Materiais" robusta. Subcategoria "Discussões Clínicas".
    - **Dores:** Escassez de conteúdo online aprofundado sobre prática clínica humanista. Dificuldade em encontrar discussões práticas e bem fundamentadas.

*(Este exercício de simulação de personas reforça a necessidade de uma AI que suporte diferentes níveis de profundidade e intenções de busca, desde o acolhimento e a praticidade para P1 até a estrutura teórica e clínica para P2 e P3).*

### 3. Simulação de Mapeamento de Jornadas do Usuário

Mapeamos jornadas simuladas para validar a fluidez da AI em cenários de uso comuns para cada persona:

- **Jornada 1 (Mariana - P1): Encontrar alívio prático para ansiedade.**
    1. **Entrada:** Google ("técnicas humanistas ansiedade") -> Artigo "Ansiedade na Ótica Humanista".
    2. **Consumo:** Lê o artigo, busca dicas práticas.
    3. **Navegação:** Clica na tag "Mindfulness" ou usa busca "exercícios mindfulness".
    4. **Exploração:** Encontra artigo com guia prático.
    5. **Ação:** Lê/pratica. Considera assinar newsletter.
    - *Pontos de Dor Simulados/Oportunidades AI:* Necessidade de CTAs claros para conteúdo prático; tags consistentes ("Técnicas Práticas"); busca eficaz; talvez subcategoria "Práticas de Bem-Estar".
- **Jornada 2 (João Pedro - P2): Entender "Empatia" segundo Rogers.**
    1. **Entrada:** Acesso direto -> Menu -> Categorias -> "Psicologia Humanista".
    2. **Exploração:** Lista de artigos. Procura por "Rogers" ou "Empatia". *Dor:* Lista pode ser longa sem filtros/subcategorias.
    3. **Busca:** Usa busca interna "empatia Carl Rogers".
    4. **Consumo:** Lê artigo explicativo.
    5. **Aprofundamento:** Busca referências/artigos relacionados sobre "Condições Necessárias". *Dor:* Dificuldade em achar material conectado.
    - *Oportunidades AI:* Implementar Subcategorias ("Teoria ACP") ou filtros por tags conceituais; melhorar seção "Conteúdo Relacionado"; robustecer seção "Materiais".
- **Jornada 3 (Dr. Ricardo - P3): Buscar integração ACP e Focalização na prática.**
    1. **Entrada:** Busca ("integração ACP focalização clínica") -> Artigo no blog.
    2. **Navegação:** Usa busca interna ou tags ("Prática Clínica", "Focalização").
    3. **Consumo:** Lê artigo sobre o tema. Busca exemplos/discussões mais aprofundadas.
    4. **Exploração Adicional:** Verifica "Materiais" por workshops/referências. *Dor:* Maioria do conteúdo pode ser introdutório.
    - *Oportunidades AI:* Tags/Filtros por "Nível de Audiência"; Subcategoria "Discussões Clínicas"; curadoria de "Materiais" para profissionais.

*(A simulação das jornadas destaca a importância crucial dos sistemas de navegação secundária (filtros, tags), busca interna eficaz, e da conexão estratégica entre conteúdos de diferentes níveis e propósitos).*

### 4. Simulação de Validação por Card Sorting

Simulamos os resultados de um Card Sorting Aberto para validar e refinar a estrutura de categorias e a rotulagem:

- **Descobertas Simuladas:**
    - **Estrutura Geral:** Confirmação provável das 5 categorias temáticas principais como agrupamentos lógicos para a maioria dos usuários.
    - **Rotulagem (P1 vs. P2/P3):** Público P1 (Mariana) tenderia a usar rótulos mais focados em sentimento/ação ("Lidando com Emoções", "Meu Crescimento"), enquanto P2/P3 (João, Ricardo) usariam termos mais técnicos/acadêmicos alinhados às categorias planejadas.
    - **Granularidade:** P2 e P3 demonstrariam necessidade de subdivisões mais claras dentro de "Psicologia Humanista" (por autor, abordagem, teoria vs. prática).
    - **Ambiguidade:** Tópicos como "Mindfulness" (visto como técnica transversal), "Autenticidade" (conceito amplo) e "Florescer na Vida" (mais abstrato) poderiam gerar agrupamentos inconsistentes, indicando necessidade de clareza ou uso estratégico de tags.
- **Recomendações Derivadas da Simulação:**
    1. **Manter Categorias Principais:** Estrutura validada.
    2. **Otimizar Rótulos:** Manter nomes formais, mas adicionar descrições acessíveis nas páginas de categoria e usar linguagem empática nos títulos/conteúdo.
    3. **Implementar Subcategorias/Tags:** Essencial para "Psicologia Humanista" e útil para filtrar por nível/contexto em outras categorias. Tornar tags visíveis e funcionais para filtro.
    4. **Clarificar Categorias:** Usar descrições introdutórias nas páginas de categoria para definir claramente o escopo (especialmente "Florescer na Vida").
    5. **Fortalecer Conexões:** Usar tags e links internos para conectar tópicos ambíguos (ex: artigo sobre Mindfulness pode ter tag "Técnica Prática" e "Bem-Estar Emocional").

*(A simulação do Card Sorting valida a estrutura macro, mas enfatiza a necessidade de mecanismos de organização secundária (subcategorias, tags) e de atenção cuidadosa à rotulagem para atender aos diferentes modelos mentais e linguagens dos públicos).*

### 5. Descrição do Diagrama Visual da AI (Simulado)

Um diagrama visual da AI (mapa do site hierárquico) foi concebido para representar a estrutura:

- **Nível 0:** Nó Raiz (/blogflorescerhumano/).
- **Nível 1:** Nós conectados à Raiz representando os itens da Navbar (Início/Artigos, Categorias, Sobre, Materiais, Mídias, Contato). Elementos globais (Busca, Link Site Principal) são indicados.
- **Nível 2:** O nó Categorias ramifica para os nós das 5 categorias principais. Outros nós de Nível 1 levam às suas páginas estáticas correspondentes.
- **Nível 3+:** Cada nó de Categoria Principal conecta-se a:
    - Nós representando Subcategorias planejadas (ex: dentro de "Psicologia Humanista").
    - Um nó genérico representando a "Página de Artigo Individual" (/[categoria]/[slug]/), acessível a partir das páginas de listagem de categorias/subcategorias.
- **Relações:** Linhas/setas indicam os principais fluxos de navegação (Homepage -> Categoria -> Artigo; Homepage -> Busca -> Artigo; Artigo -> Artigo Relacionado).
- **Consistência:** Rodapé com links padronizados (Política de Privacidade) presente em todas as páginas.

*(Este diagrama serviria como um blueprint visual claro para desenvolvedores e designers, mapeando a hierarquia e os caminhos de navegação principais).*

### 6. Conclusão e Próximos Passos

A Arquitetura da Informação planejada para o blog "Florescer Humano", conforme detalhada e refinada através dos exercícios simulados de personas, jornadas e validação, apresenta-se como uma base **sólida, coerente e centrada no usuário**. Ela equilibra as necessidades do público principal (P1 - Autoconhecimento) com as dos públicos secundários (P2 - Estudantes, P3 - Profissionais), estabelecendo uma estrutura lógica e navegável.

**Pontos Fortes Consolidados:**

- Clara organização temática em 5 categorias principais.
- Foco estratégico no público P1, mas com caminhos definidos para P2 e P3.
- Integração de sistemas de organização secundária (subcategorias, tags) para flexibilidade e profundidade.
- Sistemas de navegação (global, local, contextual, busca) bem definidos.
- Estrutura técnica modular e escalável (Next.js, Supabase, Giscus).
- Ênfase na segurança desde o início (RLS no Supabase é essencial, mesmo sem login no front-end, para proteger a leitura via API pública).

**Recomendações Finais para Implementação:**

1. **Implementar Estrutura:** Construir a estrutura de pastas e rotas no Next.js conforme detalhado.
2. **Configurar Supabase e RLS:** Criar tabelas, habilitar RLS e **definir políticas de segurança RÍGIDAS**, especialmente para newsletter_assinantes e para garantir que apenas artigos publicados sejam lidos pela API pública (anon key).
3. **Desenvolver Navegação:** Criar a Navbar responsiva, filtros de categoria/tag funcionais e a busca interna.
4. **Rotulagem e Descrições:** Aplicar os nomes de categorias e subcategorias definidos. Adicionar descrições claras e acessíveis nas páginas de categoria.
5. **Conteúdo Inicial:** Popular o blog com conteúdo inicial representativo das categorias e níveis, aplicando tags relevantes.
6. **Cross-linking Estratégico:** Implementar links internos e a seção "Conteúdo Relacionado" desde o início.
7. **Componente Giscus:** Integrar o sistema de comentários.

**Próximo Passo:** Este documento finaliza o planejamento formal da Arquitetura da Informação. Ele deve agora ser utilizado como o **principal guia** para as fases de **Design de Interface (UI), Prototipagem, Desenvolvimento Front-end e Back-end (serviços Supabase), e Criação/Migração de Conteúdo**. A AI deve ser considerada um documento vivo, sujeito a pequenas revisões e otimizações após o lançamento, com base em dados reais de uso e feedback dos usuários.

## **Simulação 2 Documentação Conclusiva da Arquitetura da Informação (AI) - Blog Florescer Humano (Com Simulação Adicional)**

**Projeto:** Blog-site Daniel Dantas - Módulo "Florescer Humano"

**Status:** Documentação AI Concluída (Fase de Planejamento Final - Pós-Simulação Adicional)

**Versão:** 1.2

**Data:** [Data Atual]

### 1. Introdução e Propósito

Esta documentação final consolida o planejamento da Arquitetura da Informação (AI) para o blog "Florescer Humano". Ela não apenas detalha a estrutura, objetivos e componentes definidos anteriormente, mas também **incorpora os resultados de duas simulações** dos passos de refinamento da AI (Criação de Personas Detalhadas, Mapeamento de Jornadas do Usuário, Validação por Card Sorting e Descrição do Diagrama Visual). A inclusão de uma **segunda simulação com personas distintas** visa garantir que a AI seja robusta, flexível e capaz de atender a uma gama ainda mais ampla de necessidades e perspectivas dentro dos públicos-alvo definidos.

O propósito deste documento é fornecer um guia abrangente e multi-validado (através de simulação) para o design, desenvolvimento e gestão de conteúdo do blog, assegurando uma experiência de usuário otimizada, boa encontrabilidade (SEO) e o cumprimento eficaz da missão do blog.

### 2. Simulação de Personas Detalhadas (Conjunto 2)

Para complementar a análise inicial, simulamos um segundo conjunto de personas:

- **Persona P1 (Alt): Carlos - O Engenheiro em Transição (48 anos, Engenheiro Civil)**
    - **Contexto:** Carlos sente um vazio existencial apesar do sucesso profissional. Questiona o propósito de sua carreira e busca mais significado e conexão emocional em sua vida. Tem dificuldade em articular sentimentos e é cético em relação a soluções rápidas, mas aberto a abordagens filosóficas e psicológicas fundamentadas.
    - **Objetivos no Blog:** (1) Explorar conceitos como "propósito de vida" e "sentido existencial" de uma forma racional, mas humana. (2) Entender como desenvolver maior inteligência emocional e expressividade. (3) Ler histórias ou reflexões de outras pessoas que passaram por transições semelhantes.
    - **Necessidades da AI:** Navegação clara para temas existenciais (Categoria "Autoconhecimento", talvez tags como "Propósito", "Transição de Carreira"). Conteúdo que conecte lógica e emoção. Acesso fácil à categoria "Florescer na Vida" para inspiração. Rótulos que evitem linguagem excessivamente "soft" ou "clínica".
    - **Dores:** Dificuldade em encontrar material que equilibre profundidade filosófica/psicológica com aplicabilidade pessoal sem ser vago. Ceticismo com "autoajuda". Desconforto com abordagens puramente emocionais.
- **Persona P2 (Alt): Beatriz - A Pesquisadora Iniciante (22 anos, Estudante de Psicologia - TCC)**
    - **Contexto:** Beatriz está desenvolvendo seu Trabalho de Conclusão de Curso sobre as críticas e a relevância atual da Psicologia Humanista. Precisa de fontes confiáveis, argumentos bem estruturados e referências acadêmicas sobre a história do movimento e seus principais expoentes.
    - **Objetivos no Blog:** (1) Encontrar artigos que discutam a história da psicologia humanista e seu contexto de surgimento. (2) Acessar análises críticas (favoráveis ou desfavoráveis) sobre as teorias de Rogers, Maslow, etc. (3) Localizar referências bibliográficas (livros, artigos seminais) sobre o tema. (4) Entender como o blog posiciona a relevância atual do humanismo.
    - **Necessidades da AI:** Seção "Materiais" muito bem organizada com bibliografia e links acadêmicos (se possível). Tags como "História da Psicologia", "Críticas ao Humanismo", "Pesquisa Humanista". Artigos com referências claras. Possibilidade de filtrar conteúdo por "Teoria/História". Informações claras sobre os autores do blog (credibilidade).
    - **Dores:** Dificuldade em encontrar fontes secundárias confiáveis e bem referenciadas sobre a história e críticas do humanismo em português. Material online frequentemente focado apenas nos aspectos positivos ou introdutórios.
- **Persona P3 (Alt): Sandra - A Líder de RH Humanista (39 anos, Gerente de Recursos Humanos)**
    - **Contexto:** Sandra acredita que os princípios humanistas podem transformar o ambiente de trabalho. Busca aplicar conceitos como empatia, escuta ativa, desenvolvimento de potencial e autenticidade na gestão de equipes e na cultura organizacional. Não é terapeuta, mas busca ferramentas práticas baseadas na psicologia humanista.
    - **Objetivos no Blog:** (1) Encontrar "traduções" práticas dos conceitos humanistas para o ambiente corporativo. (2) Ler sobre como aplicar a comunicação empática na liderança e resolução de conflitos. (3) Descobrir modelos ou frameworks para promover o crescimento e o bem-estar das equipes inspirados no humanismo. (4) Entender as bases da motivação e engajamento sob essa ótica.
    - **Necessidades da AI:** Tags ou subcategorias como "Humanismo nas Organizações", "Liderança Humanista", "Comunicação no Trabalho". Artigos que diferenciem claramente princípios gerais de técnicas clínicas. Seção "Materiais" com potenciais guias ou checklists para gestores. Conteúdo que conecte o humanismo a temas de RH (engajamento, cultura, desenvolvimento).
    - **Dores:** A maioria do material humanista foca no contexto terapêutico. Dificuldade em encontrar aplicações práticas e estruturadas para o mundo corporativo. Receio de soar "pouco profissional" ao tentar aplicar conceitos vistos como "soft".

*(Este segundo conjunto de personas destaca a necessidade da AI suportar buscas por significado e aplicação prática (Carlos), pesquisa acadêmica e histórica (Beatriz) e tradução de princípios para contextos não-clínicos (Sandra)).*

### 3. Simulação de Mapeamento de Jornadas do Usuário (Conjunto 2)

Novas jornadas simuladas:

- **Jornada 4 (Carlos - P1 Alt): Buscando sentido após os 40.**
    1. **Entrada:** Busca "encontrar propósito depois dos 40" -> Artigo em "Florescer na Vida" ou "Autoconhecimento".
    2. **Consumo:** Lê a reflexão, se identifica. Busca algo mais estruturado.
    3. **Navegação:** Explora categoria "Autoconhecimento". *Dor:* Muitos artigos parecem focados em problemas específicos (ansiedade), não na busca ampla por sentido.
    4. **Busca:** Usa busca "sentido da vida psicologia humanista".
    5. **Exploração:** Encontra artigo mais teórico. *Dor:* A conexão entre teoria e prática pessoal não é óbvia.
    - *Oportunidades AI:* Tag/Subcategoria "Busca por Sentido" ou "Questões Existenciais". Artigos que façam a ponte entre teoria humanista e reflexão pessoal sobre propósito. Seção "Conteúdo Relacionado" que conecte artigos de diferentes categorias (ex: um teórico de Psic. Hum. com uma reflexão de Florescer na Vida).
- **Jornada 5 (Beatriz - P2 Alt): Pesquisando críticas a Maslow.**
    1. **Entrada:** Busca acadêmica ou direta ao blog -> Seção "Materiais" ou busca interna "críticas Maslow".
    2. **Exploração:** Encontra (ou não) referências em "Materiais". Lê artigo que menciona Maslow.
    3. **Navegação:** Procura tags como "Abraham Maslow", "Críticas ao Humanismo", "História da Psicologia". *Dor:* Tags podem não existir ou não serem visíveis/filtráveis facilmente.
    4. **Consumo:** Lê artigo(s) encontrados. *Dor:* Falta de citações diretas ou links para fontes primárias/secundárias.
    - *Oportunidades AI:* Robustecer a seção "Materiais" com bibliografia detalhada. Implementar sistema de tags consistente e filtrável. Adotar padrão de citação nos artigos acadêmicos/teóricos.
- **Jornada 6 (Sandra - P3 Alt): Aplicando escuta empática no trabalho.**
    1. **Entrada:** Busca "escuta ativa humanista trabalho" -> Artigo sobre empatia (talvez em "Relacionamentos" ou "Psic. Hum.").
    2. **Consumo:** Entende o conceito. Busca "como aplicar".
    3. **Navegação:** Procura tags "Comunicação", "Liderança", "Organizações". Explora categorias. *Dor:* Conteúdo muito focado no terapêutico, difícil "traduzir".
    4. **Exploração:** Acessa "Materiais" buscando guias. *Dor:* Sem material específico para contexto organizacional.
    - *Oportunidades AI:* Tags/Subcategorias claras para "Aplicação Organizacional/Não-Clínica". Criar conteúdo específico (ou curar em "Materiais") focado na tradução de princípios humanistas para o trabalho.

*(Estas jornadas adicionais reforçam a necessidade de organização por contexto de aplicação, filtros avançados e uma seção "Materiais" bem curada e segmentada).*

### 4. Simulação de Validação por Card Sorting (Conjunto 2)

Considerando as novas personas, a simulação de Card Sorting Aberto sugere:

- **Descobertas Simuladas:**
    - **Grupos por Aplicação:** Sandra (P3 Alt) provavelmente criaria grupos como "Para o Trabalho", "Desenvolvimento de Equipes", além de grupos temáticos gerais. Carlos (P1 Alt) poderia criar "Questões Profundas" ou "Para Entender a Vida".
    - **Grupos por Formato:** Beatriz (P2 Alt) poderia separar "Teoria Fundamental", "História", "Críticas", "Referências". Usuários em geral podem separar "Artigos" de "Recursos Práticos" (indicando valor das seções "Artigos" vs "Materiais").
    - **Consistência Temática:** As 5 categorias principais provavelmente ainda emergiriam como eixos centrais para a maioria.
    - **Terminologia:** Termos como "Propósito", "Sentido da Vida", "Comunicação Empática", "Liderança Humanista" surgiriam nos rótulos criados pelos participantes.
- **Recomendações Derivadas da Simulação (Complementares):**
    1. **Filtros por Contexto:** Além de categorias e tags temáticas, considerar filtros (ou tags dedicadas) para "Contexto de Aplicação" (ex: Pessoal, Clínico, Educacional, Organizacional).
    2. **Organização de "Materiais":** A seção "Materiais" precisa de sub-organização clara (ex: por formato - E-books, Guias, Bibliografia; ou por público/aplicação - Para Terapeutas, Para Educadores, Para Autoconhecimento).
    3. **Terminologia do Mundo Real:** Incorporar termos como "Propósito", "Liderança", "Comunicação" nas tags e títulos onde apropriado, conectando com a linguagem dos usuários.
    4. **Clareza no Conteúdo:** Usar introduções ou metadados para indicar claramente o público e o contexto de aplicação de cada artigo/material.

*(Esta segunda simulação de Card Sorting reforça a ideia de que, além da organização temática (categorias), os usuários se beneficiam de formas de encontrar conteúdo por contexto de aplicação e formato).*

### 5. Descrição do Diagrama Visual da AI (Visão Consolidada)

O diagrama visual da AI, informado por ambas as simulações, continua representando a mesma estrutura hierárquica fundamental (Homepage -> Seções Navbar -> Categorias/Páginas -> Subcategorias/Artigos). No entanto, as simulações sugerem que o diagrama deveria, idealmente, incluir anotações ou convenções visuais para indicar:

- **Filtros/Tags:** Presença de mecanismos de filtro por tags, nível ou contexto nas páginas de listagem.
- **Organização Interna:** Indicação da sub-organização planejada para seções como "Materiais" e "Mídias".
- **Níveis de Conteúdo:** Possível diferenciação visual (ex: cor, ícone) para indicar conteúdo introdutório vs. avançado ou teórico vs. prático.
- **Conexões Contextuais:** Setas ou linhas pontilhadas indicando fortes conexões entre diferentes seções (ex: um artigo teórico em "Psic. Hum." linkando para um guia prático em "Materiais" ou uma reflexão em "Florescer na Vida").

*(O diagrama, portanto, evolui de um simples mapa de site para um blueprint mais rico que comunica não apenas a estrutura, mas também as principais funcionalidades de navegação e organização secundária).*

### 6. Conclusão e Próximos Passos (Visão Final)

A Arquitetura da Informação para o blog "Florescer Humano", agora informada por **duas rodadas de simulação de refinamento (personas, jornadas, card sorting)**, está robusta, flexível e bem alinhada aos seus objetivos e públicos diversificados. As simulações confirmaram a solidez da estrutura de categorias principal, mas destacaram a **importância crucial de mecanismos de organização e navegação secundários** para atender às necessidades específicas de cada persona.

**Recomendações Finais Consolidadas:**

1. **Estrutura Híbrida:** Manter as 5 categorias principais como espinha dorsal temática. Implementar um **sistema de tags rico e filtrável** para cobrir conceitos específicos, autores, contextos de aplicação (Pessoal, Clínico, Educacional, Organizacional) e níveis de audiência (Iniciante, Estudante, Profissional).
2. **Navegação Aprimorada:** Garantir que os filtros por tags/contexto/nível sejam **visíveis e fáceis de usar** nas páginas de listagem de artigos. Otimizar a função de **busca interna** para reconhecer esses diferentes facets.
3. **Clareza e Contextualização:** Usar **descrições claras** para categorias e seções. Indicar o público e o contexto de aplicação nos artigos/materiais (ex: através de subtítulos, introduções ou metadados visíveis).
4. **Seção "Materiais" Estratégica:** Organizar a seção "Materiais" de forma clara (ex: por tipo de recurso ou por objetivo do usuário) e curá-la com conteúdo relevante para os diferentes públicos e contextos identificados.
5. **Linguagem Acessível e Conectada:** Equilibrar a terminologia técnica necessária (para P2/P3) com uma linguagem acolhedora e acessível (para P1/P3-Alt). Usar **links internos** para conectar teoria, prática, reflexão e recursos.
6. **Segurança (RLS):** Reafirmar a necessidade de implementar políticas RLS rigorosas no Supabase para proteger o acesso via API pública (anon key), especialmente para dados de newsletter e conteúdo não publicado.

**Próximo Passo Definitivo:** Com esta documentação final e multi-validada (via simulação) da Arquitetura da Informação, o projeto está pronto para avançar com confiança para as fases de **Design Visual (UI), Design de Interação (UX), Desenvolvimento Técnico (Front-end e Back-end/Supabase Services) e Produção de Conteúdo**, utilizando este documento como o guia central para a estrutura e organização do blog "Florescer Humano".

## **Simulação 3 Documentação Conclusiva da Arquitetura da Informação (AI) - Blog Florescer Humano (Com Simulação Adicional - Conjunto 3)**

**Projeto:** Blog-site Daniel Dantas - Módulo "Florescer Humano"

**Status:** Documentação AI Concluída (Fase de Planejamento Final - Pós-Simulação Conjunto 3)

**Versão:** 1.3

**Data:** [Data Atual]

### 1. Introdução e Propósito

Esta versão final da documentação da Arquitetura da Informação (AI) para o blog "Florescer Humano" consolida as definições anteriores e incorpora os insights de **três rodadas de simulação** dos passos de refinamento da AI (Personas, Jornadas, Card Sorting, Diagrama Visual). A inclusão deste **terceiro conjunto de personas e cenários simulados** visa garantir a máxima robustez, flexibilidade e adequação da AI às diversas necessidades e perspectivas dos potenciais usuários do blog.

O propósito é fornecer um guia definitivo e exaustivamente validado (via simulação) para as fases subsequentes de design e desenvolvimento, assegurando que a estrutura do blog "Florescer Humano" seja intuitiva, significativa e eficaz em sua missão.

### 2. Simulação de Personas Detalhadas (Conjunto 3)

Introduzimos um terceiro conjunto de personas simuladas:

- **Persona P1 (Conjunto 3): Lucas - O Jovem Questionador (24 anos, Recém-formado em Comunicação)**
    - **Contexto:** Lucas está iniciando sua carreira e sente uma desconexão entre seus valores pessoais e as expectativas do mercado de trabalho. Questiona o que realmente significa sucesso e bem-estar para si. Interessado em filosofia e psicologia, busca abordagens que valorizem a autenticidade e o sentido, mas que também ofereçam alguma orientação prática para lidar com a pressão e a incerteza da vida adulta inicial.
    - **Objetivos no Blog:** (1) Ler reflexões sobre autenticidade, valores e escolhas de vida na perspectiva humanista. (2) Encontrar ferramentas ou insights para lidar com a pressão por performance e a comparação social. (3) Entender como aplicar princípios humanistas nas relações interpessoais (amizades, início de relacionamentos). (4) Conectar-se com uma comunidade ou perspectiva que valide suas inquietações.
    - **Necessidades da AI:** Conteúdo que aborde "Início de Carreira", "Valores Pessoais", "Autenticidade" (tags/subcategorias). Artigos em "Relacionamentos" com foco em amizades e relacionamentos na juventude. Linguagem que conecte com sua geração, evitando tom paternalista. Categoria "Florescer na Vida" com histórias de pessoas reais pode ser impactante.
    - **Dores:** Dificuldade em encontrar conteúdo psicológico que não seja focado apenas em problemas clínicos ou que não pareça "descolado" de sua realidade. Sensação de estar "perdido" entre muitas opções e conselhos contraditórios.
- **Persona P2 (Conjunto 3): Camila - A Terapeuta em Formação (27 anos, Psicóloga Recém-formada, Iniciando Pós em ACP)**
    - **Contexto:** Camila acabou de se formar e está iniciando sua especialização em Abordagem Centrada na Pessoa. Sente a necessidade de consolidar sua base teórica, mas principalmente de encontrar recursos que a ajudem nos primeiros passos da prática clínica supervisionada. Busca entender a "arte" da terapia ACP além dos livros.
    - **Objetivos no Blog:** (1) Encontrar discussões detalhadas sobre as atitudes facilitadoras (empatia, congruência, aceitação) na prática. (2) Ler exemplos (mesmo que hipotéticos ou anonimizados) de como manejar momentos desafiadores na terapia ACP. (3) Acessar sugestões de leituras complementares ou recursos para supervisão. (4) Compreender a aplicação da Focalização como ferramenta auxiliar.
    - **Necessidades da AI:** Conteúdo claramente marcado como "Para Terapeutas em Formação" ou "Prática Clínica Inicial". Subcategoria "Atitudes Facilitadoras" ou "Processo Terapêutico ACP". Exemplos práticos ou vinhetas clínicas (com devidos cuidados éticos). Seção "Materiais" com guias para terapeutas iniciantes ou links para grupos de estudo/supervisão. Tags como "Supervisão", "Desafios Clínicos", "Empatia na Prática".
    - **Dores:** Sentir o "abismo" entre a teoria da faculdade/livros e a complexidade da prática real. Medo de cometer erros ou não ser "empática o suficiente". Falta de materiais práticos focados nos desafios iniciais do terapeuta ACP.
- **Persona P3 (Conjunto 3): Roberto - O Artista Filosófico (55 anos, Artista Plástico e Professor de Arte)**
    - **Contexto:** Roberto sempre se interessou pela condição humana, explorando temas existenciais em sua arte. Vê conexões entre o processo criativo e conceitos humanistas como auto-expressão, experiência subjetiva e a busca por significado. Não busca terapia, mas sim um diálogo intelectual e inspiracional.
    - **Objetivos no Blog:** (1) Ler artigos que explorem a interface entre psicologia humanista, filosofia existencial e artes/criatividade. (2) Encontrar reflexões sobre o papel da experiência estética e da intuição (talvez conectando com a Focalização) no autoconhecimento. (3) Descobrir autores ou pensadores que transitem entre essas áreas. (4) Participar (via comentários) de discussões que conectem psicologia e arte.
    - **Necessidades da AI:** Tags como "Criatividade", "Arte e Psicologia", "Filosofia Existencial", "Fenomenologia". Conteúdo que explore a dimensão estética e simbólica da experiência. Seção "Mídias" com recomendações de livros ou documentários que abordem essa interface. Artigos na categoria "Psicologia Humanista" que façam pontes com a filosofia.
    - **Dores:** Dificuldade em encontrar espaços online que tratem da psicologia humanista de forma menos clínica e mais filosófica ou cultural. Conteúdos que separem rigidamente "ciência" de "arte" ou "espiritualidade".

*(Este terceiro conjunto de personas reforça a necessidade de abordar questões de identidade e carreira (Lucas), os desafios da formação clínica inicial (Camila) e o potencial para diálogos interdisciplinares (Roberto), exigindo flexibilidade na categorização e profundidade nos conteúdos oferecidos).*

### 3. Simulação de Mapeamento de Jornadas do Usuário (Conjunto 3)

Novas jornadas simuladas com base nas personas do Conjunto 3:

- **Jornada 7 (Lucas - P1 Alt 2): Buscando autenticidade no trabalho.**
    1. **Entrada:** Busca "ser autêntico no trabalho psicologia" -> Artigo sobre autenticidade (talvez em "Autoconhecimento").
    2. **Consumo:** Lê o artigo, busca conexão com sua realidade profissional.
    3. **Navegação:** Procura tags "Carreira", "Valores Pessoais", "Trabalho". Explora categorias. *Dor:* Conteúdo pode parecer genérico ou não abordar as pressões específicas do início de carreira.
    4. **Exploração:** Encontra um artigo em "Florescer na Vida" sobre alguém que mudou de carreira. Se conecta.
    5. **Ação:** Deixa um comentário, busca artigos relacionados sobre tomada de decisão.
    - *Oportunidades AI:* Tags específicas para "Início de Carreira", "Valores no Trabalho". Conteúdo que aborde dilemas éticos e de autenticidade no contexto profissional. Conectar artigos de "Autoconhecimento" com histórias de "Florescer na Vida".
- **Jornada 8 (Camila - P2 Alt 2): Procurando exemplos de Congruência na prática.**
    1. **Entrada:** Acesso direto ou via grupo de estudos -> Categoria "Psicologia Humanista".
    2. **Navegação:** Busca subcategoria "Teoria ACP" ou "Prática Clínica Inicial". Usa busca "congruência terapeuta exemplos".
    3. **Consumo:** Lê artigo teórico sobre congruência. *Dor:* Precisa de exemplos de como *se manifesta* ou como *desenvolver*.
    4. **Exploração:** Procura por tags "Vinheta Clínica", "Desafios Terapêuticos", "Desenvolvimento do Terapeuta". Verifica "Materiais".
    - *Oportunidades AI:* Conteúdo específico sobre os desafios de *ser* congruente na prática (não apenas o conceito). Uso de exemplos hipotéticos claros. Seção "Materiais" com "Dicas para Terapeutas Iniciantes". Tags muito específicas sobre habilidades terapêuticas.
- **Jornada 9 (Roberto - P3 Alt 2): Explorando a relação entre Focalização e processo criativo.**
    1. **Entrada:** Busca "Focalização Gendlin criatividade" ou "felt sense arte".
    2. **Consumo:** Lê artigo sobre Focalização. Busca conexões com a arte.
    3. **Navegação:** Procura tags "Criatividade", "Arte e Psicologia", "Fenomenologia", "Corpo e Emoção". Explora categorias "Psicologia Humanista" e "Florescer na Vida".
    4. **Exploração:** Encontra artigo que tangencia o tema. *Dor:* Conexão não é explícita ou aprofundada.
    5. **Ação:** Deixa um comentário perguntando sobre a relação ou buscando referências. Verifica "Mídias".
    - *Oportunidades AI:* Conteúdo que explore explicitamente a interface Humanismo/Artes/Filosofia. Tags interdisciplinares claras. Curadoria da seção "Mídias" com foco nessas interfaces. Incentivar o diálogo nos comentários sobre esses temas.

*(Estas jornadas adicionais reforçam a necessidade de tags muito específicas, conteúdo que aborde contextos particulares (início de carreira, formação clínica, interdisciplinaridade) e uma curadoria cuidadosa das seções "Materiais" e "Mídias").*

### 4. Simulação de Validação por Card Sorting (Conjunto 3)

Considerando as novas personas, a simulação de Card Sorting Aberto sugere:

- **Descobertas Simuladas:**
    - **Grupos por Fase da Vida/Carreira:** Lucas (P1 Alt 2) poderia criar grupos como "Início da Vida Adulta", "Carreira e Propósito". Camila (P2 Alt 2) poderia criar "Formação Clínica", "Teoria vs. Prática".
    - **Grupos Interdisciplinares:** Roberto (P3 Alt 2) certamente criaria grupos como "Psicologia e Arte", "Filosofia da Experiência", "Criatividade e Consciência".
    - **Consistência Temática vs. Aplicação:** A tensão entre agrupar por tema teórico ("ACP") versus por aplicação/contexto ("Para Terapeutas", "Para Educadores", "Para o Trabalho") provavelmente se tornaria mais evidente.
    - **Rótulos:** Surgiriam rótulos como "Autenticidade", "Escolhas", "Desenvolvimento Profissional", "Habilidades Terapêuticas", "Arte e Sentido".
- **Recomendações Derivadas da Simulação (Reforço e Novas):**
    1. **Sistema Híbrido Robusto (Categorias + Tags):** A necessidade de um sistema de tags muito granular e funcional (com filtros visíveis) torna-se **ainda mais crítica** para permitir que os usuários naveguem tanto por tema quanto por contexto, nível ou aplicação.
    2. **Flexibilidade na Descoberta:** A AI deve permitir múltiplos caminhos para encontrar o mesmo conteúdo (via categoria, via tag de conceito, via tag de aplicação, via busca).
    3. **Conteúdo Interdisciplinar:** Planejar e sinalizar claramente (via tags ou seção dedicada) conteúdo que explore as interfaces do humanismo com outras áreas (arte, filosofia, educação, organizações).
    4. **Segmentação Clara:** Usar introduções, metadados ou mesmo seções distintas no site para direcionar conteúdo para fases específicas da vida/carreira (jovens adultos, terapeutas iniciantes).
    5. **Evolução da AI:** Reconhecer que, com a diversidade de interesses, a AI (especialmente as tags e subcategorias) precisará ser continuamente revisada e expandida à medida que o conteúdo cresce.

*(Esta terceira simulação enfatiza que uma AI bem-sucedida para este blog precisa ir além da simples categorização temática, incorporando dimensões de contexto, nível, aplicação e interdisciplinaridade de forma explícita e navegável).*

### 5. Descrição do Diagrama Visual da AI (Visão Final Enriquecida)

O diagrama visual da AI, após três rodadas de simulação, deve ser concebido não apenas como um mapa hierárquico, mas como um **mapa de ecossistema de conteúdo**. Ele deve visualizar:

- A estrutura hierárquica principal (Homepage -> Seções -> Categorias -> Artigos).
- A **rede de conexões** criada pelas **tags**, mostrando como um artigo pode pertencer a uma categoria, mas se conectar (via tags) a múltiplos outros conceitos, contextos ou níveis.
- A centralidade de funcionalidades como **Busca** e **Filtros** como mecanismos alternativos e essenciais de navegação.
- A importância das seções **"Materiais"** e **"Mídias"** como hubs de recursos complementares, com sua própria estrutura interna indicada.
- As diferentes **portas de entrada** para o conteúdo (Homepage, Categorias, Busca, Links Externos).
- Anotações destacando a necessidade de **clareza de rótulos** e **segmentação de conteúdo** para diferentes personas/níveis.

*(O diagrama final torna-se uma ferramenta mais estratégica, ilustrando a riqueza e a interconectividade planejadas para o conteúdo do blog).*

### 6. Conclusão e Próximos Passos (Visão Definitiva)

A Arquitetura da Informação para o blog "Florescer Humano", agora refinada através de **três simulações detalhadas**, está pronta para guiar o desenvolvimento. As múltiplas perspectivas de personas e jornadas confirmaram a estrutura base, mas, crucialmente, destacaram a necessidade de **flexibilidade, granularidade e clareza contextual** para atender à diversidade de interesses e necessidades dentro dos públicos definidos.

**Recomendações Finais Definitivas:**

1. **Implementar Sistema Híbrido:** Usar as 5 categorias como base temática e um **sistema de tags abrangente e funcional** (com filtros visíveis na interface) como principal ferramenta para navegação por conceito, contexto, aplicação e nível.
2. **Priorizar Filtros e Busca:** Investir em funcionalidades de filtro e busca interna que permitam aos usuários refinar suas pesquisas com base em múltiplos critérios (categoria, tag, palavra-chave).
3. **Segmentar e Sinalizar Conteúdo:** Utilizar introduções, subtítulos, metadados visíveis e tags para indicar claramente o público-alvo, o nível de profundidade e o contexto de aplicação de cada peça de conteúdo.
4. **Curadoria Estratégica:** Desenvolver as seções "Materiais" e "Mídias" com sub-organização clara e conteúdo curado para atender às necessidades específicas identificadas (referências acadêmicas, guias práticos, recursos para formação, diálogos interdisciplinares).
5. **Foco na Conectividade:** Enfatizar a criação de links internos relevantes para guiar os usuários entre teoria, prática, reflexão e recursos adicionais, criando jornadas de aprendizado coesas.
6. **Manter RLS Rigorosa:** Implementar e testar exaustivamente as políticas RLS no Supabase para garantir a segurança dos dados e a correta exposição do conteúdo público via API.

**Próximo Passo Imediato:** Com esta documentação da AI finalizada e validada por múltiplas simulações, o projeto pode prosseguir com segurança para as fases de **Design de UI/UX, Desenvolvimento Técnico e Criação de Conteúdo Inicial**, usando este documento como o guia mestre para a estrutura informacional e organizacional do blog "Florescer Humano". A natureza dinâmica do conteúdo exigirá revisões periódicas da AI pós-lançamento.

# Design System do blogflorescerhumano

Excelente! Com acesso ao package.json, tsconfig.json, next.config.mjs, globals.css, à estrutura de pastas e à URL do site (https://psicologodanieldantas.com/), consigo fazer uma análise bem mais profunda e gerar uma documentação detalhada sobre os padrões visuais e de componentes utilizados, que servirá como base para o Design System do blogflorescerhumano.

---

## **Documentação: Análise de Padrões Visuais e Componentes - Site psicologodanieldantas.com**

**Projeto:** Blog-site Daniel Dantas - Análise do Site Principal

**Objetivo:** Documentar os padrões visuais e de componentes do site psicologodanieldantas.com para informar a criação de um Design System visualmente coeso, mas tecnicamente independente, para o módulo blogflorescerhumano.

**Data:** [Data Atual]

### Introdução

Esta documentação detalha a análise dos elementos visuais, componentes de interface (UI) e estrutura técnica observados no site psicologodanieldantas.com e em seu código fonte fornecido. O objetivo é extrair os fundamentos do seu "Design System implícito" para guiar a construção de um sistema coeso para o blog "Florescer Humano".

**Tecnologias Chave Identificadas:**

- **Framework:** Next.js (v15+) com App Router
- **Linguagem:** TypeScript
- **Estilização Principal:** Tailwind CSS (v3.4+)
- **Componentes UI Primitives:** Radix UI (extensivamente utilizado)
- **Metodologia de Componentes (Provável):** Shadcn/ui (pela estrutura components/ui/, uso de Radix + Tailwind + clsx + tailwind-merge via lib/utils.ts)
- **Iconografia:** Lucide React
- **Outras bibliotecas UI relevantes:** next-themes (theming), sonner (toasts), recharts (gráficos), embla-carousel-react (carrosséis), etc.

### 1. Fundamentos Visuais (Design Tokens)

Os tokens de design são as "átomos" visuais que garantem consistência. Eles são primariamente definidos via variáveis CSS em globals.css (o segundo snippet fornecido, que corresponde visualmente ao site) e provavelmente referenciados/estendidos na configuração do Tailwind (tailwind.config.ts - *conteúdo não fornecido, mas inferido*).

### 1.1. Cores

- **Sistema:** Utiliza variáveis CSS customizadas para definir a paleta, com suporte a tema claro (padrão) e escuro (.dark).
- **Formato:** As cores são definidas em HSL (Hue, Saturation, Lightness), ex: 36 33% 97%.
- **Paleta Principal (Light Theme - Inferido do globals.css e site):**
    - -background: hsl(36 33% 97%) (Um bege/off-white muito claro)
    - -foreground: hsl(30 45% 23%) (Um marrom escuro, quase preto)
    - -primary: hsl(30 45% 23%) (Marrom escuro - usado para texto/elementos primários)
    - -primary-foreground: hsl(36 33% 97%) (Bege/off-white - para texto sobre fundo primário)
    - -secondary: hsl(36 33% 97%) (Bege/off-white - usado como fundo alternativo?)
    - -secondary-foreground: hsl(30 45% 23%) (Marrom escuro)
    - -muted: hsl(36 33% 97%)
    - -muted-foreground: hsl(30 30% 36%) (Marrom acinzentado/médio)
    - -accent: hsl(36 33% 97%)
    - -accent-foreground: hsl(30 45% 23%)
    - -border: hsl(30 30% 76%) (Um bege/marrom claro para bordas)
    - -input: hsl(30 30% 76%) (Mesma cor da borda para fundo/borda de inputs)
    - -ring: hsl(30 45% 23%) (Marrom escuro para anel de foco)
    - -destructive: Cores padrão para estados destrutivos (vermelho).
- **Tema Escuro:** Variáveis correspondentes são definidas sob a classe .dark.
- **Uso:** As classes utilitárias do Tailwind (ex: bg-background, text-primary, border-border) provavelmente usam essas variáveis CSS.

### 1.2. Tipografia

- **Fonte Principal:** Kaisei Opti (Serifada, elegante) - Carregada via @font-face (referenciando Google Fonts em globals.css).
- **Fonte Fallback:** Arial, Helvetica, sans-serif.
- **Hierarquia (Tamanhos, Pesos, Alturas de Linha):** Gerenciada primariamente pelas classes utilitárias do Tailwind (ex: text-lg, font-semibold, leading-relaxed). A configuração específica estaria em tailwind.config.ts na seção theme.fontSize ou theme.fontWeight, etc.
- **Cor:** Usa as variáveis de cor (--foreground, --primary, --secondary-foreground, etc.).

### 1.3. Espaçamento

- **Sistema:** Gerenciado pela escala de espaçamento padrão ou customizada do Tailwind (ex: p-4, m-8, space-y-2). A configuração estaria em tailwind.config.ts na seção theme.spacing.
- **Consistência:** O uso de utilitários Tailwind promove o uso consistente de múltiplos de uma unidade base (geralmente 4px).

### 1.4. Bordas e Raios (Radius)

- **Cor da Borda:** Definida pela variável --border (hsl(30 30% 76%)). Usada com classes como border.
- **Raio (Radius):** Uma variável --radius: 0.5rem; é definida. Isso é provavelmente usado para configurar os utilitários de borderRadius do Tailwind (ex: rounded-lg, rounded-md). A configuração exata estaria em tailwind.config.ts (theme.borderRadius).

### 1.5. Sombras

- Não definidas explicitamente como variáveis CSS em globals.css. Provavelmente utilizam as classes de sombra padrão do Tailwind (shadow-sm, shadow-md, shadow-lg, etc.) ou são customizadas em tailwind.config.ts (theme.boxShadow).

### 1.6. Iconografia

- **Biblioteca:** lucide-react é utilizada, oferecendo um conjunto consistente de ícones SVG.

### 2. Componentes de UI

A estrutura components/ui/ e as dependências @radix-ui/* indicam fortemente o uso da abordagem Shadcn/ui: componentes reutilizáveis construídos sobre primitivas acessíveis do Radix UI e estilizados com Tailwind CSS.

### 2.1. Abordagem Geral

- **Construção:** Componentes React (provavelmente funcionais com TypeScript).
- **Estilização:** Tailwind CSS aplicado diretamente via className.
- **Composição de Classes:** Uso da função cn (de lib/utils.ts, combinando clsx e tailwind-merge) para aplicar classes condicionais e evitar conflitos de utilitários Tailwind.
- **Variantes:** Uso de class-variance-authority (cva) para definir variantes de estilo e tamanho (ex: buttonVariants em button.tsx).
- **Acessibilidade:** Herdada em grande parte das primitivas do Radix UI (gerenciamento de estado, interações de teclado, atributos ARIA).

### 2.2. Listagem de Componentes Identificados (components/ui/)

O diretório ui contém uma biblioteca abrangente, incluindo (mas não limitado a):

- Accordion
- Alert, AlertDialog
- Avatar
- Badge
- Breadcrumb
- Button
- Calendar
- Card
- Carousel
- Checkbox
- Collapsible
- Command (para menus de comando/busca)
- Dialog (Modais)
- Drawer
- DropdownMenu
- Form (integração com react-hook-form)
- Input, InputOTP, Textarea
- Label
- Menubar
- NavigationMenu
- Pagination
- Popover
- RadioGroup
- Select
- Separator
- Sheet (Side panels)
- Skeleton (Loading states)
- Slider
- Switch
- Table
- Tabs
- Toast (via Sonner)
- Toggle, ToggleGroup
- Tooltip

### 2.3. Análise de Componente Exemplo: Button (Inferido)

- **Base:** Provavelmente usa <Slot> do Radix para permitir composição (ex: botão como link).
- **Estilo:** Define buttonVariants usando cva.
- **Variantes (Estilo):** default (provavelmente fundo --primary, texto --primary-foreground), destructive, outline (borda --border), secondary (fundo --secondary?), ghost (sem fundo/borda, hover sutil), link (aparência de link).
- **Variantes (Tamanho):** default, sm, lg, icon (para botões apenas com ícone).
- **Props:** Aceita props padrão de botão HTML, variant, size, e className para overrides.
- **Uso:** <Button variant="outline" size="sm">Texto</Button>

### 3. Layout e Responsividade

- **Abordagem:** Utiliza as classes responsivas do Tailwind CSS (prefixos sm:, md:, lg:, xl:, 2xl:) para adaptar layout, espaçamento, tipografia, etc., a diferentes tamanhos de tela. Os breakpoints estariam definidos em tailwind.config.ts.
- **Estrutura:** O layout principal (app/layout.tsx) define a estrutura geral. Componentes específicos de layout podem existir (ex: Container não listado, mas comum) ou o layout pode ser construído diretamente com utilitários Tailwind (Flexbox, Grid).
- **Considerações Mobile:** Há atenção a alvos de toque (min-height: 44px) e prevenção de zoom em inputs (font-size: 16px) em globals.css.

### 4. Tom Visual e Sensação

- **Paleta:** As cores (bege claro, marrom escuro, marrom médio) transmitem uma sensação **calma, acolhedora, profissional e talvez um pouco clássica/natural**. Evita cores muito vibrantes ou "tech".
- **Tipografia:** O uso da serifada Kaisei Opti reforça a sensação de **elegância, confiabilidade e talvez um toque mais reflexivo/humanista**.
- **Geral:** O design parece buscar um equilíbrio entre profissionalismo clínico e uma sensação acolhedora/humana, alinhada à área de atuação do psicólogo.

### 5. Diretrizes Gerais para o Design System do blogflorescerhumano

Com base nesta análise, as seguintes diretrizes são recomendadas para o DS do blog:

1. **Manter Coesão Visual:** O DS do blog deve **adotar os mesmos tokens visuais** (cores, tipografia, raios, ícones) do site principal para garantir uma experiência integrada. As variáveis CSS de globals.css e as configurações inferidas de tailwind.config.ts devem ser replicadas ou referenciadas no ambiente do blog.
2. **Implementação Independente:** Os **componentes de UI do blog devem ser implementações separadas**, residindo dentro de src/app/blogflorescerhumano/components/ui/. Eles devem usar o sufixo Blog (ex: ButtonBlog.tsx).
3. **Replicar Estilo Visual:** Os componentes do blog devem **imitar a aparência e o comportamento** dos componentes correspondentes do site principal. Se o site usa Radix + Tailwind (Shadcn), essa é uma boa abordagem a ser seguida também no blog para facilitar a replicação visual e aproveitar a acessibilidade, mas não é estritamente obrigatório (poderia ser apenas Tailwind puro se a complexidade for menor). A função cn de lib/utils.ts deve ser reutilizada.
4. **Consistência de Layout:** Padrões de layout responsivo e estruturação de página observados no site principal devem ser considerados ao criar os templates (src/app/blogflorescerhumano/templates/) do blog.
5. **Independência Técnica:** Apesar da coesão visual, o código do DS do blog (componentes, estilos específicos) deve permanecer isolado dentro do módulo blogflorescerhumano, garantindo manutenibilidade separada.

### 6. Conclusão da Análise

O site psicologodanieldantas.com utiliza um sistema visual bem definido, provavelmente baseado na metodologia Shadcn/ui, que combina a flexibilidade do Tailwind CSS com as primitivas acessíveis do Radix UI. Os tokens visuais (cores HSL, tipografia serifada) criam uma identidade calma e profissional. Esta análise fornece uma base sólida para desenvolver um Design System para o blogflorescerhumano que seja visualmente harmonioso com o site principal, ao mesmo tempo que mantém sua independência técnica e organizacional. O próximo passo é codificar os tokens e componentes base para o blog, seguindo estas diretrizes.

---

## **Documentação do Design System - Blog Florescer Humano**

**Projeto:** Blog-site Daniel Dantas - Módulo "Florescer Humano"

**Status:** Definição Inicial

IA: Okay, compreendido. Com base na análise detalhada do site psicologodanieldantas.com, nas definições da Arquitetura da Informação do blog e nos requisitos específicos que listamos, vamos construir a documentação completa para o Design System (DS) do módulo blogflorescerhumano.

Esta documentação servirá como guia para garantir que o blog mantenha uma identidade visual coesa com o site principal, ao mesmo tempo que estabelece seus próprios componentes e padrões técnicos independentes.

**Versão:** 1.0

**Data:** [Data Atual]

### 1. Introdução

### 1.1. Propósito

Esta documentação define o Design System (DS) para o módulo do blog "Florescer Humano", parte integrante do site psicologodanieldantas.com. O objetivo principal é estabelecer um conjunto de **diretrizes visuais, componentes de interface (UI) reutilizáveis e padrões de codificação** para garantir:

- **Coesão Visual:** Manter uma aparência e sensação consistentes com o site principal psicologodanieldantas.com, criando uma experiência de usuário fluida e integrada.
- **Consistência Interna:** Assegurar que todas as páginas e elementos dentro do blog sigam os mesmos padrões visuais e interativos.
- **Eficiência no Desenvolvimento:** Fornecer componentes e estilos prontos para uso, acelerando o desenvolvimento e facilitando a manutenção.
- **Usabilidade e Acessibilidade:** Incorporar as melhores práticas de UX e acessibilidade desde a base do sistema.
- **Manutenibilidade:** Promover código limpo, organizado e reutilizável através de componentes padronizados.
- **Independência Técnica:** Apesar da coesão visual, o código do DS do blog (componentes, estilos) será implementado e mantido de forma independente dentro da estrutura de pastas src/app/blogflorescerhumano/.

### 1.2. Princípios Norteadores

O DS do "Florescer Humano" é guiado pelos seguintes princípios:

- **Humanista e Acolhedor:** O design deve refletir os valores do blog (calma, profundidade, crescimento, autenticidade), utilizando a paleta de cores e tipografia definidas para criar um ambiente convidativo e seguro.
- **Claro e Intuitivo:** A interface deve ser fácil de entender e navegar, priorizando a clareza da informação e a simplicidade da interação, especialmente para o público principal (P1 - Busca por Autoconhecimento).
- **Acessível:** O design e a implementação devem seguir as diretrizes de acessibilidade (WCAG 2.1 AA) para garantir que o conteúdo seja utilizável por todos.
- **Consistente:** Os mesmos padrões visuais e interativos devem ser aplicados em todo o módulo do blog.
- **Modular e Reutilizável:** Componentes devem ser projetados para serem independentes e facilmente reutilizáveis em diferentes contextos dentro do blog.
- **Coeso (com o Site Principal):** As escolhas visuais (cores, fontes, espaçamentos gerais) devem espelhar as do site psicologodanieldantas.com.

### 1.3. Base de Referência

Este DS é informado pela análise detalhada dos padrões visuais e estrutura técnica do site principal psicologodanieldantas.com, que utiliza uma combinação de Tailwind CSS, primitivas Radix UI (provavelmente via metodologia Shadcn/ui) e tipografia específica (Kaisei Opti).

### 2. Fundamentos Visuais (Design Tokens)

Os Design Tokens são os valores fundamentais e indivisíveis que definem a identidade visual do blog. Eles **devem espelhar diretamente** os tokens utilizados no site principal psicologodanieldantas.com para garantir a coesão. A implementação recomendada é através de variáveis CSS globais (definidas em src/app/blogflorescerhumano/styles/blog-globals.css ou similar e/ou configuradas no tailwind.config.ts do projeto).

### 2.1. Cores

- **Sistema:** Utilização de variáveis CSS customizadas em formato HSL, com suporte a tema claro (padrão) e escuro (.dark).
- **Paleta Principal (Baseada na análise do site principal):**
    - **Light Theme:**
        - -background: hsl(36 33% 97%)
        - -foreground: hsl(30 45% 23%)
        - -card: hsl(36 33% 97%)
        - -card-foreground: hsl(30 45% 23%)
        - -popover: hsl(36 33% 97%)
        - -popover-foreground: hsl(30 45% 23%)
        - -primary: hsl(30 45% 23%)
        - -primary-foreground: hsl(36 33% 97%)
        - -secondary: hsl(36 33% 97%)
        - -secondary-foreground: hsl(30 45% 23%)
        - -muted: hsl(36 33% 97%)
        - -muted-foreground: hsl(30 30% 36%)
        - -accent: hsl(36 33% 97%)
        - -accent-foreground: hsl(30 45% 23%)
        - -destructive: hsl(0 84.2% 60.2%)
        - -destructive-foreground: hsl(36 33% 97%)
        - -border: hsl(30 30% 76%)
        - -input: hsl(30 30% 76%)
        - -ring: hsl(30 45% 23%)
    - **Dark Theme (.dark):**
        - -background: hsl(30 45% 23%)
        - -foreground: hsl(36 33% 97%)
        - -card: hsl(30 45% 23%)
        - -card-foreground: hsl(36 33% 97%)
        - -popover: hsl(30 45% 23%)
        - -popover-foreground: hsl(36 33% 97%)
        - -primary: hsl(36 33% 97%)
        - -primary-foreground: hsl(30 45% 23%)
        - -secondary: hsl(30 30% 36%)
        - -secondary-foreground: hsl(36 33% 97%)
        - -muted: hsl(30 30% 36%)
        - -muted-foreground: hsl(36 20% 80%)
        - -accent: hsl(30 30% 36%)
        - -accent-foreground: hsl(36 33% 97%)
        - -destructive: hsl(0 62.8% 30.6%)
        - -destructive-foreground: hsl(36 33% 97%)
        - -border: hsl(30 30% 36%)
        - -input: hsl(30 30% 36%)
        - -ring: hsl(36 33% 97%)
- **Uso:** Devem ser consumidas via classes utilitárias do Tailwind CSS (ex: bg-background, text-primary-foreground, border-border) configuradas para usar essas variáveis.
- **Acessibilidade:** Verificar o contraste entre cores de texto e fundo para atender aos critérios WCAG AA.

### 2.2. Tipografia

- **Fonte Principal:** Kaisei Opti (Serifada) - Deve ser carregada no projeto (ex: via Google Fonts ou localmente).
- **Fonte Fallback:** Arial, Helvetica, sans-serif.
- **Hierarquia:**
    - Gerenciada via classes utilitárias do Tailwind CSS (text-sm, text-base, text-lg, text-xl, text-2xl, text-3xl, text-4xl, etc.).
    - **A escala de tamanhos (fontSize), pesos (fontWeight) e alturas de linha (lineHeight) deve espelhar a configuração utilizada no site principal.** (Verificar tailwind.config.ts do site principal ou inspecionar os estilos computados).
    - Exemplo (a ser validado/ajustado):
        - Corpo de Texto: text-base font-normal leading-relaxed text-foreground
        - Títulos H1: text-4xl font-bold text-primary
        - Títulos H2: text-3xl font-semibold text-primary
        - Títulos H3: text-2xl font-semibold text-primary
        - Links: text-primary hover:underline
- **Legibilidade:** Garantir bom contraste e tamanho adequado para leitura confortável em diferentes dispositivos.

### 2.3. Espaçamento

- **Sistema:** Utilizar a escala de espaçamento do Tailwind CSS (p-1, m-2, space-y-4, etc.).
- **Consistência:** **A escala (theme.spacing no tailwind.config.ts) deve ser a mesma do site principal** para manter a harmonia visual. Geralmente baseada em múltiplos de 0.25rem (4px).
- **Uso:** Aplicar consistentemente para margens, paddings, espaçamento entre elementos e em layouts de grid/flex.

### 2.4. Bordas e Raios (Radius)

- **Cor da Borda Padrão:** Utilizar a variável --border (via classe border-border).
- **Espessura da Borda:** Padrão Tailwind (border, border-2) ou customizada se necessário.
- **Raio (Radius):** Utilizar a variável --radius (valor 0.5rem identificado no site principal) para configurar as classes rounded-* do Tailwind. Aplicar consistentemente em botões, cards, inputs, etc.

### 2.5. Sombras

- **Estilo:** Replicar os estilos de sombra (box-shadow) utilizados no site principal. Verificar se são usadas as classes padrão do Tailwind (shadow-sm, shadow-md, shadow-lg) ou se há customizações no tailwind.config.ts.
- **Uso:** Aplicar sutilmente para dar profundidade a elementos como Cards, Popovers, Dropdowns.

### 3. Componentes de UI (*Blog)

Componentes são os blocos de construção reutilizáveis da interface do blog. Devem residir em src/app/blogflorescerhumano/components/ui/ e usar o sufixo Blog.

### 3.1. Princípios Gerais de Implementação

- **Tecnologia:** Recomendado usar **React com TypeScript**. Para a base dos componentes (primitivas), recomenda-se usar **Radix UI** para garantir acessibilidade e comportamento robusto. Para estilização, usar **Tailwind CSS** aplicado via className.
- **Estilo e Variantes:** Utilizar class-variance-authority (CVA) para definir variantes de estilo e tamanho. Usar a função cn (de lib/utils.ts) para composição de classes.
- **Visual:** Devem **replicar fielmente a aparência** (cores, tipografia, espaçamento, bordas, raios, sombras) dos componentes equivalentes no site principal.
- **API (Props):** Definir interfaces claras com TypeScript para as props, permitindo configuração e mantendo a consistência.
- **Acessibilidade:** Implementar seguindo as melhores práticas (semântica HTML, ARIA, navegação por teclado, estados de foco).
- **Independência:** Componentes devem ser auto-contidos e não depender excessivamente do contexto onde são usados.

### 3.2. Componentes Essenciais (Lista Inicial)

- **ButtonBlog:** Para ações e links.
    - *Variantes:* default (primária), secondary, outline, ghost, link, destructive.
    - *Tamanhos:* default, sm, lg, icon.
    - *Estados:* Hover, focus-visible, disabled, active.
- **CardBlog:** Para exibir resumos de artigos em listagens.
    - *Estrutura:* Imagem de capa, título, resumo, metadados (categoria/autor/data), link "Leia mais".
    - *Estilo:* Usar tokens de card, borda, raio, sombra.
- **InputBlog, TextareaBlog, LabelBlog:** Para formulários (Contato, Newsletter).
    - *Estilo:* Usar tokens de input, border, ring (foco).
    - *Acessibilidade:* Associação correta label-input.
- **FormBlog:** (Wrapper, se usar react-hook-form como no site principal).
- **TagBlog / BadgeBlog:** Para exibir tags de artigos ou categorias.
    - *Estilo:* Pequeno, com cantos arredondados, cores discretas (ex: bg-muted, text-muted-foreground ou variações de accent).
- **ArticleMetadataBlog:** Componente para exibir consistentemente autor, data, categoria(s) de um artigo.
- **AuthorInfoBlog:** Bloco para exibir foto (usando foto_arquivo), nome e biografia (opcional) do autor.
- **SeparatorBlog:** Linha horizontal para divisão visual.
- **PaginationBlog:** Para navegação em listas longas de artigos.
- **SearchBarBlog:** Campo de busca com ícone.
- **GiscusComments:** Componente específico para carregar e exibir a seção de comentários do Giscus (marcado como 'use client').
- **NewsletterFormBlog:** Formulário dedicado para inscrição na newsletter (marcado como 'use client').
- **ContactFormBlog:** Formulário dedicado para contato (marcado como 'use client').
- **SkeletonBlog:** Para indicar estados de carregamento de forma visualmente agradável.

### 3.3. Diretrizes Específicas (Exemplo: CardBlog)

- **Propósito:** Representar visualmente um resumo de artigo em uma lista ou grid.
- **Estrutura:**
    - Container principal (<article> ou <div>) com estilos de Card (fundo var(--card), border, rounded-lg, shadow-md - replicar site principal).
    - Link envolvendo o card ou partes dele, apontando para o artigo completo.
    - Imagem de Capa (next/image usando imagem_capa_arquivo) no topo ou lateral, com alt text descritivo.
    - Área de Conteúdo:
        - Título (<h3> ou <h2> dependendo do contexto) com estilo tipográfico apropriado (text-xl font-semibold text-primary?).
        - Resumo (<p>) com estilo de corpo de texto, talvez com limite de linhas (line-clamp).
        - Metadados (ArticleMetadataBlog) - autor, data, categoria(s) com estilo text-sm text-muted-foreground.
- **Responsividade:** Ajustar layout (imagem/texto lado a lado ou empilhado) e tamanho de fonte/espaçamento em diferentes breakpoints.
- **Interação:** Efeito sutil de hover (ex: leve aumento da sombra, mudança na borda). Estado :focus-visible claro no link.

*(Nota: Cada componente essencial listado acima deve ter diretrizes detalhadas similares desenvolvidas durante a implementação).*

### 4. Layout e Responsividade

- **Princípios:** O layout do blog deve ser fluido e adaptar-se a todas as larguras de tela (mobile, tablet, desktop). Usar abordagem **mobile-first** é recomendado.
- **Breakpoints:** Utilizar os breakpoints definidos no tailwind.config.ts (que devem espelhar os do site principal). Padrões comuns: sm, md, lg, xl, 2xl.
- **Grid System:** Utilizar o sistema de Grid ou Flexbox do Tailwind para estruturar o conteúdo principal e barras laterais (se houver).
- **Containers:** Definir uma largura máxima (max-w-) para o conteúdo principal em telas grandes para melhorar a legibilidade, consistente com o site principal.
- **Templates:** Implementar componentes de template (ex: ArticleTemplateBlog.tsx, CategoryTemplateBlog.tsx em src/app/blogflorescerhumano/templates/) que definem a estrutura geral da página (header, área de conteúdo principal, footer) e aplicam os padrões de layout responsivo.

### 5. Acessibilidade (Diretrizes Essenciais - WCAG 2.1 AA)

A acessibilidade deve ser considerada em todas as etapas.

- **HTML Semântico:** Utilizar tags HTML apropriadas (<nav>, <main>, <article>, <aside>, <h1>-<h6>, <button>, <label>, etc.) para dar estrutura e significado ao conteúdo.
- **Navegação por Teclado:** Todos os elementos interativos (links, botões, inputs, etc.) devem ser acessíveis e operáveis usando apenas o teclado. A ordem de foco deve ser lógica e previsível. O estilo :focus-visible (outline marrom var(--ring)) deve ser claro e consistente.
- **Contraste de Cores:** Verificar o contraste entre texto e fundo, e entre elementos de UI importantes, usando ferramentas online (ex: WebAIM Contrast Checker), garantindo a conformidade com os ratios WCAG AA (4.5:1 para texto normal, 3:1 para texto grande).
- **Texto Alternativo (Alt Text):** Todas as imagens que transmitem informação devem ter um atributo alt descritivo. Imagens puramente decorativas devem ter alt="".
- **ARIA:** Usar atributos ARIA (Accessible Rich Internet Applications) quando a semântica HTML não for suficiente para descrever o papel, estado ou propriedade de um componente customizado (Radix UI ajuda muito nisso).
- **Formulários:** Associar <label> explicitamente aos seus controles (<input>, <textarea>, <select>) usando htmlFor. Fornecer mensagens de erro claras e acessíveis.
- **Legibilidade:** Utilizar tamanhos de fonte e alturas de linha adequados. Evitar texto justificado.

### 6. Iconografia

- **Biblioteca Padrão:** Utilizar lucide-react para consistência com o site principal.
- **Uso:** Ícones devem ser usados para reforçar visualmente ações ou informações, não como substitutos únicos para texto (exceto em botões de ícone bem definidos).
- **Estilo:** Ícones devem herdar a cor do texto (currentColor) ou usar cores de texto do Tailwind. O tamanho deve ser consistente (ex: h-4 w-4, h-5 w-5).
- **Acessibilidade:** Se um ícone for puramente decorativo, adicionar aria-hidden="true". Se ele transmitir significado sem texto visível (ex: botão de fechar só com 'X'), fornecer texto alternativo para leitores de tela (ex: <span className="sr-only">Fechar</span>).

### 7. Implementação Técnica (Guia para Desenvolvedores)

- **Localização:** Todo código específico do DS do blog reside em src/app/blogflorescerhumano/.
- **Componentes:** Criar componentes em .../components/ui/ com o sufixo Blog. Usar Radix + Tailwind + CVA + cn (recomendado).
- **Tokens:** Definir/replicar variáveis CSS em .../styles/blog-globals.css ou configurar no Tailwind. Consumir via classes Tailwind.
- **Estilos:** Usar Tailwind className. Para estilos complexos ou específicos, usar CSS Modules (*.module.css) na pasta do componente.
- **Templates:** Usar componentes de template em .../templates/ para estruturar as páginas.
- **Clean Code:** Seguir princípios de código limpo (nomes descritivos, funções pequenas, DRY - Don't Repeat Yourself).

### 8. Conclusão

Este Design System fornece as bases visuais e técnicas para a construção do blog "Florescer Humano". Ao aderir a estas diretrizes, garantimos que o blog será visualmente coeso com o site psicologodanieldantas.com, consistente internamente, acessível, fácil de usar e eficiente de desenvolver e manter. Ele é um documento vivo e deve ser consultado e potencialmente atualizado durante todo o ciclo de vida do projeto.

# **Documentação: Arquitetura de Pastas e Arquivos - Blog Florescer Humano**

**Projeto:** Blog-site Daniel Dantas - Módulo "Florescer Humano"

**Status:** Definição Concluída

**Versão:** 1.0

**Data:** [Data Atual]

### 1. Introdução e Propósito

Esta documentação detalha a estrutura de pastas e arquivos adotada para o desenvolvimento do módulo do blog "Florescer Humano" dentro do projeto Next.js do site psicologodanieldantas.com.

O **propósito** desta arquitetura é fornecer uma organização:

- **Modular e Isolada:** Manter o código do blog (componentes, lógica, estilos) separado do site principal, facilitando o desenvolvimento, teste e manutenção independentes.
- **Clara e Intuitiva:** Utilizar convenções de nomenclatura e organização que tornem fácil para qualquer desenvolvedor (presente ou futuro) localizar e entender o código.
- **Alinhada com Next.js App Router:** Tirar proveito das convenções do App Router do Next.js para roteamento baseado em arquivos e funcionalidades como Layouts, Loading e Error UIs.
- **Orientada a Funcionalidades/Domínio (Parcialmente):** Agrupar arquivos relacionados a uma funcionalidade ou domínio específico (ex: Artigos, Categorias, Supabase Services) dentro de subpastas dedicadas.
- **Facilitadora de Código Limpo:** Promover a separação de responsabilidades (componentes UI, lógica de dados, serviços, utilitários) e a reutilização de código.
- **Escalável:** Permitir que o blog cresça em conteúdo e funcionalidades sem que a estrutura se torne caótica.
- **Consistente com a AI:** Refletir a Arquitetura da Informação definida (categorias, páginas, fluxos) na organização dos arquivos e rotas.
- **Otimizada para UX e SEO:** Suportar URLs semânticas e uma estrutura que contribui para uma boa experiência do usuário e indexação pelos motores de busca.

### 2. Visão Geral da Estrutura de Alto Nível

O projeto utiliza Next.js com o App Router. A estrutura principal é:

      `.
├── public/             # Assets estáticos (imagens, fontes, etc.)
├── src/
│   ├── app/            # Diretório central do App Router (rotas e UIs)
│   ├── components/     # Componentes React REUTILIZÁVEIS EM TODO O SITE
│   ├── lib/            # Funções utilitárias e clientes GLOBAIS
│   └── types/          # Definições TypeScript GLOBAIS
├── .env.local          # Variáveis de ambiente
├── next.config.mjs     # Configuração do Next.js
├── tailwind.config.ts  # Configuração do Tailwind CSS
├── tsconfig.json       # Configuração do TypeScript
└── package.json        # Dependências e scripts`

- **public/:** Contém assets acessíveis publicamente via URL. Crucial para as imagens do blog que não estarão no Supabase.
- **src/app/:** O coração do roteamento e da UI. Cada pasta aqui (exceto as iniciadas com _) define um segmento de rota.
- **src/components/:** Armazena componentes React que são compartilhados entre o site principal e o módulo do blog (ex: Navbar principal, Footer principal).
- **src/lib/:** Funções utilitárias, configurações de clientes de API (como o supabaseClient.ts) que podem ser usados globalmente.
- **src/types/:** Tipos TypeScript compartilhados em todo o projeto.

### 3. Arquitetura do Módulo Blog (src/app/blogflorescerhumano/)

Todo o código e estrutura específicos do blog "Florescer Humano" **residirão exclusivamente** dentro desta pasta, garantindo o **isolamento e a autonomia organizacional** definidos nos objetivos.

```sql
      src/app/blogflorescerhumano/
│
├── layout.tsx        # Layout Principal DO BLOG (aplica NavbarBlog, FooterBlog, ThemeProvider específico?)
├── page.tsx          # Página Inicial/Homepage DO BLOG (ex: /blogflorescerhumano) - Provavelmente lista artigos
├── loading.tsx       # UI de Loading para a raiz do blog
├── error.tsx         # UI de Erro para a raiz do blog
├── not-found.tsx     # UI 404 específica para rotas não encontradas DENTRO do blog
│
├── # --- Rotas Estáticas (Páginas Principais) ---
│
├── categorias/
│   ├── page.tsx      # Página que lista/descreve todas as categorias
│   └── loading.tsx
│
├── sobre/
│   └── page.tsx      # Página "Sobre o Blog"
│
├── materiais/
│   └── page.tsx      # Página "Materiais Adicionais"
│
├── midias/
│   └── page.tsx      # Página "Recomendações de Mídias"
│
├── contato/
│   └── page.tsx      # Página "Contato" (provavelmente 'use client')
│
├── politica-privacidade/
│   └── page.tsx      # Página "Política de Privacidade"
│
├── em-construcao/
│   └── page.tsx      # Página genérica "Em Construção"
│
├── # --- Rotas Dinâmicas (Conteúdo Principal) ---
│
├── [categoria]/      # Rota dinâmica para categorias individuais (ex: /blogflorescerhumano/autoconhecimento)
│   ├── page.tsx      # Lista artigos da categoria específica (usa params.categoria)
│   ├── loading.tsx
│   ├── error.tsx
│   └── [slug]/       # Rota dinâmica aninhada para artigos individuais (ex: /blog/.../autoconhecimento/meu-artigo)
│       ├── page.tsx  # Exibe o artigo específico (usa params.categoria, params.slug)
│       ├── loading.tsx
│       └── error.tsx
│
├── # --- Código Fonte Específico do Blog ---
│
├── components/       # Componentes React específicos DO BLOG
│   ├── Article/      # Relacionados a Artigos
│   │   ├── ArticleCardBlog.tsx
│   │   ├── ArticleDetailBlog.tsx
│   │   ├── ArticleListBlog.tsx
│   │   └── ArticleMetadataBlog.tsx
│   ├── Category/     # Relacionados a Categorias
│   │   ├── CategoryLabelBlog.tsx
│   │   └── CategoryListBlog.tsx
│   ├── UI/           # Componentes UI genéricos DO BLOG (baseados no DS principal)
│   │   ├── ButtonBlog.tsx
│   │   ├── SearchBarBlog.tsx
│   │   ├── PaginationBlog.tsx
│   │   └── ... (replicar componentes de components/ui do site principal com sufixo Blog)
│   ├── GiscusComments.tsx # Componente para comentários ('use client')
│   ├── NewsletterFormBlog.tsx # Formulário ('use client')
│   ├── ContactFormBlog.tsx    # Formulário ('use client')
│   └── AuthorInfoBlog.tsx
│
├── hooks/            # Hooks customizados específicos DO BLOG
│   ├── data/         # Hooks para buscar dados do Supabase
│   │   ├── useSupabaseArticle.ts
│   │   ├── useSupabaseArticles.ts
│   │   └── useSupabaseCategories.ts
│   └── ui/           # Hooks de UI (opcional)
│       └── useSearchFilter.ts
│
├── services/         # Lógica de interação com APIs/Bancos de Dados DO BLOG
│   └── supabase/     # Funções específicas para interagir com Supabase
│       ├── articleService.ts
│       ├── categoryService.ts
│       ├── tagService.ts
│       ├── authorService.ts
│       └── newsletterService.ts
│
├── styles/           # Estilos específicos DO BLOG
│   ├── blog-globals.css # Estilos globais SÓ para o blog (se necessário)
│   ├── *.module.css   # CSS Modules para componentes específicos
│   └── ...
│
├── templates/        # Layouts de Página reutilizáveis DO BLOG
│   ├── ArticleTemplateBlog.tsx
│   ├── CategoryTemplateBlog.tsx
│   └── StaticPageTemplateBlog.tsx
│
└── utils/            # Funções utilitárias específicas DO BLOG
    ├── helpers.ts
    ├── seoUtils.ts
    └── supabaseUtils.ts (opcional)
```

IGNORE_WHEN_COPYING_START

content_copy  download  Use code [with caution](https://support.google.com/legal/answer/13505487).

IGNORE_WHEN_COPYING_END

### 4. Detalhamento e Justificativas

### 4.1. Isolamento do Módulo (src/app/blogflorescerhumano/)

- **Justificativa:** Garante que todo o código relacionado ao blog esteja contido, facilitando a localização, a manutenção e a possibilidade futura de extrair o blog para um pacote separado, se necessário. Evita poluir o escopo global do src/app/.
- **Implementação:** Todas as rotas, componentes, serviços, hooks, estilos e utilitários específicos do blog estão aninhados dentro desta pasta.
- **Nomenclatura:** O uso do sufixo Blog em componentes (ButtonBlog.tsx) e potencialmente em hooks/utils reforça esse isolamento e previne colisões com elementos de mesmo nome do site principal.

### 4.2. Roteamento (Convenções do App Router)

- **page.tsx:** Arquivo principal que exporta um componente React para renderizar a UI da rota. Geralmente Server Components (RSC) para buscar dados.
- **layout.tsx:** Define UI compartilhada para um segmento e seus filhos. O layout.tsx na raiz de blogflorescerhumano conterá a Navbar e o Footer específicos do blog (ou os reutilizará do global) e envolverá todas as páginas do blog.
- **Pastas com [] (ex: [categoria]):** Definem rotas dinâmicas. O valor do segmento (ex: "autoconhecimento") fica disponível nos params do componente page.tsx. Isso é crucial para páginas de categoria e artigos, refletindo a AI.
- **Arquivos Especiais (loading.tsx, error.tsx, not-found.tsx):** Permitem criar UIs específicas para estados de carregamento (via React Suspense), tratamento de erros (via Error Boundaries) e páginas 404, melhorando a UX. São colocados no mesmo nível da rota que devem controlar.

### 4.3. Organização de Componentes (components/)

- **components/ui/:** Segue o padrão Shadcn/ui (inferido do site principal). Contém componentes de UI "primitivos" ou genéricos (Button, Card, Input), mas com o sufixo Blog e estilizados para manter a coesão visual com o DS principal.
- **Pastas por Funcionalidade (Article/, Category/):** Agrupa componentes mais complexos ou específicos de um domínio do blog. Ex: ArticleCardBlog usa vários componentes de ui/ para montar o card.
- **Componentes Específicos na Raiz:** Componentes maiores ou que não se encaixam claramente em UI ou funcionalidade (ex: GiscusComments, NewsletterFormBlog) podem ficar na raiz de components/.
- **Client Components ('use client'):** Componentes que usam hooks de estado (useState), efeitos (useEffect) ou interatividade do navegador precisam da diretiva 'use client' no topo. Isso é comum para formulários e componentes que dependem de APIs do browser.

### 4.4. Lógica de Dados (services/ e hooks/)

- **services/supabase/:** Abstrai completamente as chamadas ao Supabase. Os componentes ou Server Components importam funções daqui (ex: getArticles()) sem precisar saber detalhes da implementação do Supabase. Promove separação de responsabilidades e facilita testes ou a troca futura do backend.
- **hooks/data/:** Principalmente útil para Client Components que precisam buscar dados ou gerenciar estado relacionado a dados (ex: paginação, filtros). Podem encapsular chamadas aos services. Em RSCs, a busca de dados pode ser feita diretamente no componente page.tsx chamando os services.

### 4.5. Estilos (styles/)

- **Abordagem:** Primariamente Tailwind CSS, aplicado via className.
- **blog-globals.css (Opcional):** Se houver estilos globais que se aplicam *apenas* ao blog e não ao site inteiro.
- **CSS Modules (*.module.css):** Usado para estilos específicos de componentes que são difíceis ou verbosos de fazer apenas com Tailwind, garantindo escopo local.

### 4.6. Templates (templates/)

- **Propósito:** Reutilizar a estrutura e layout comum entre páginas do mesmo tipo (ex: todos os artigos terão a mesma estrutura básica). O page.tsx da rota importa o template correspondente e passa os dados específicos como props.
- **Exemplo:** src/app/blogflorescerhumano/[categoria]/[slug]/page.tsx importaria ArticleTemplateBlog e passaria os dados do artigo buscado do Supabase para ele.

### 4.7. Utilitários (utils/)

- **Propósito:** Funções puras e reutilizáveis específicas do blog.
- **Exemplos:** helpers.ts (formatação de datas, truncar texto), seoUtils.ts (gerar metadados dinâmicos para layout.tsx ou page.tsx), supabaseUtils.ts (funções auxiliares para tratar dados do Supabase, se necessário).

### 4.8. Assets Estáticos (public/blogflorescerhumano/)

- **Propósito:** Armazenar imagens de capa, ícones personalizados do blog, ou outros assets que precisam ser servidos diretamente.
- **Uso:** Referenciados no código usando caminhos relativos à raiz (ex: /blogflorescerhumano/imagem-capa.png). O componente next/image deve ser usado para otimização.

### 5. Convenções de Nomenclatura

- **Pastas:** kebab-case (ex: blogflorescerhumano, politica-privacidade) ou camelCase (menos comum para pastas de rota). Dentro do código, usar camelCase (ex: components/Article).
- **Arquivos:** kebab-case para arquivos de configuração e rotas/páginas (page.tsx, layout.tsx, blog-globals.css). PascalCase para componentes React (ButtonBlog.tsx, ArticleTemplateBlog.tsx). camelCase para arquivos JS/TS de lógica (articleService.ts, helpers.ts).
- **Sufixo Blog:** Aplicado a componentes, hooks, utils e estilos específicos do módulo para diferenciação.

### 6. Considerações de SEO

- **Estrutura de URL:** As rotas dinâmicas com [categoria] e [slug] geram URLs semânticas e amigáveis (ex: /blogflorescerhumano/autoconhecimento/titulo-do-artigo), o que é positivo para SEO.
- **Metadados:** A estrutura permite definir metadados (title, description) dinamicamente nos page.tsx ou layout.tsx de cada rota, usando dados do Supabase (auxiliado por seoUtils.ts).

### 7. Escalabilidade e Manutenibilidade

- **Modularidade:** O isolamento na pasta blogflorescerhumano torna fácil adicionar novas funcionalidades ou mesmo extrair o blog futuramente.
- **Separação de Responsabilidades:** A divisão clara entre UI (components), lógica de dados (hooks, services), templates e utilitários facilita a manutenção e o entendimento do código.
- **Reutilização:** Componentes em ui/ e templates/ promovem a reutilização, reduzindo a duplicação de código.

### 8. Conclusão

Esta arquitetura de pastas e arquivos fornece uma estrutura organizada, modular e escalável para o desenvolvimento do blog "Florescer Humano" dentro do ecossistema Next.js e alinhada com a Arquitetura da Informação definida. Ela promove boas práticas de desenvolvimento, facilita a manutenção e suporta os objetivos de UX e SEO do projeto. Seguir esta estrutura e suas convenções é recomendado para garantir a consistência e a qualidade do código ao longo do desenvolvimento.

# **Documentação: Arquitetura de Pastas e Arquivos - Projeto Completo (Site + Blog)**

**Projeto:** Blog-site Daniel Dantas (Site Principal + Módulo Blog)

**Status:** Estrutura Definida

**Versão:** 2.0

**Data:** [Data Atual]

### 1. Visão Geral e Propósito da Estrutura

Esta documentação descreve a arquitetura de pastas e arquivos consolidada para todo o projeto psicologodanieldantas.com, incluindo o módulo integrado blogflorescerhumano. A estrutura visa:

- **Modularidade Clara:** Separar logicamente o código do site principal (landing page) e do módulo do blog.
- **Reutilização Eficiente:** Permitir o compartilhamento de componentes, utilitários e configurações globais entre o site e o blog.
- **Consistência:** Manter convenções de nomenclatura e organização em todo o projeto.
- **Alinhamento com Next.js App Router:** Utilizar as melhores práticas e convenções do framework.
- **Manutenibilidade e Escalabilidade:** Facilitar a manutenção de ambas as partes e a adição futura de novos módulos ou funcionalidades.

### 2. Estrutura Detalhada de Pastas e Arquivos (Consolidada)

      `.
├── public/                     # Assets estáticos
│   ├── psicologodanieldantas/ # Assets do site principal (ex: Daniel-Dantas-logo-footer-correta.png, hero-sofa.png)
│   └── blogflorescerhumano/    # Assets específicos do blog (ex: importancia-da-empatia-image-blog.png)
├── src/
│   ├── app/                    # === Diretório Principal do App Router ===
│   │   │
│   │   ├── # --- Arquivos Globais da Aplicação ---
│   │   ├── layout.tsx          # Layout RAIZ (HTML, BODY, ThemeProvider, Analytics, CookieConsent?)
│   │   ├── page.tsx            # Página inicial DO SITE PRINCIPAL (/) - Landing Page
│   │   ├── globals.css         # Estilos globais (incluindo variáveis CSS :root e .dark)
│   │   ├── google-site-verification.tsx # Verificação Google
│   │   ├── robots.ts           # Geração do robots.txt
│   │   ├── sitemap.ts          # Geração do sitemap.xml (DEVE incluir rotas do blog)
│   │   ├── schema-markup.tsx   # Dados estruturados globais
│   │   │
│   │   ├── # --- Rotas Estáticas DO SITE PRINCIPAL ---
│   │   ├── em-construcao/      # Página /em-construcao (usada pelo site ou blog)
│   │   │   └── page.tsx
│   │   ├── politica-de-privacidade/ # Página /politica-de-privacidade (usada pelo site ou blog)
│   │   │   └── page.tsx
│   │   │   # OBS: Rotas como /sobre, /servicos, /faq, /contato do SITE PRINCIPAL podem ser
│   │   │   #      seções dentro de app/page.tsx (One-Page) ou páginas separadas aqui.
│   │   │   #      A documentação original não detalha isso, vamos assumir One-Page por simplicidade
│   │   │   #      mas se fossem páginas separadas, estariam aqui: /sobre/page.tsx, etc.
│   │   │
│   │   ├── # ============================================================
│   │   ├── # ===        MÓDULO DO BLOG FLORESCER HUMANO             ===
│   │   ├── # ============================================================
│   │   │
│   │   └── blogflorescerhumano/
│   │       │
│   │       ├── # --- Arquivos Base do Módulo Blog ---
│   │       ├── layout.tsx        # Layout ESPECÍFICO do Blog (aplica NavbarBlog, FooterBlog) - Aninhado dentro do layout raiz
│   │       ├── page.tsx          # Página inicial DO BLOG (/blogflorescerhumano) - Listagem de artigos
│   │       ├── loading.tsx       # UI Loading da homepage do blog
│   │       ├── error.tsx         # UI Error da homepage do blog
│   │       ├── not-found.tsx     # UI 404 específica do blog
│   │       │
│   │       ├── # --- Rotas Estáticas DO BLOG ---
│   │       ├── categorias/
│   │       │   ├── page.tsx      # Página /blogflorescerhumano/categorias
│   │       │   └── loading.tsx
│   │       ├── sobre/
│   │       │   └── page.tsx      # Página /blogflorescerhumano/sobre
│   │       ├── materiais/
│   │       │   └── page.tsx      # Página /blogflorescerhumano/materiais
│   │       ├── midias/           # NOVA - Seção Mídias adicionada na documentação do blog
│   │       │   └── page.tsx      # Página /blogflorescerhumano/midias
│   │       ├── contato/
│   │       │   └── page.tsx      # Página /blogflorescerhumano/contato
│   │       │   # OBS: Note que esta é DIFERENTE da seção/página de contato do site principal
│   │       │
│   │       ├── # --- Rotas Dinâmicas DO BLOG ---
│   │       ├── [categoria]/
│   │       │   ├── page.tsx      # Página /blogflorescerhumano/[categoria]
│   │       │   ├── loading.tsx
│   │       │   ├── error.tsx
│   │       │   └── [slug]/
│   │       │       ├── page.tsx  # Página /blogflorescerhumano/[categoria]/[slug]
│   │       │       ├── loading.tsx
│   │       │       └── error.tsx
│   │       │
│   │       ├── # --- Código Fonte Específico do Blog ---
│   │       ├── components/       # Componentes React específicos DO BLOG
│   │       │   ├── Article/
│   │       │   ├── Category/
│   │       │   ├── UI/           # Componentes UI com sufixo Blog (ButtonBlog, etc.)
│   │       │   ├── GiscusComments.tsx
│   │       │   ├── NewsletterFormBlog.tsx
│   │       │   ├── ContactFormBlog.tsx
│   │       │   └── AuthorInfoBlog.tsx
│   │       │
│   │       ├── hooks/            # Hooks específicos DO BLOG
│   │       │   ├── data/         # Hooks Supabase (useSupabaseArticle, etc.)
│   │       │   └── ui/
│   │       │
│   │       ├── services/         # Serviços específicos DO BLOG
│   │       │   └── supabase/     # Funções Supabase (articleService, etc.)
│   │       │
│   │       ├── styles/           # Estilos específicos DO BLOG
│   │       │   ├── blog-globals.css (se necessário)
│   │       │   └── *.module.css
│   │       │
│   │       ├── templates/        # Templates de página DO BLOG
│   │       │   ├── ArticleTemplateBlog.tsx
│   │       │   ├── CategoryTemplateBlog.tsx
│   │       │   └── StaticPageTemplateBlog.tsx
│   │       │
│   │       └── utils/            # Utilitários específicos DO BLOG
│   │           ├── helpers.ts
│   │           ├── seoUtils.ts
│   │           └── supabaseUtils.ts
│   │
│   ├── # === Componentes Globais (Usados pelo Site e/ou Blog) ===
│   ├── components/
│   │   ├── analytics-event-tracker.tsx # Reutilizável
│   │   ├── analytics.tsx             # Reutilizável
│   │   ├── cookie-consent.tsx        # Reutilizável
│   │   ├── lazy-image.tsx            # Reutilizável
│   │   ├── script-loader.tsx         # Reutilizável
│   │   ├── theme-provider.tsx        # Reutilizável (Aplicado no layout.tsx raiz)
│   │   ├── touch-friendly-button.tsx # Pode ser base para ButtonBlog
│   │   ├── whatsapp-button.tsx       # Reutilizável
│   │   ├── # --- Componentes específicos da Landing Page ---
│   │   ├── challenges-section.tsx    # Específico LP
│   │   ├── contact-form.tsx          # Específico LP (DI FERENTE do ContactFormBlog.tsx)
│   │   ├── lazy-map.tsx              # Específico LP (seção Contato)
│   │   ├── simple-chatbot.tsx        # Específico LP
│   │   ├── wave-transition.tsx       # Específico LP
│   │   ├── # --- Componentes UI Globais (Shadcn/ui - Base para Blog) ---
│   │   └── ui/
│   │       ├── accordion.tsx
│   │       ├── alert-dialog.tsx
│   │       ├── button.tsx      # O componente base para ButtonBlog.tsx
│   │       ├── card.tsx        # O componente base para CardBlog.tsx
│   │       ├── input.tsx       # O componente base para InputBlog.tsx
│   │       ├── label.tsx       # O componente base para LabelBlog.tsx
│   │       ├── ... (Todos os outros componentes Shadcn)
│   │
│   ├── # === Hooks e Libs Globais ===
│   ├── hooks/                    # Hooks reutilizáveis em todo o site
│   │   ├── use-mobile.tsx        # Reutilizável
│   │   └── use-toast.ts          # Reutilizável (via Sonner)
│   │
│   ├── lib/                      # Utilitários e clientes globais
│   │   ├── utils.ts              # Função `cn` (clsx + tailwind-merge) - ESSENCIAL e REUTILIZÁVEL
│   │   └── supabaseClient.ts     # Cliente Supabase GLOBAL - REUTILIZÁVEL
│   │
│   └── # === Tipos Globais ===
│   └── types/
│       ├── index.ts
│       └── supabase.ts           # Tipos gerados pelo Supabase (se usar CLI)
│
├── .env.local
├── components.json             # Arquivo de configuração Shadcn/ui
├── middleware.ts               # Middleware Next.js (se houver)
├── next.config.mjs
├── package.json
├── pnpm-lock.yaml
├── postcss.config.mjs
├── tailwind.config.ts
└── tsconfig.json`

### 3. Explicação da Estrutura Consolidada

1. **Raiz do Projeto:** Contém arquivos de configuração (package.json, next.config.mjs, tailwind.config.ts, etc.) e a pasta src.
2. **src/:** Abriga todo o código fonte da aplicação.
3. **src/app/:**
    - **Arquivos Globais:** layout.tsx (raiz HTML, aplica ThemeProvider, Analytics), page.tsx (landing page principal), globals.css (estilos base e variáveis CSS).
    - **Rotas Estáticas Globais:** Pastas como politica-de-privacidade definem páginas acessíveis a partir da raiz (ex: /politica-de-privacidade).
    - **src/app/blogflorescerhumano/ (Módulo Blog):**
        - Contém sua **própria estrutura de rotas** (estáticas como /categorias, /sobre; dinâmicas como /[categoria]/[slug]).
        - Possui seu **próprio layout.tsx**, que será renderizado *dentro* do layout.tsx raiz, permitindo adicionar elementos específicos do blog (como uma Navbar secundária se necessário, ou contextos específicos).
        - Abriga suas **próprias subpastas** components, hooks, services, styles, templates, utils, garantindo **total isolamento técnico**.
        - Componentes em components/ui/ aqui **herdarão visualmente** dos componentes em src/components/ui/, mas serão **implementações distintas** com o sufixo Blog.
4. **src/components/ (Global):**
    - Contém componentes usados em **múltiplas partes do site**, incluindo a landing page e potencialmente reutilizados ou referenciados pelo blog (como ThemeProvider, Analytics).
    - Crucialmente, contém a pasta ui/ com os **componentes base do Shadcn/ui**. Estes são os componentes "originais" que servirão de modelo visual para os componentes *Blog.tsx do módulo do blog.
5. **src/hooks/ e src/lib/ (Global):**
    - Contêm hooks (use-mobile, use-toast) e utilitários (cn em utils.ts, supabaseClient.ts) que são **essenciais e podem ser usados tanto pelo site principal quanto pelo blog**. A função cn e o supabaseClient são exemplos claros de reutilização.
6. **public/:** Dividida em subpastas (psicologodanieldantas/ e blogflorescerhumano/) para organizar os assets de cada parte do site.

### 4. Fluxo de Reutilização e Coesão

- **Tokens Visuais:** Definidos em src/app/globals.css e/ou tailwind.config.ts, aplicam-se a **todo** o projeto, garantindo coesão de cores, fontes, etc.
- **Componentes Base:** Os componentes em src/components/ui/ definem a aparência padrão (baseada nos tokens).
- **Componentes do Blog:** Os componentes em src/app/blogflorescerhumano/components/ui/ (ex: ButtonBlog.tsx) importam a lógica de variantes (buttonVariants) e estilos base do componente correspondente em src/components/ui/ (ex: button.tsx), mas são arquivos separados. Isso permite pequenas customizações futuras no blog sem afetar o site principal, mantendo a coesão visual.
- **Utilitários Globais:** Funções como cn e o cliente Supabase são importados de src/lib/ tanto pela landing page quanto pelo blog.

### 5. Conclusão

Esta estrutura consolidada oferece uma visão clara de como o site principal e o módulo do blog coexistem dentro do mesmo projeto Next.js, promovendo a reutilização de configurações e utilitários globais, ao mesmo tempo que garante um forte isolamento técnico e organizacional para o blog "Florescer Humano". Ela está alinhada com as melhores práticas do Next.js App Router e suporta os objetivos definidos na Arquitetura da Informação e no Design System.

# **Documentação: Integrações (Google, Mapas) - Aplicação no Site e Blog**

**Projeto:** Blog-site Daniel Dantas (Site Principal + Módulo Blog)

**Status:** Diretrizes de Implementação

**Versão:** 1.0

**Data:** [Data Atual]

### 1. Introdução e Propósito

Esta documentação descreve como as integrações com serviços externos, especificamente as ferramentas do Google (Site Verification, Analytics, Tag Manager, Schema Markup, Robots.txt, Sitemap) e o Mapa Interativo, devem ser implementadas e gerenciadas para abranger **tanto** o site principal (psicologodanieldantas.com) **quanto** o módulo do blog (/blogflorescerhumano).

O objetivo é garantir que:

- **Rastreamento e Análise Unificados:** Google Analytics e Tag Manager coletem dados de forma consistente de todo o site, incluindo o blog.
- **Verificação de Propriedade Válida:** A verificação do Google Search Console cubra todo o domínio.
- **SEO Otimizado:** Dados estruturados (Schema), robots.txt e sitemap.xml reflitam corretamente a estrutura completa do site e do blog, maximizando a visibilidade nos motores de busca.
- **Funcionalidade Consistente:** O mapa interativo, se necessário no blog, utilize a mesma implementação otimizada do site principal.
- **Boas Práticas:** As implementações sigam as melhores práticas de performance (lazy loading), consentimento (LGPD/GDPR) e segurança.

A arquitetura de pastas e o uso de layouts aninhados no Next.js App Router facilitam essa gestão unificada.

### 2. Google Site Verification

- **Arquivo Responsável:** src/app/google-site-verification.tsx (Conforme estrutura fornecida).
- **Funcionamento:** Este componente provavelmente renderiza uma meta tag <meta name="google-site-verification" content="..." /> necessária para provar a propriedade do domínio psicologodanieldantas.com ao Google Search Console.
- **Implementação (Site + Blog):**
    - Este componente deve ser renderizado **uma única vez** dentro do <head> do **Layout Raiz** da aplicação (src/app/layout.tsx).
    - Ao ser incluído no layout raiz, a meta tag estará presente em **todas as páginas** do site, incluindo todas as páginas dentro de /blogflorescerhumano.
    - **Nenhuma ação adicional** é necessária especificamente para o blog. A verificação é feita no nível do domínio.
- **Boas Práticas:** Manter o código de verificação atualizado conforme fornecido pelo Google Search Console.

### 3. Google Analytics e Google Tag Manager (GTM)

- **Arquivos Responsáveis:**
    - src/components/analytics.tsx: Provavelmente carrega o(s) script(s) do GA4/GTM.
    - src/components/cookie-consent.tsx: Gerencia o consentimento do usuário para cookies/rastreamento.
    - src/components/analytics-event-tracker.tsx: Função/componente para disparar eventos personalizados.
- **Funcionamento:** O analytics.tsx insere o snippet de rastreamento do Google. Sua execução é condicionada ao consentimento do usuário, gerenciado pelo cookie-consent.tsx. Eventos específicos podem ser rastreados usando o analytics-event-tracker.tsx.
- **Implementação (Site + Blog):**
    1. **Carregamento Global:** O componente CookieConsent e o componente Analytics (ou sua lógica de inicialização condicionada ao consentimento) devem ser incluídos **uma única vez** no **Layout Raiz** (src/app/layout.tsx). Isso garante que eles sejam carregados em todas as páginas.
    2. **Rastreamento Unificado:** Uma vez carregado (após consentimento), o script GA4/GTM rastreará automaticamente as visualizações de página (pageviews) de **todas as rotas**, incluindo as do site principal (/) e as do blog (/blogflorescerhumano/...).
    3. **Segmentação de Dados:** A diferenciação entre tráfego do site e do blog será feita **dentro da plataforma do Google Analytics/GTM**, utilizando filtros baseados no caminho da página (ex: page_path starts with /blogflorescerhumano/).
    4. **Eventos Personalizados:** O analytics-event-tracker.tsx pode ser importado e utilizado em **qualquer componente** (tanto do site quanto do blog) onde um evento específico precise ser rastreado (ex: clique em botão de agendamento, envio de formulário de contato do blog, inscrição na newsletter do blog).
- **Boas Práticas:**
    - Sempre carregar scripts de rastreamento **após** obter o consentimento explícito do usuário (LGPD/GDPR).
    - Configurar corretamente os filtros e relatórios no GA/GTM para analisar separadamente o desempenho do site e do blog.
    - Manter os IDs de acompanhamento (GA4 Measurement ID, GTM Container ID) em variáveis de ambiente.

### 4. Schema Markup (Dados Estruturados)

- **Arquivos Responsáveis:**
    - src/app/schema-markup.tsx: Provavelmente lida com Schema global (nível do site).
    - Lógica dentro dos page.tsx (para Schema específico da página).
- **Funcionamento:** Insere dados estruturados (JSON-LD) no <head> para ajudar os motores de busca a entenderem o conteúdo da página.
- **Implementação (Site + Blog):**
    1. **Schema Global:** O componente SchemaMarkup (src/app/schema-markup.tsx) deve ser incluído **uma única vez** no **Layout Raiz** (src/app/layout.tsx). Ele deve gerar o Schema básico do tipo WebSite e Organization (ou Person para Daniel Dantas).
    2. **Schema Específico de Página:** **É crucial** gerar Schema **específico** para cada tipo de página relevante, tanto no site quanto no blog. Isso deve ser feito **dentro do componente page.tsx** de cada rota:
        - **Landing Page (src/app/page.tsx):** Pode ter Schema WebPage, talvez Service para os serviços oferecidos.
        - **Páginas Estáticas (Site e Blog - ex: /sobre, /contato, /politica-de-privacidade, /blogflorescerhumano/sobre):** Devem gerar Schema WebPage.
        - **Páginas de Artigo do Blog (src/app/blogflorescerhumano/[categoria]/[slug]/page.tsx):** **FUNDAMENTAL** gerar Schema Article ou BlogPosting. Os dados para preencher este schema (título, autor, data de publicação/modificação, imagem de capa, resumo, etc.) devem ser **buscados do Supabase** para aquele artigo específico.
        - **Páginas de Categoria do Blog (src/app/blogflorescerhumano/[categoria]/page.tsx):** Podem gerar Schema CollectionPage, listando os artigos contidos.
    3. **Geração Dinâmica:** A lógica para gerar o JSON-LD específico da página deve residir nos respectivos page.tsx (Server Components), que têm acesso aos dados necessários (seja estático ou buscado do Supabase).
- **Boas Práticas:**
    - Usar JSON-LD como formato preferencial.
    - Validar o Schema gerado usando ferramentas como o Google Rich Results Test.
    - Garantir que o Schema reflita com precisão o conteúdo visível na página.

### 5. Robots.txt

- **Arquivo Responsável:** src/app/robots.ts (Convenção Next.js para geração dinâmica).
- **Funcionamento:** Gera o arquivo /robots.txt na raiz do site, que instrui os robôs dos motores de busca sobre quais partes do site podem ou não ser rastreadas.
- **Implementação (Site + Blog):**
    - A lógica em src/app/robots.ts deve garantir que **nenhuma seção importante seja bloqueada acidentalmente**.
    - **Verificar:** As regras devem permitir o rastreamento da raiz (Allow: /) e, por consequência, de /blogflorescerhumano/.
    - **Confirmar:** Não deve haver regras Disallow: que bloqueiem /blogflorescerhumano/ ou subdiretórios importantes como /blogflorescerhumano/categorias/ ou /blogflorescerhumano/[categoria]/.
    - **Sitemap:** Incluir a URL completa do sitemap (ex: Sitemap: https://psicologodanieldantas.com/sitemap.xml).
- **Boas Práticas:** Manter o robots.txt o mais permissivo possível para conteúdo público, bloqueando apenas áreas administrativas ou de baixo valor (se houver).

### 6. Sitemap.xml

- **Arquivo Responsável:** src/app/sitemap.ts (Convenção Next.js para geração dinâmica).
- **Funcionamento:** Gera o arquivo /sitemap.xml na raiz do site, que lista as URLs importantes do site para ajudar os motores de busca a descobri-las e indexá-las.
- **Implementação (Site + Blog):**
    1. **Lógica Unificada:** A função exportada por src/app/sitemap.ts **PRECISA ser modificada** para gerar URLs tanto do site principal quanto do blog.
    2. **URLs do Site Principal:** Listar as URLs estáticas (/, /politica-de-privacidade, /em-construcao, etc.) e quaisquer outras páginas principais.
    3. **URLs do Blog (Dinâmicas):**
        - **Buscar Dados do Supabase:** A função precisará **conectar-se ao Supabase** para buscar:
            - Todas as **categorias** publicadas (para gerar URLs como /blogflorescerhumano/[categoria]).
            - Todos os **artigos** publicados (com status = 'publicado' e data_publicacao válida) para gerar URLs como /blogflorescerhumano/[categoria]/[slug].
        - **Construir URLs:** Mapear os dados buscados para o formato de URL correto e adicioná-los à lista do sitemap. Incluir lastModified (usando data_atualizacao ou data_publicacao).
- **Boas Práticas:**
    - Incluir apenas URLs canônicas e indexáveis.
    - Atualizar o sitemap dinamicamente ou com frequência (a abordagem do Next.js com sitemap.ts geralmente o gera sob demanda ou durante o build).
    - Garantir que as URLs no sitemap correspondam exatamente às URLs acessíveis no site.

### 7. Mapa Interativo

- **Arquivo Responsável:** src/components/lazy-map.tsx (Componente reutilizável).
- **Funcionamento:** Carrega e exibe um mapa interativo (provavelmente Google Maps) de forma otimizada (lazy loading).
- **Implementação (Site + Blog):**
    1. **Uso no Site Principal:** Já está implementado, provavelmente na seção de contato da landing page (src/app/page.tsx).
    2. **Uso no Blog (Opcional):** Se a página de contato do blog (src/app/blogflorescerhumano/contato/page.tsx) ou qualquer outra página do blog precisar exibir um mapa:
        - **Importar:** Importar o componente LazyMap de src/components/lazy-map.tsx.
        - **Utilizar:** Renderizar o componente passando as props necessárias (endereço, coordenadas, chave de API se aplicável e configurada de forma segura).
    3. **Reutilização:** O mesmo componente LazyMap pode ser usado em ambos os contextos, garantindo consistência e evitando duplicação de código.
- **Boas Práticas:**
    - Sempre usar lazy loading para mapas.
    - Gerenciar chaves de API de forma segura (variáveis de ambiente, idealmente com restrições de domínio na plataforma do provedor do mapa).
    - Fornecer alternativas textuais ou garantir a acessibilidade do mapa.

### 8. Conclusão

A estrutura do projeto Next.js com App Router permite gerenciar eficientemente as integrações do Google e componentes como mapas para todo o site, incluindo o módulo do blog. A chave é:

- Implementar configurações e scripts **globais** no **Layout Raiz** (src/app/layout.tsx).
- Gerar arquivos de **raiz** (robots.txt, sitemap.xml) na **raiz do app/**, mas com lógica que **inclua os dados/URLs do blog** (exigindo busca no Supabase para o sitemap).
- Gerar **Schema específico** dinamicamente **dentro dos page.tsx** relevantes (site e blog).
- **Reutilizar componentes globais** (LazyMap, Analytics, etc.) onde necessário dentro do módulo do blog.

Seguir estas diretrizes garantirá que todas as integrações funcionem corretamente e de forma otimizada para o site psicologodanieldantas.com como um todo.

# **Documentação Definitiva do Projeto: Site Psicólogo Daniel Dantas & Blog Florescer Humano**

**Versão:** 2.0 (Consolidada)

**Data:** [Data Atual]

**Autores:** Daniel Dantas, IA (Assistente de Projeto)

**Índice:**

1. Visão Geral do Projeto
2. Objetivos Estratégicos (Site e Blog)
3. Arquitetura Geral: Integração Site + Blog
4. Arquitetura da Informação (AI) Consolidada
    
    4.1. AI do Site Principal (psicologodanieldantas.com)
    
    4.2. AI do Módulo Blog (/blogflorescerhumano)
    
    4.3. Refinamentos da AI (Simulações de Personas, Jornadas, Card Sorting)
    
5. Design System Consolidado
    
    5.1. Filosofia e Princípios
    
    5.2. Fundamentos Visuais (Tokens)
    
    5.3. Componentes de UI (Globais e Específicos do Blog)
    
    5.4. Layout e Responsividade
    
    5.5. Acessibilidade
    
    5.6. Iconografia
    
6. Arquitetura de Pastas e Arquivos (Estrutura Completa do Projeto)
7. Tecnologias e Ferramentas (Stack Tecnológico)
8. Banco de Dados (Supabase)
    
    8.1. Esquema de Tabelas (SQL)
    
    8.2. Gerenciamento de Segurança (RLS)
    
9. Integrações Externas
    
    9.1. Google (Verification, Analytics/GTM, Schema, Robots, Sitemap)
    
    9.2. Mapa Interativo (Lazy Loading)
    
    9.3. Giscus (Comentários do Blog)
    
10. Boas Práticas Adotadas
    
    10.1. Experiência do Usuário (UX)
    
    10.2. Otimização para Motores de Busca (SEO)
    
    10.3. Código Limpo e Manutenibilidade
    
11. Conteúdo de Referência (Copy do Site Principal)
12. Guia de Reprodução e Próximos Passos

---

### 1. Visão Geral do Projeto

Este projeto engloba a criação e manutenção do site profissional do Psicólogo Daniel Dantas (psicologodanieldantas.com) e a integração de um módulo de blog, denominado "Florescer Humano" (/blogflorescerhumano), dentro da mesma aplicação Next.js.

- **Site Principal:** Funciona como uma landing page estendida, apresentando o profissional, seus serviços, abordagem terapêutica e formas de contato, com foco na captação de clientes e estabelecimento de autoridade.
- **Módulo Blog ("Florescer Humano"):** Opera como uma seção rica em conteúdo, focada nos princípios do humanismo, psicologia humanista (ACP, Focalização), mindfulness e autoconhecimento. Visa educar, inspirar e construir uma comunidade, funcionando de forma tecnicamente modular, mas visualmente integrada ao site principal.

A plataforma tecnológica escolhida é **Next.js com App Router**, estilizada com **Tailwind CSS** e utilizando **Supabase** como backend (principalmente para o blog) e **Giscus** para comentários.

### 2. Objetivos Estratégicos (Site e Blog)

### 2.1. Objetivos Gerais do Site (psicologodanieldantas.com)

- **Apresentação Profissional:** Destacar o trabalho, experiência, abordagem (humanista, ACP, Focalização, Mindfulness) e diferenciais do psicólogo Daniel Dantas.
- **Captação de Leads:** Facilitar o agendamento de consultas e o contato inicial de potenciais clientes (formulário, WhatsApp).
- **Construção de Confiança:** Transmitir profissionalismo, acolhimento e sensibilidade através do design e do conteúdo.
- **Informação de Serviços:** Descrever claramente os serviços oferecidos (psicoterapia online individual, grupos, etc.).
- **Usabilidade e Acessibilidade:** Garantir uma experiência de navegação fácil, rápida e acessível.
- **SEO Básico:** Otimizar a landing page para termos de busca relacionados ao nome do profissional e serviços principais.

### 2.2. Objetivos Específicos do Blog ("Florescer Humano")

- **Missão:** Cultivar a compreensão e vivência do humanismo, oferecendo um "jardim de reflexão, aprendizado e encontro" focado em psicologia humanista (ACP, Focalização), Mindfulness e diálogo interdisciplinar.
- **Visão:** Tornar-se uma referência online sobre humanismo, construir uma comunidade engajada e guiar os leitores no "florescer humano".
- **Valores:** Coerentes com a abordagem humanista (Valorização da Pessoa, Respeito pela Experiência, Crescimento, Autenticidade, Diálogo, Ética, etc.).
- **Público-Alvo (Priorizado):** 1° Pessoas em busca de autoconhecimento; 2° Estudantes de Psicologia; 3° Profissionais da Área.
- **Conteúdo:** Publicar regularmente artigos (reflexões, guias práticos, teoria acessível), explorar aplicações do humanismo, ressoar com os desafios do público, oferecer ferramentas.
- **Engajamento:** Incentivar comentários (Giscus), promover diálogo, considerar expansão para outras plataformas (newsletter, redes sociais).
- **Alcance:** Otimizar para SEO, buscar colaborações.
- **Integração:** Garantir coesão visual e transição fluida com o site principal, mantendo autonomia técnica e URLs claras (/blogflorescerhumano/...).
- **Sustentabilidade:** Implementar estratégias éticas de monetização (afiliados, patrocínios curated, conteúdo pago, doações) para viabilizar o projeto a longo prazo.
- *(Referência Detalhada: Seção "Documentação: Objetivos Estratégicos e Fundamentais - Blog Florescer Humano")*

### 3. Arquitetura Geral: Integração Site + Blog

O projeto adota uma **arquitetura monolítica com separação modular** dentro de uma única aplicação Next.js:

- **Aplicação Única:** Todo o código reside em um único repositório e é deployado como uma única aplicação.
- **Módulo do Blog:** O código específico do blog está isolado na pasta src/app/blogflorescerhumano/. Isso inclui suas próprias rotas, layouts aninhados, componentes (*Blog), serviços, hooks e estilos.
- **Compartilhamento:** Configurações globais (Next.js, Tailwind, TS), estilos base (globals.css), utilitários (lib/utils.ts), cliente Supabase (lib/supabaseClient.ts) e componentes UI base (src/components/ui/) são compartilhados. O layout raiz (src/app/layout.tsx) envolve toda a aplicação.
- **Roteamento:** O Next.js App Router gerencia as rotas. A landing page está em /, e o blog em /blogflorescerhumano/.
- **Benefícios:** Reutilização de código global, deploy simplificado, manutenção centralizada, ao mesmo tempo que permite desenvolvimento focado no blog sem impactar diretamente o site principal (e vice-versa).

### 4. Arquitetura da Informação (AI) Consolidada

A AI define como o conteúdo é organizado, estruturado e rotulado para garantir usabilidade e encontrabilidade.

### 4.1. AI do Site Principal (psicologodanieldantas.com)

- **Estrutura:** Principalmente uma **Landing Page Estendida (One-Page)**, com seções correspondendo aos itens de menu (Início, Sobre, Serviços, FAQ, Blog [link], Contato).
- **Páginas Separadas:** /politica-de-privacidade, /em-construcao.
- **Navegação:** Menu principal fixo (ou que encolhe/muda no scroll), links internos para seções, botão de CTA principal ("Agendar Consulta", WhatsApp).
- **Foco:** Apresentação clara e direta, guiando o usuário para o contato ou agendamento.

### 4.2. AI do Módulo Blog (/blogflorescerhumano)

- **Estrutura Hierárquica/Temática:** Organizada em torno de 5 categorias principais.
- **Categorias Principais:**
    1. Autoconhecimento e Desenvolvimento Pessoal
    2. Psicologia Humanista e Abordagens Relacionadas
    3. Bem-Estar Emocional e Saúde Mental
    4. Relacionamentos e Conexões Humanas
    5. Florescer na Vida (Inspiracional/Pessoal)
- **Organização Secundária (Híbrida):**
    - **Subcategorias:** Para detalhamento dentro das categorias (especialmente em Psicologia Humanista).
    - **Tags:** Sistema flexível para conectar artigos por conceitos, autores, nível de audiência, contexto de aplicação (Pessoal, Clínico, Educacional, Organizacional). Essencial para atender à diversidade de personas.
- **Páginas Principais do Blog:**
    - /blogflorescerhumano/ (Homepage do Blog / Listagem de Artigos)
    - /[categoria]/ (Página de Categoria)
    - /[categoria]/[slug]/ (Página de Artigo Individual)
    - /categorias/ (Visão Geral das Categorias)
    - /sobre/ (Sobre o Blog)
    - /materiais/ (Recursos Adicionais)
    - /midias/ (Recomendações Externas)
    - /contato/ (Contato específico do Blog)
- **Sistemas de Navegação:** Navbar específica do blog, filtros por categoria/tag, busca interna, navegação contextual (links internos, relacionados), navegação suplementar (footer).
- **Rotulagem:** Focada na clareza para P1, mas com termos técnicos disponíveis via tags/subcategorias. Consistente e otimizada para SEO.
- *(Referência Detalhada: Seção "Documentação Conclusiva da Arquitetura da Informação (AI) - Blog Florescer Humano (Com Simulação Adicional - Conjunto 3)")*

### 4.3. Refinamentos da AI (Simulações de Personas, Jornadas, Card Sorting)

- **Personas:** Múltiplos conjuntos simulados (Mariana, João, Ricardo; Carlos, Beatriz, Sandra; Lucas, Camila, Roberto) validaram a estrutura e destacaram a necessidade de atender diferentes níveis de profundidade, contextos de aplicação e interesses interdisciplinares.
- **Jornadas:** Simulações revelaram a importância de filtros granulares, busca eficaz, conexão clara entre teoria/prática e seções de recursos bem curadas.
- **Card Sorting:** Simulações confirmaram as categorias principais, mas indicaram a necessidade de rótulos acessíveis e mecanismos de organização secundários (tags, subcategorias, filtros por contexto/formato).
- **Recomendações Chave:** Implementar sistema híbrido (Categorias + Tags ricas e filtráveis), priorizar filtros/busca, segmentar/sinalizar conteúdo (nível, contexto), curadoria estratégica de Materiais/Mídias, fortalecer conectividade (links internos).

### 5. Design System Consolidado

O DS define a linguagem visual e interativa. O blog **herda visualmente** do site principal, mas implementa seus componentes de forma **independente**.

### 5.1. Filosofia e Princípios

- Humanista, Acolhedor, Claro, Intuitivo, Acessível, Consistente, Modular, Coeso.

### 5.2. Fundamentos Visuais (Tokens)

- **Cores:** Paleta HSL definida em globals.css (Bege claro, Marrom escuro, Marrom médio), com temas claro/escuro. Deve ser usada consistentemente em ambos os módulos.
- **Tipografia:** Fonte principal Kaisei Opti (Serifada), fallback Arial (Sans-serif). Hierarquia gerenciada por Tailwind, espelhando o site principal.
- **Espaçamento:** Escala Tailwind consistente em todo o projeto.
- **Bordas/Raios:** Usar --border e --radius (0.5rem) definidos globalmente.
- **Sombras:** Replicar padrões de sombra do site principal (provavelmente via classes Tailwind).
- *(Referência Detalhada: Seção "Documentação: Análise de Padrões Visuais e Componentes - Site psicologodanieldantas.com")*

### 5.3. Componentes de UI (Globais e Específicos do Blog)

- **Abordagem:** Recomendado seguir o padrão Shadcn/ui (Radix + Tailwind + CVA + cn) identificado no site principal.
- **Componentes Globais (src/components/ui/):** Componentes base (Button, Card, Input, etc.) usados pelo site principal.
- **Componentes do Blog (src/app/blogflorescerhumano/components/ui/):** Implementações **separadas** com sufixo Blog (ex: ButtonBlog.tsx). Devem **importar/replicar** os estilos/variantes dos componentes globais correspondentes para garantir coesão visual, mas o código é isolado no módulo do blog.
- **Lista Essencial (Blog):** ButtonBlog, CardBlog, InputBlog, TextareaBlog, LabelBlog, TagBlog/BadgeBlog, ArticleMetadataBlog, AuthorInfoBlog, SeparatorBlog, PaginationBlog, SearchBarBlog, GiscusComments, NewsletterFormBlog, ContactFormBlog, SkeletonBlog.

### 5.4. Layout e Responsividade

- Abordagem **mobile-first** com breakpoints Tailwind consistentes.
- Uso de **Flexbox/Grid** do Tailwind.
- **Containers** com max-w- para limitar largura em telas grandes.
- **Templates** (src/app/blogflorescerhumano/templates/) para estrutura de páginas do blog.

### 5.5. Acessibilidade

- Seguir **WCAG 2.1 AA**.
- HTML Semântico, Navegação por Teclado, Contraste de Cores, Alt Text, ARIA (via Radix), Formulários acessíveis, Legibilidade.

### 5.6. Iconografia

- Usar **lucide-react** consistentemente.
- Aplicar boas práticas de acessibilidade para ícones.

### 6. Arquitetura de Pastas e Arquivos (Estrutura Completa do Projeto)

- A estrutura detalhada na Seção 2 da "Documentação: Arquitetura de Pastas e Arquivos - Projeto Completo (Site + Blog)" deve ser seguida.
- **Destaques:**
    - Isolamento total do blog em src/app/blogflorescerhumano/.
    - Reutilização de src/components/ui/, src/lib/, src/hooks/ globais.
    - Estrutura de rotas dinâmica e estática clara dentro do módulo do blog usando App Router.
    - Organização interna do módulo do blog (components, services, hooks, styles, templates, utils).
    - Separação de assets em public/psicologodanieldantas/ e public/blogflorescerhumano/.

### 7. Tecnologias e Ferramentas (Stack Tecnológico)

- **Framework:** Next.js (v15+) com App Router
- **Linguagem:** TypeScript
- **Estilização:** Tailwind CSS (v3.4+)
- **Componentes UI:** Radix UI Primitives + class-variance-authority + clsx + tailwind-merge (via lib/utils.ts - padrão Shadcn/ui)
- **Banco de Dados (Blog):** Supabase (PostgreSQL)
- **Comentários (Blog):** Giscus (via GitHub Issues)
- **Formulários:** React Hook Form + Zod (para validação)
- **Theming:** next-themes
- **Ícones:** lucide-react
- **Notificações (Toast):** Sonner
- **Carrossel:** Embla Carousel React
- **Gráficos (Opcional):** Recharts
- **Analytics:** Google Analytics 4 / Google Tag Manager

### 8. Banco de Dados (Supabase)

Utilizado primariamente para o conteúdo dinâmico do blog.

### 8.1. Esquema de Tabelas (SQL)

- As tabelas definidas são: categorias, subcategorias, autores, tags, artigos, artigos_tags, newsletter_assinantes.
- O SQL completo (com e sem comentários) está detalhado na seção "Documentação do Esquema de Banco de Dados Supabase para o Blog 'Florescer Humano'".
- **Lembrete:** Colunas foto_arquivo e imagem_capa_arquivo armazenam apenas nomes de arquivos da pasta public/.

### 8.2. Gerenciamento de Segurança (RLS)

- **OBRIGATÓRIO:** Habilitar RLS em **TODAS** as tabelas no painel do Supabase.
- **Políticas Essenciais:**
    - **Leitura Pública (SELECT USING (true)):** Para categorias, subcategorias, autores, tags.
    - **Leitura Pública Condicional (SELECT USING (status = 'publicado' AND data_publicacao <= now())):** Para artigos. Isso é crucial para proteger rascunhos/agendados da API anon.
    - **Leitura Restrita (SELECT USING (false)):** Para newsletter_assinantes. Bloqueia totalmente o acesso de leitura via API anon.
    - **Escrita Restrita (FOR ALL USING/WITH CHECK (false) ou auth.role() = 'authenticated' - simplificado):** Aplicar políticas que impeçam a escrita via API anon para todas as tabelas. A gestão do conteúdo será feita via dashboard Supabase ou por um usuário autenticado (se uma interface de admin for criada). A inserção na newsletter requer uma função segura (Edge Function ou backend).
- *(Referência Detalhada: Seção "Documentação: Gerenciando Segurança com Row Level Security (RLS) no Supabase")*

### 9. Integrações Externas

As integrações devem ser gerenciadas de forma unificada para todo o site.

### 9.1. Google (Verification, Analytics/GTM, Schema, Robots, Sitemap)

- **Verification:** Meta tag em src/app/layout.tsx via componente google-site-verification.tsx.
- **Analytics/GTM:** Scripts carregados em src/app/layout.tsx via analytics.tsx, condicionados ao consentimento gerenciado por cookie-consent.tsx. Rastreamento unificado, segmentação feita no GA/GTM por page_path. Eventos via analytics-event-tracker.tsx.
- **Schema Markup:** Schema global (WebSite, Person) em src/app/layout.tsx via schema-markup.tsx. Schema específico (Article, BlogPosting, WebPage, CollectionPage) gerado dinamicamente dentro dos page.tsx relevantes (site e blog), buscando dados quando necessário (ex: Supabase para artigos).
- **Robots.txt:** Gerado por src/app/robots.ts, deve permitir rastreamento de / e /blogflorescerhumano/.
- **Sitemap.xml:** Gerado por src/app/sitemap.ts, **deve buscar dados do Supabase** para incluir dinamicamente as URLs de categorias e artigos publicados do blog, além das páginas estáticas do site.
- *(Referência Detalhada: Seção "Documentação: Integrações (Google, Mapas) - Aplicação no Site e Blog")*

### 9.2. Mapa Interativo (Lazy Loading)

- **Componente:** src/components/lazy-map.tsx.
- **Uso:** Implementado na landing page. Pode ser **reutilizado** na página de contato do blog (ou onde for necessário) importando o mesmo componente.
- **Boas Práticas:** Lazy loading essencial, gerenciamento seguro de API keys.

### 9.3. Giscus (Comentários do Blog)

- **Tecnologia:** Sistema de comentários baseado em GitHub Discussions/Issues.
- **Implementação:**
    - Componente GiscusComments.tsx (em src/app/blogflorescerhumano/components/) marcado como 'use client'.
    - Utiliza o pacote @giscus/react.
    - Configurado com o repositório GitHub, IDs, mapeamento (ex: pathname), tema, etc.
    - Renderizado dentro do template ou página de artigo individual (ArticleTemplateBlog.tsx ou /[categoria]/[slug]/page.tsx).
- **Vantagens:** Sem backend próprio para comentários, moderação via GitHub, integração natural para comunidades de desenvolvedores (mas aberto a todos).

### 10. Boas Práticas Adotadas

- **UX:** Foco na clareza, consistência, acessibilidade, feedback visual, navegação intuitiva, design responsivo, conteúdo direcionado às personas.
- **SEO:** URLs semânticas, sitemap dinâmico, robots.txt otimizado, schema markup rico e específico, meta tags dinâmicas, otimização de imagens (next/image), linkagem interna estratégica, conteúdo relevante focado em palavras-chave identificadas.
- **Código Limpo:** Modularidade (isolamento do blog), componentização (reutilização via DS), separação de responsabilidades (UI, lógica de dados, serviços), tipagem forte (TypeScript), convenções de nomenclatura, uso de linters/formatters (ESLint/Prettier), código comentado onde necessário.

### 11. Conteúdo de Referência (Copy do Site Principal)

*(Esta seção incluiria a cópia detalhada fornecida no arquivo DOCUMENTACAO-sitepsicologodanieldantas.md, servindo como referência para o tom de voz, estilo de escrita e informações institucionais a serem mantidas ou adaptadas no blog).*

- Cabeçalho / Menu (Itens de navegação do site principal)
- Hero Section (Título, Subtítulo, CTA principal)
- Sobre Mim (Texto completo)
- Conheça Meu Trabalho (Descrição do vídeo)
- Desafios que Podemos Enfrentar Juntos (Lista de desafios em cards)
- Serviços (Descrição Psicoterapia Online)
- Demandas Atendidas (Texto introdutório)
- Outros Serviços (Descrições detalhadas)
- Blog Florescer Humano (Chamada na landing page)
- FAQ (Perguntas e respostas)
- Contato (Informações, texto do formulário)
- Footer (Texto, Links Rápidos)
- Política de Privacidade (Estrutura e trechos)
- Página em Construção (Texto padrão)

### 12. Guia de Reprodução e Próximos Passos

Para reproduzir este projeto do zero:

1. **Setup Inicial:** Crie um novo projeto Next.js com TypeScript e Tailwind CSS (npx create-next-app@latest --typescript --tailwind).
2. **Estrutura de Pastas:** Crie a estrutura de pastas detalhada na Seção 6, incluindo a pasta global src/app/ e o módulo src/app/blogflorescerhumano/.
3. **Instalar Dependências:** Instale todas as dependências listadas no package.json fornecido (pnpm install ou npm install).
4. **Configurações:** Copie/adapte os arquivos de configuração: next.config.mjs, tailwind.config.ts, tsconfig.json, postcss.config.mjs, components.json. Configure as variáveis de ambiente (.env.local) com suas chaves Supabase.
5. **Estilos Globais:** Configure src/app/globals.css com as variáveis CSS de cores e estilos base.
6. **Supabase Setup:** Crie um projeto no Supabase. Execute o SQL da Seção 8.1 para criar as tabelas. **HABILITE RLS e configure as POLÍTICAS de segurança** conforme a Seção 8.2.
7. **Utilitários Globais:** Implemente src/lib/utils.ts (função cn) e src/lib/supabaseClient.ts.
8. **Componentes Globais (Shadcn/ui):** Instale/copie os componentes base de src/components/ui/ (ou use o CLI do Shadcn: npx shadcn-ui@latest add ...).
9. **Layout Raiz:** Implemente src/app/layout.tsx aplicando ThemeProvider, Analytics, CookieConsent.
10. **Landing Page:** Desenvolva src/app/page.tsx e os componentes específicos da landing page (em src/components/), utilizando a cópia da Seção 11.
11. **Módulo Blog - Layout:** Implemente src/app/blogflorescerhumano/layout.tsx com a Navbar e Footer específicos do blog (que devem ser visualmente coesos com os globais).
12. **Módulo Blog - Componentes UI (*Blog):** Crie os componentes em .../components/ui/ com sufixo Blog, replicando o estilo visual dos componentes globais.
13. **Módulo Blog - Serviços Supabase:** Implemente as funções em .../services/supabase/ para interagir com as tabelas do blog.
14. **Módulo Blog - Páginas/Templates:** Crie os page.tsx para as rotas estáticas e dinâmicas, utilizando os templates/ e buscando dados via services.
15. **Módulo Blog - Funcionalidades:** Implemente a busca, filtros, paginação, formulários (NewsletterFormBlog, ContactFormBlog), e integre o GiscusComments.
16. **Integrações Google:** Configure google-site-verification.tsx, schema-markup.tsx, robots.ts, e **adapte sitemap.ts para buscar dados do blog no Supabase**.
17. **Conteúdo Inicial:** Popule o Supabase com categorias, autor(es) e alguns artigos iniciais.
18. **Teste e Refine:** Teste exaustivamente a funcionalidade, responsividade, acessibilidade, performance e segurança (RLS).

---

Esta documentação abrangente deve fornecer um roteiro completo para a compreensão e reconstrução do projeto integrado psicologodanieldantas.com com o módulo blogflorescerhumano.

# **Documentação de Implementação: Módulo Blog "Florescer Humano"**

**Projeto:** Blog-site Daniel Dantas (Integração do Módulo Blog)

**Status:** Guia de Implementação

**Versão:** 1.0

**Data:** [Data Atual]

### 1. Introdução

Este documento fornece um guia passo a passo para implementar o módulo do blog "Florescer Humano" dentro da aplicação Next.js existente do site psicologodanieldantas.com. Pressupõe-se que a estrutura base do site principal (conforme descrito na análise e documentação) já esteja funcional.

O objetivo é integrar o blog de forma **modular, tecnicamente independente, mas visualmente coesa**, utilizando as tecnologias e padrões definidos (Next.js App Router, TypeScript, Tailwind CSS, Radix UI/Shadcn, Supabase, Giscus).

### 2. Pré-requisitos e Preparação

- **Ambiente de Desenvolvimento:** Certifique-se de ter Node.js (versão compatível com Next.js 15+), pnpm/npm/yarn configurados.
- **Projeto Existente:** Tenha o código fonte do site psicologodanieldantas.com clonado e funcional localmente.
- **Contas de Serviço:**
    - **Supabase:** Conta criada e um projeto Supabase disponível (pode ser o mesmo usado para outras partes do site, se houver, ou um novo). Tenha acesso às credenciais (URL e anon key, service_role key para funções seguras).
    - **GitHub:** Repositório GitHub criado ou existente onde as discussões/issues do Giscus serão armazenadas. Você precisará do nome do repositório, ID do repositório e ID da categoria de discussão.
- **Backup:** **FAÇA UM BACKUP COMPLETO** do seu projeto atual antes de iniciar modificações significativas. Use um sistema de controle de versão (Git) e crie um branch separado para a implementação do blog (ex: feature/implement-blog).

### 3. Etapa 1: Configuração do Banco de Dados (Supabase)

Esta etapa cria a estrutura de dados necessária para o conteúdo do blog.

1. **Acesse o Supabase:** Faça login no seu painel Supabase.
2. **SQL Editor:** Navegue até a seção "SQL Editor".
3. **Criar Tabelas:** Execute os scripts SQL definidos na **"Documentação do Esquema de Banco de Dados Supabase" (Seção 8.1 do documento mestre)** para criar as tabelas: categorias, subcategorias, autores, tags, artigos, artigos_tags, newsletter_assinantes. Execute também a função e os triggers para trigger_set_timestamp.
    - *(Copie e cole o SQL completo e comentado ou sem comentários da documentação anterior).*
4. **Habilitar RLS (Row Level Security):**
    - Vá para "Authentication" -> "Policies".
    - Para **CADA UMA** das tabelas criadas (categorias, subcategorias, autores, tags, artigos, artigos_tags, newsletter_assinantes), clique na tabela e ative o toggle "Enable RLS". **Este passo é CRUCIAL para a segurança.**
5. **Criar Políticas RLS:**
    - Ainda na seção "Policies", para cada tabela, crie as políticas de segurança necessárias usando o SQL Editor ou a interface gráfica. **Comece com as políticas mínimas para leitura pública e bloqueio de acesso não autorizado:**
        - **Leitura Pública (Permitir anon ler):**
            
                  `-- Para categorias, subcategorias, autores, tags:
            CREATE POLICY "Permitir leitura publica" ON nome_da_tabela FOR SELECT USING (true);`
            
        - **Leitura Condicional de Artigos (Permitir anon ler apenas publicados):**
            
                  `CREATE POLICY "Permitir leitura publica de artigos publicados" ON artigos FOR SELECT
            USING (status = 'publicado' AND data_publicacao IS NOT NULL AND data_publicacao <= now());`
            
            IGNORE_WHEN_COPYING_START
            
            content_copy  download  Use code [with caution](https://support.google.com/legal/answer/13505487). SQL
            
            IGNORE_WHEN_COPYING_END
            
        - **Bloqueio Total de Newsletter (Impedir anon de ler):**
            
                  `CREATE POLICY "Bloquear leitura publica" ON newsletter_assinantes FOR SELECT USING (false);`
            
            IGNORE_WHEN_COPYING_START
            
            content_copy  download  Use code [with caution](https://support.google.com/legal/answer/13505487). SQL
            
            IGNORE_WHEN_COPYING_END
            
        - **Bloqueio de Escrita Anônima (Impedir anon de escrever):** Para **todas** as tabelas, crie políticas para bloquear escrita pela API pública:
            
                  `CREATE POLICY "Bloquear escrita publica" ON nome_da_tabela FOR ALL USING (false) WITH CHECK (false);`
            
            IGNORE_WHEN_COPYING_START
            
            content_copy  download  Use code [with caution](https://support.google.com/legal/answer/13505487). SQL
            
            IGNORE_WHEN_COPYING_END
            
            *(Lembre-se: Você gerenciará o conteúdo via dashboard ou precisará de lógica de backend/funções seguras para escrita, especialmente para a newsletter).*
            
    - *(Consulte a "Documentação: Gerenciando Segurança com RLS" para políticas mais detalhadas, se necessário).*
6. **Variáveis de Ambiente:** Certifique-se de que as variáveis NEXT_PUBLIC_SUPABASE_URL e NEXT_PUBLIC_SUPABASE_ANON_KEY estejam definidas no seu arquivo .env.local.

### 4. Etapa 2: Criação da Estrutura de Pastas do Módulo Blog

1. **Navegue até src/app/:** No seu terminal, dentro da pasta do projeto.
2. **Crie a Pasta Principal do Módulo:**
    
          `mkdir blogflorescerhumano
    cd blogflorescerhumano`
    
    IGNORE_WHEN_COPYING_START
    
    content_copy  download  Use code [with caution](https://support.google.com/legal/answer/13505487). Bash
    
    IGNORE_WHEN_COPYING_END
    
3. **Crie as Subpastas Essenciais:**
    
          `mkdir components hooks services styles templates utils
    mkdir components/Article components/Category components/UI
    mkdir hooks/data hooks/ui
    mkdir services/supabase
    # Crie as pastas para rotas estáticas:
    mkdir categorias sobre materiais midias contato politica-privacidade em-construcao
    # Crie a estrutura para rotas dinâmicas:
    mkdir \[categoria\]
    mkdir \[categoria\]/\[slug\]`
    
    IGNORE_WHEN_COPYING_START
    
    content_copy  download  Use code [with caution](https://support.google.com/legal/answer/13505487). Bash
    
    IGNORE_WHEN_COPYING_END
    
4. **Crie Arquivos Base (Placeholders):** Crie arquivos vazios ou com conteúdo mínimo dentro das pastas recém-criadas, conforme a estrutura detalhada na **"Documentação: Arquitetura de Pastas e Arquivos - Projeto Completo" (Seção 5.2)**. Essenciais para começar:
    - src/app/blogflorescerhumano/layout.tsx
    - src/app/blogflorescerhumano/page.tsx
    - src/app/blogflorescerhumano/loading.tsx
    - src/app/blogflorescerhumano/error.tsx
    - src/app/blogflorescerhumano/not-found.tsx
    - Arquivos page.tsx básicos dentro das pastas de rotas estáticas (categorias, sobre, etc.).
    - Arquivos page.tsx, loading.tsx, error.tsx dentro das pastas de rotas dinâmicas ([categoria], [categoria]/[slug]).
5. **Crie a Pasta de Assets:**
    
          `# Navegue de volta para a raiz do projeto se necessário
    cd ../../..
    mkdir public/blogflorescerhumano`
    
    IGNORE_WHEN_COPYING_START
    
    content_copy  download  Use code [with caution](https://support.google.com/legal/answer/13505487). Bash
    
    IGNORE_WHEN_COPYING_END
    

### 5. Etapa 3: Configuração do Layout Específico do Blog

1. **Edite src/app/blogflorescerhumano/layout.tsx:**
    - Este layout será renderizado *dentro* do layout raiz (src/app/layout.tsx).
    - Importe e adicione os componentes NavbarBlog e FooterBlog (que você criará na Etapa 5).
    - Certifique-se de que ele aceite e renderize { children }.
    - Exemplo de estrutura básica:
        
              `import NavbarBlog from './components/NavbarBlog'; // Criar este componente
        import FooterBlog from './components/FooterBlog'; // Criar este componente
        import { ReactNode } from 'react';
        
        export default function BlogLayout({ children }: { children: ReactNode }) {
          return (
            <div className="flex flex-col min-h-screen"> {/* Exemplo de estrutura */}
              <NavbarBlog />
              <main className="flex-grow container mx-auto px-4 py-8"> {/* Ajuste conforme necessário */}
                {children}
              </main>
              <FooterBlog />
            </div>
          );
        }`
        
        IGNORE_WHEN_COPYING_START
        
        content_copy  download  Use code [with caution](https://support.google.com/legal/answer/13505487). TypeScript
        
        IGNORE_WHEN_COPYING_END
        

### 6. Etapa 4: Implementação dos Serviços Supabase

1. **Verifique o Cliente Global:** Certifique-se de que src/lib/supabaseClient.ts está configurado corretamente com as variáveis de ambiente e exporta o cliente Supabase.
2. **Implemente os Serviços do Blog:**
    - Crie os arquivos em src/app/blogflorescerhumano/services/supabase/ (articleService.ts, categoryService.ts, tagService.ts, authorService.ts, newsletterService.ts).
    - Dentro de cada arquivo, importe o cliente Supabase global: import { supabase } from '@/lib/supabaseClient'; (ajuste o path se necessário).
    - Implemente as funções de busca de dados necessárias, tratando erros. Exemplos:
        - **articleService.ts:**
            
                  `// Exemplo: Buscar artigos públicos para a homepage/listagem
            export const getPublicArticles = async (limit = 10, offset = 0) => {
              const { data, error } = await supabase
                .from('artigos')
                .select(`*, categoria:categorias(nome, slug), autor:autores(nome)`) // Exemplo com JOINs
                .eq('status', 'publicado')
                .lte('data_publicacao', new Date().toISOString())
                .order('data_publicacao', { ascending: false })
                .range(offset, offset + limit - 1);
            
              if (error) {
                console.error('Erro ao buscar artigos publicados:', error);
                return [];
              }
              return data || [];
            };
            
            // Exemplo: Buscar um artigo específico pelo slug e categoria
            export const getArticleBySlugAndCategory = async (categorySlug: string, articleSlug: string) => {
              const { data, error } = await supabase
                .from('artigos')
                .select(`*, categoria:categorias!inner(slug), autor:autores(nome, foto_arquivo), tags:tags(*)`)
                .eq('slug', articleSlug)
                .eq('categoria.slug', categorySlug) // Filtrando pelo slug da categoria via JOIN
                .eq('status', 'publicado')
                .lte('data_publicacao', new Date().toISOString())
                .single(); // Espera um único resultado
            
               if (error) {
                 console.error(`Erro ao buscar artigo ${categorySlug}/${articleSlug}:`, error);
                 return null;
               }
               return data;
            };
            // ... outras funções (getArticlesByCategory, getArticlesByTag, etc.)`
            
            IGNORE_WHEN_COPYING_START
            
            content_copy  download  Use code [with caution](https://support.google.com/legal/answer/13505487). TypeScript
            
            IGNORE_WHEN_COPYING_END
            
        - **categoryService.ts:** getCategories(), getCategoryBySlug().
        - **tagService.ts:** getTags(), getArticlesByTag().
        - **authorService.ts:** getAuthorById().
        - **newsletterService.ts:** *Importante:* A função subscribeToNewsletter **NÃO** deve fazer um insert direto usando a anon key. Ela deve chamar uma API Route ou Server Action segura que use a service_role key ou chame uma Edge Function.

### 7. Etapa 5: Criação dos Componentes de UI do Blog (*Blog.tsx)

1. **Identifique Componentes Base:** Olhe para src/components/ui/ do site principal (Button, Card, Input, etc.).
2. **Crie Versões do Blog:** Na pasta src/app/blogflorescerhumano/components/ui/, crie os arquivos correspondentes com o sufixo Blog (ex: ButtonBlog.tsx).
3. **Reutilize Lógica e Estilos:**
    - Importe a função cn de src/lib/utils.ts.
    - Importe as variants (CVA) do componente base, se aplicável (ex: import { buttonVariants } from '@/components/ui/button';).
    - Replique a estrutura do componente base, aplicando as mesmas classes Tailwind e variantes para garantir coesão visual.
    - Exemplo conceitual (ButtonBlog.tsx):
        
              `import * as React from 'react';
        import { Slot } from '@radix-ui/react-slot';
        import { cva, type VariantProps } from 'class-variance-authority';
        import { cn } from '@/lib/utils'; // Importar o CN GLOBAL
        // Importar as variantes do botão GLOBAL (ou replicá-las se preferir total isolamento)
        import { buttonVariants } from '@/components/ui/button'; // Caminho para o botão base
        
        // Definir interface de Props (pode ser idêntica à do Button base)
        export interface ButtonBlogProps
          extends React.ButtonHTMLAttributes<HTMLButtonElement>,
            VariantProps<typeof buttonVariants> { // Reutiliza as variantes
          asChild?: boolean;
        }
        
        const ButtonBlog = React.forwardRef<HTMLButtonElement, ButtonBlogProps>(
          ({ className, variant, size, asChild = false, ...props }, ref) => {
            const Comp = asChild ? Slot : 'button';
            return (
              <Comp
                // Aplica as variantes e permite overrides via className
                className={cn(buttonVariants({ variant, size, className }))}
                ref={ref}
                {...props}
              />
            );
          }
        );
        ButtonBlog.displayName = 'ButtonBlog';
        
        export { ButtonBlog };`
        
        IGNORE_WHEN_COPYING_START
        
        content_copy  download  Use code [with caution](https://support.google.com/legal/answer/13505487). TypeScript
        
        IGNORE_WHEN_COPYING_END
        
4. **Crie os Componentes Necessários:** Foque primeiro nos componentes mais usados (Button, Card, Input, Label, Tag/Badge).

### 8. Etapa 6: Implementação dos Componentes Específicos do Blog

1. **Desenvolva os Componentes Funcionais:** Crie os componentes em src/app/blogflorescerhumano/components/ (ex: ArticleCardBlog.tsx, ArticleListBlog.tsx, CategoryLabelBlog.tsx, AuthorInfoBlog.tsx, ArticleMetadataBlog.tsx).
2. **Composição:** Use os componentes de UI (*Blog.tsx) recém-criados para montar esses componentes mais complexos.
    - Ex: ArticleCardBlog usará CardBlog, CategoryLabelBlog, ArticleMetadataBlog, next/image.

### 9. Etapa 7: Construção dos Templates de Página do Blog

1. **Crie os Templates:** Em src/app/blogflorescerhumano/templates/, crie os arquivos ArticleTemplateBlog.tsx, CategoryTemplateBlog.tsx, StaticPageTemplateBlog.tsx.
2. **Estruture o Layout:** Defina a estrutura HTML e de layout principal para cada tipo de página, organizando onde o conteúdo principal, sidebars (se houver), metadados, comentários, etc., serão renderizados.
3. **Use Componentes:** Importe e posicione os componentes específicos do blog (ex: ArticleDetailBlog, ArticleListBlog, AuthorInfoBlog) dentro dos templates.
4. **Props:** Defina as props que cada template receberá (ex: ArticleTemplateBlog recebe o objeto artigo completo).

### 10. Etapa 8: Implementação das Páginas (Rotas) do Blog

1. **Página Inicial do Blog (.../page.tsx):**
    - Marcar como async.
    - Chamar getPublicArticles() do articleService.
    - Passar os dados para ArticleListBlog ou um template específico.
2. **Página de Categoria (.../[categoria]/page.tsx):**
    - Marcar como async.
    - Acessar params.categoria.
    - Chamar uma função do articleService para buscar artigos por slug de categoria.
    - Passar os dados para ArticleListBlog ou CategoryTemplateBlog.
3. **Página de Artigo (.../[categoria]/[slug]/page.tsx):**
    - Marcar como async.
    - Acessar params.categoria e params.slug.
    - Chamar getArticleBySlugAndCategory() do articleService.
    - Tratar caso o artigo não seja encontrado (ex: notFound() do Next.js).
    - Passar os dados do artigo para ArticleTemplateBlog ou ArticleDetailBlog.
    - Renderizar o componente GiscusComments nesta página.
    - **Gerar Metadados:** Implementar a função generateMetadata para definir title e description dinamicamente com base nos dados do artigo (usar seoUtils.ts).
4. **Páginas Estáticas (sobre/page.tsx, etc.):**
    - Criar o conteúdo estático ou buscar de uma fonte se necessário.
    - Utilizar StaticPageTemplateBlog se aplicável.

### 11. Etapa 9: Integração do Giscus

1. **Configure o Repositório GitHub:** Habilite "Discussions" no repositório escolhido. Crie uma categoria para os comentários do blog. Obtenha o ID do Repositório e o ID da Categoria.
2. **Crie GiscusComments.tsx:** Em .../components/, crie o componente conforme exemplo anterior, marcando-o como 'use client' e inserindo suas credenciais do repositório/categoria.
3. **Adicione ao Template/Página:** Inclua <GiscusComments /> no local desejado dentro de ArticleTemplateBlog.tsx ou diretamente em .../[categoria]/[slug]/page.tsx.

### 12. Etapa 10: Implementação dos Formulários (Contato, Newsletter)

1. **Crie os Componentes:** Desenvolva NewsletterFormBlog.tsx e ContactFormBlog.tsx em .../components/.
2. **Marque como 'use client':** Eles precisam de interatividade.
3. **Use react-hook-form e zod:** Para gerenciamento de estado e validação (seguindo o padrão do site principal).
4. **Submissão Segura:**
    - **Contato:** Pode enviar via API Route ou Server Action que talvez envie um e-mail.
    - **Newsletter:** **NÃO FAÇA supabase.from('newsletter_assinantes').insert(...) diretamente do Client Component com a anon key!** Crie uma **Server Action** ou uma **API Route (src/app/api/newsletter/subscribe/route.ts)** que receba o e-mail, valide-o e use o **cliente Supabase com a service_role key** (ou chame uma Edge Function segura) para inserir o e-mail no banco de dados. Implemente lógica de Double Opt-In se desejado.
5. **Adicione às Páginas:** Coloque os formulários nas páginas relevantes (ex: ContactFormBlog em .../contato/page.tsx, NewsletterFormBlog no Footer ou em locais estratégicos).

### 13. Etapa 11: Atualização de Arquivos Globais (Sitemap, Robots)

1. **src/app/sitemap.ts:**
    - **Modifique a função:** Torne-a async.
    - **Importe Serviços:** Importe categoryService e articleService.
    - **Busque Dados do Blog:** Chame getCategories() e getPublicArticles() (ou uma função similar que retorne apenas slugs e data_atualizacao).
    - **Mapeie URLs:** Adicione as URLs das categorias do blog (/blogflorescerhumano/${categoria.slug}) e dos artigos do blog (/blogflorescerhumano/${artigo.categoria.slug}/${artigo.slug}) à lista de URLs do sitemap, junto com as URLs do site principal. Use data_atualizacao para lastModified.
2. **src/app/robots.ts:**
    - **Verifique:** Garanta que não há regras Disallow: bloqueando /blogflorescerhumano/. Se o acesso for permitido por padrão (Allow: /), nenhuma mudança pode ser necessária. Adicione a linha Sitemap: [URL completa do seu sitemap.xml].

### 14. Etapa 12: Gerenciamento de Assets (Imagens)

1. **Adicione Imagens:** Coloque as imagens de capa dos artigos e fotos de autores (se específicas do blog) dentro de public/blogflorescerhumano/.
2. **Referencie no Banco:** Na tabela artigos, preencha a coluna imagem_capa_arquivo apenas com o nome do arquivo (ex: "meu-artigo.png"). Faça o mesmo para foto_arquivo na tabela autores se aplicável.
3. **Use next/image:** Nos componentes (ex: ArticleCardBlog, ArticleDetailBlog, AuthorInfoBlog), use o componente <Image> do Next.js, construindo o src dinamicamente:
    
          `import Image from 'next/image';
    // ... dentro do componente ...
    <Image
      src={`/blogflorescerhumano/${artigo.imagem_capa_arquivo}`} // Constrói o caminho
      alt={`Capa do artigo: ${artigo.titulo}`}
      width={800} // Defina tamanhos apropriados
      height={400}
      // priority={true} // Se for imagem principal da página (LCP)
    />`
    
    IGNORE_WHEN_COPYING_START
    
    content_copy  download  Use code [with caution](https://support.google.com/legal/answer/13505487). Jsx
    
    IGNORE_WHEN_COPYING_END
    

### 15. Etapa 13: Estilização Adicional

1. **Tailwind:** Use as classes utilitárias para a maior parte da estilização, garantindo o uso dos tokens globais.
2. **CSS Modules:** Se precisar de estilos mais complexos ou encapsulados para um componente específico do blog, crie um arquivo NomeDoComponente.module.css na mesma pasta do componente e importe-o.
3. **blog-globals.css:** Use src/app/blogflorescerhumano/styles/blog-globals.css (e importe-o em blogflorescerhumano/layout.tsx) apenas se houver estilos que precisam ser aplicados a *todas* as páginas do blog, mas *não* ao site principal.

### 16. Etapa 14: Testes e Refinamento

1. **Teste Funcional:** Navegue por todas as páginas do blog, teste filtros, busca, formulários, comentários.
2. **Teste de Responsividade:** Verifique a aparência e funcionalidade em diferentes tamanhos de tela (use as DevTools do navegador).
3. **Teste de Acessibilidade:** Use ferramentas automatizadas (Lighthouse, Axe) e faça testes manuais (navegação por teclado, leitores de tela básicos). Verifique contrastes.
4. **Teste de Segurança (RLS):** Use o SQL Editor do Supabase ou chamadas de API para simular acesso anônimo e garantir que apenas dados públicos são retornados e que a escrita está bloqueada. **Teste especialmente a tabela newsletter_assinantes**.
5. **Teste de Performance:** Analise o tempo de carregamento das páginas (Lighthouse, PageSpeed Insights). Verifique se as imagens estão otimizadas e se o lazy loading (mapas, imagens) está funcionando.
6. **Refinamento:** Ajuste estilos, componentes e lógica com base nos testes.

---

Seguindo estas etapas detalhadas, você conseguirá implementar o módulo "Florescer Humano" de forma organizada, segura e coesa dentro do seu projeto existente. Lembre-se de trabalhar de forma incremental e testar frequentemente. Boa implementação!