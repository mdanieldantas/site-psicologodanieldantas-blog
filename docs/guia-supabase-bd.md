# **Documentação do Esquema de Banco de Dados Supabase para o Blog "Florescer Humano"**

### 1. Introdução

Este documento descreve a estrutura do banco de dados PostgreSQL gerenciado pelo Supabase, projetado para suportar o conteúdo e as funcionalidades do blog "Florescer Humano". O esquema visa organizar os dados de forma eficiente, segura e escalável, alinhando-se com a Arquitetura da Informação e os requisitos funcionais definidos para o blog.

### 2. Princípios e Convenções Gerais

- **Segurança (RLS):** A segurança é primordial. **Row Level Security (RLS)** será habilitada para *todas* as tabelas. Políticas específicas definirão quem pode acessar (ler) e modificar (escrever) os dados em cada tabela, garantindo que apenas usuários/roles autorizados possam interagir com os dados.
- **Chaves Primárias:** Utilizamos bigint generated by default as identity como chave primária padrão. Isso fornece um identificador numérico único e auto-incremental para cada registro.
- **Timestamps:** As colunas data_criacao e data_atualizacao usam o tipo timestamptz (timestamp with time zone) para registrar informações temporais precisas. A coluna data_atualizacao é atualizada automaticamente em cada operação UPDATE através de um trigger e uma função auxiliar (trigger_set_timestamp).
- **Slugs:** Colunas chamadas slug são usadas para criar identificadores únicos e amigáveis para URLs (ex: /categorias/autoconhecimento, /artigos/autoconhecimento/entendendo-a-autoestima). Eles são essenciais para SEO e roteamento no Next.js. Geralmente possuem uma restrição UNIQUE.
- **Gerenciamento de Imagens:** Conforme definido, as imagens (capas de artigos, fotos de autores) **não são armazenadas no banco de dados**. Elas residem na pasta /public/ do projeto Next.js. As colunas *_arquivo (ex: imagem_capa_arquivo, foto_arquivo) no banco de dados armazenam **apenas o nome do arquivo** correspondente (ex: "meu-artigo.png"). A aplicação front-end é responsável por construir o caminho completo para exibir a imagem (ex: /blogflorescerhumano/meu-artigo.png).
- **Relacionamentos:** Chaves estrangeiras (references) são usadas para estabelecer e impor relacionamentos entre tabelas (ex: um artigo pertence a uma categoria e um autor). As cláusulas ON DELETE definem o comportamento quando um registro referenciado é excluído (cascade: exclui registros dependentes; restrict: impede a exclusão se houver dependentes; set null: define a chave estrangeira como nula).
- **Validação:** Restrições CHECK são usadas para garantir que os dados em certas colunas atendam a critérios específicos (ex: status em artigos, formato de email em newsletter_assinantes).

### 3. Detalhamento das Tabelas

### 3.1. categorias

- **Propósito:** Armazena as categorias temáticas principais do blog (ex: "Autoconhecimento", "Psicologia Humanista"). Essencial para a organização e navegação primária.
- **Colunas Chave:**
    - id: Identificador único da categoria.
    - nome: Nome da categoria exibido ao usuário (único).
    - slug: Identificador para URL (único).
    - descricao: Texto opcional descrevendo a categoria.
- **Relacionamentos:** Referenciada por subcategorias e artigos.
- **RLS:** Leitura pública, escrita restrita.

### 3.2. subcategorias

- **Propósito:** Permite uma classificação mais específica dentro de uma categoria principal (ex: "Mindfulness" dentro de "Bem-Estar Emocional").
- **Colunas Chave:**
    - id: Identificador único da subcategoria.
    - nome: Nome da subcategoria.
    - slug: Identificador para URL (único).
    - categoria_id: Chave estrangeira que liga à tabela categorias (define a categoria pai).
    - descricao: Texto opcional.
- **Relacionamentos:** Refere-se a categorias. Referenciada por artigos.
- **RLS:** Leitura pública, escrita restrita.

### 3.3. autores

- **Propósito:** Guarda informações sobre os autores dos artigos. Inicialmente pode conter apenas Daniel Dantas, mas permite adicionar outros colaboradores.
- **Colunas Chave:**
    - id: Identificador único do autor.
    - nome: Nome do autor.
    - biografia: Texto sobre o autor.
    - foto_arquivo: **Nome do arquivo** da foto do autor (localizada na pasta /public/).
    - perfil_academico_url: Link opcional para perfil externo.
- **Relacionamentos:** Referenciada por artigos.
- **RLS:** Leitura pública, escrita restrita.

### 3.4. tags

- **Propósito:** Permite etiquetar artigos com tópicos específicos que podem atravessar múltiplas categorias (ex: "Carl Rogers", "Resiliência"). Facilita a descoberta de conteúdo relacionado de forma flexível.
- **Colunas Chave:**
    - id: Identificador único da tag.
    - nome: Nome da tag (único).
    - slug: Identificador para URL/filtro (único).
- **Relacionamentos:** Associada a artigos através da tabela de junção artigos_tags.
- **RLS:** Leitura pública, escrita restrita.

### 3.5. artigos

- **Propósito:** Tabela central que armazena cada post individual do blog. Contém o conteúdo principal e metadados essenciais.
- **Colunas Chave:**
    - id: Identificador único do artigo.
    - titulo: Título principal do artigo.
    - slug: Identificador único para a URL do artigo.
    - conteudo: O corpo principal do artigo (texto, Markdown, HTML ou JSONB).
    - resumo: Pequeno trecho para pré-visualizações e SEO.
    - imagem_capa_arquivo: **Nome do arquivo** da imagem de capa (localizada em /public/blogflorescerhumano/).
    - categoria_id: Link para a categoria principal do artigo.
    - subcategoria_id: Link opcional para a subcategoria.
    - autor_id: Link para o autor do artigo.
    - data_publicacao: Data/hora em que o artigo deve se tornar visível publicamente. Permite agendamento.
    - status: Controla a visibilidade ('rascunho', 'publicado', 'arquivado').
    - fts: (tipo `tsvector`) Coluna especial para Busca Full-Text, geralmente populada automaticamente via trigger combinando `titulo` e `conteudo`. Usada para otimizar buscas textuais.
- **Relacionamentos:** Refere-se a categorias, subcategorias, autores. Associada a tags via artigos_tags.
- **RLS:** Política complexa necessária. Leitura pública apenas para artigos com status = 'publicado' e data_publicacao no passado. Acesso a rascunhos/arquivados restrito. Escrita restrita.

### 3.6. artigos_tags

- **Propósito:** Tabela de junção que implementa a relação muitos-para-muitos entre artigos e tags. Permite que um artigo tenha múltiplas tags e uma tag seja usada em múltiplos artigos.
- **Colunas Chave:**
    - artigo_id: Chave estrangeira para artigos.
    - tag_id: Chave estrangeira para tags.
    - (artigo_id, tag_id): Chave primária composta, garantindo unicidade da associação.
- **Relacionamentos:** Liga artigos e tags.
- **RLS:** Acesso de leitura deve espelhar o acesso ao artigo correspondente. Escrita restrita.

### 3.7. newsletter_assinantes

- **Propósito:** Armazena os endereços de e-mail de usuários que optaram por receber a newsletter. Contém dados pessoais sensíveis.
- **Colunas Chave:**
    - id: Identificador único do assinante.
    - email: Endereço de e-mail (único, com validação de formato).
    - status_confirmacao: Indica se o e-mail foi confirmado (para Double Opt-In).
    - token_confirmacao: Token temporário para o processo de confirmação.
    - data_confirmacao: Timestamp da confirmação.
- **Relacionamentos:** Nenhuma chave estrangeira direta para outras tabelas de conteúdo.
- **RLS:** **Extremamente restrita.** Nenhuma leitura ou escrita pública direta permitida. Operações devem ser feitas via funções seguras ou APIs de backend. Acesso de leitura restrito a administradores.

### 4. Objetos Auxiliares

- **Função trigger_set_timestamp() e Triggers Associados:**
    - **Propósito:** Automatizam a atualização da coluna data_atualizacao em tabelas como categorias, subcategorias, autores e artigos sempre que um registro é modificado (via UPDATE). Isso garante que se tenha um registro preciso da última modificação sem a necessidade de atualizar manualmente o campo na aplicação.

### 5. Conclusão

Este esquema de banco de dados fornece uma fundação sólida para o "Blog Florescer Humano". Ele organiza o conteúdo de maneira lógica, permite flexibilidade através de tags, gerencia informações de autores e categorias, e inclui uma estrutura para a funcionalidade de newsletter, ao mesmo tempo em que considera as melhores práticas de segurança e o gerenciamento de imagens fora do banco de dados. Os próximos passos essenciais incluem a implementação deste esquema no Supabase, a habilitação rigorosa do RLS e a definição das políticas de segurança apropriadas para cada tabela.

```jsx
-- ## TABELAS PRINCIPAIS DE CONTEÚDO ##

CREATE TABLE categorias (
  id bigint generated by default as identity primary key,
  nome text not null unique,
  slug text not null unique,
  descricao text,
  data_criacao timestamptz default now() not null,
  data_atualizacao timestamptz default now() not null
);

CREATE TABLE subcategorias (
  id bigint generated by default as identity primary key,
  nome text not null,
  slug text not null unique,
  categoria_id bigint not null references categorias(id) on delete cascade,
  descricao text,
  data_criacao timestamptz default now() not null,
  data_atualizacao timestamptz default now() not null
);

CREATE TABLE autores (
  id bigint generated by default as identity primary key,
  nome text not null,
  biografia text,
  foto_arquivo text,
  perfil_academico_url text,
  data_criacao timestamptz default now() not null,
  data_atualizacao timestamptz default now() not null
);

CREATE TABLE tags (
  id bigint generated by default as identity primary key,
  nome text not null unique,
  slug text not null unique,
  data_criacao timestamptz default now() not null
);

CREATE TABLE artigos (
  id bigint generated by default as identity primary key,
  titulo text not null,
  slug text not null unique,
  conteudo text not null,
  resumo text,
  imagem_capa_arquivo text,
  categoria_id bigint not null references categorias(id) on delete restrict,
  subcategoria_id bigint references subcategorias(id) on delete set null,
  autor_id bigint not null references autores(id) on delete restrict,
  data_publicacao timestamptz,
  status text not null default 'rascunho' check (status in ('rascunho', 'publicado', 'arquivado')),
  data_criacao timestamptz default now() not null,
  data_atualizacao timestamptz default now() not null
);

CREATE TABLE artigos_tags (
  artigo_id bigint not null references artigos(id) on delete cascade,
  tag_id bigint not null references tags(id) on delete cascade,
  primary key (artigo_id, tag_id)
);

-- ## TABELA DE FUNCIONALIDADES ADICIONAIS ##

CREATE TABLE newsletter_assinantes (
  id bigint generated by default as identity primary key,
  email text not null unique check (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'),
  data_inscricao timestamptz default now() not null,
  status_confirmacao text not null default 'pendente' check (status_confirmacao in ('pendente', 'confirmado')),
  token_confirmacao text unique,
  data_confirmacao timestamptz
);

-- ## Funções Auxiliares (Opcional, mas recomendado para `data_atualizacao`) ##

create or replace function trigger_set_timestamp()
returns trigger as $$
begin
  new.data_atualizacao = now();
  return new;
end;
$$ language plpgsql;

-- Triggers
create trigger set_timestamp_categorias before update on categorias for each row execute procedure trigger_set_timestamp();
create trigger set_timestamp_subcategorias before update on subcategorias for each row execute procedure trigger_set_timestamp();
create trigger set_timestamp_autores before update on autores for each row execute procedure trigger_set_timestamp();
create trigger set_timestamp_artigos before update on artigos for each row execute procedure trigger_set_timestamp();

```

Okay, vamos criar uma documentação detalhada sobre como gerenciar a segurança das suas tabelas Supabase usando **Row Level Security (RLS)**, focando especificamente no esquema que definimos para o blog "Florescer Humano".

---

## **Documentação: Gerenciando Segurança com Row Level Security (RLS) no Supabase**

### 1. O que é Row Level Security (RLS)?

Row Level Security (RLS) é um recurso fundamental do PostgreSQL (o banco de dados por trás do Supabase) que permite controlar **quais linhas (rows)** em uma tabela um usuário específico pode acessar ou modificar (inserir, atualizar, deletar).

Em vez de apenas controlar o acesso à tabela inteira (GRANT/REVOKE), RLS permite definir regras (chamadas **Políticas**) baseadas nas características da linha ou no usuário que está tentando acessá-la.

**Por que é crucial para o seu blog?**

- **Segurança Granular:** Garante que usuários anônimos (visitantes do blog) só possam ler artigos publicados, enquanto administradores ou editores possam gerenciar rascunhos e outros conteúdos.
- **Proteção de Dados:** Impede o acesso não autorizado a dados sensíveis, como a lista de assinantes da newsletter.
- **Força a Autorização no Banco:** As regras são aplicadas diretamente no banco de dados, oferecendo uma camada de segurança robusta, mesmo que haja falhas na lógica da sua aplicação front-end ou back-end.
- **Integração com Supabase Auth:** O Supabase facilita o uso de RLS, fornecendo funções úteis dentro das políticas para identificar o usuário autenticado (auth.uid(), auth.role(), auth.jwt(), etc.).

### 2. Habilitando RLS nas Tabelas

**Passo Fundamental:** Antes de criar qualquer política, você **PRECISA** habilitar RLS para cada tabela que deseja proteger.

1. **Acesse o Painel Supabase:** Vá para o seu projeto no Supabase.
2. **Navegue até Autenticação:** No menu lateral esquerdo, clique em "Authentication".
3. **Acesse a Aba Policies:** Dentro da seção de Autenticação, clique na aba "Policies".
4. **Selecione a Tabela:** Você verá uma lista das suas tabelas. Encontre a tabela para a qual deseja habilitar RLS (ex: artigos).
5. **Clique em "Enable RLS":** Haverá um botão ou toggle para habilitar RLS naquela tabela específica. Clique nele.
6. **Confirme:** Pode ser necessário confirmar a ação.

**IMPORTANTE:** Quando você habilita RLS em uma tabela sem nenhuma política definida, o comportamento padrão é **NEGAR TODO O ACESSO** (SELECT, INSERT, UPDATE, DELETE) para todos os usuários, exceto superusuários do banco. Isso é uma medida de segurança "fail-safe". Portanto, **após habilitar RLS, você deve criar políticas para permitir o acesso desejado.**

**Recomendação:** Habilite RLS para **TODAS** as tabelas que criamos (categorias, subcategorias, autores, tags, artigos, artigos_tags, newsletter_assinantes).

### 3. Entendendo as Políticas RLS

Uma política RLS é basicamente uma regra SQL associada a uma tabela que define as condições para permitir uma operação específica (SELECT, INSERT, UPDATE, DELETE) para um determinado role (ou para public, que inclui usuários anônimos e autenticados).

Componentes de uma Política:

- **Nome:** Um nome descritivo para a política (ex: "Permitir leitura pública de artigos publicados").
- **Tabela:** A tabela à qual a política se aplica (ex: artigos).
- **Comando:** A operação SQL que a política controla (SELECT, INSERT, UPDATE, DELETE, ou ALL).
- **Role:** O(s) role(s) aos quais a política se aplica (ex: public, authenticated, anon, ou roles customizados).
- **USING (Expressão):** Uma expressão SQL que retorna boolean. É avaliada para **linhas existentes** na tabela. Se a expressão retornar true para uma linha, a operação (SELECT, UPDATE, DELETE) é permitida naquela linha para o role especificado.
- **WITH CHECK (Expressão):** Uma expressão SQL que retorna boolean. É avaliada para **linhas que estão sendo inseridas ou atualizadas**. Se a expressão retornar true, a operação (INSERT, UPDATE) é permitida. Garante que novas linhas ou modificações cumpram a regra.

**Como Supabase usa Roles:**

- anon: Representa usuários não autenticados que usam a chave anon da API.
- authenticated: Representa usuários autenticados (logados) que usam a chave anon da API.
- service_role: Representa acesso com a chave service_role (geralmente usada no backend), que **ignora** as políticas RLS por padrão. Use com cuidado!
- (Você pode criar roles customizados no PostgreSQL se precisar de granularidade maior, mas anon e authenticated cobrem muitos casos).

### 4. Padrões Comuns de Políticas RLS

Vamos ver alguns exemplos de políticas comuns que aplicaremos ao nosso blog:

**a) Leitura Pública:** Permitir que qualquer pessoa (anônima ou autenticada) leia os dados.

```sql
      -- Exemplo: Permitir leitura pública de categorias
CREATE POLICY "Permitir leitura publica de categorias"
ON categorias
FOR SELECT -- Aplica-se apenas à operação SELECT
USING (true); -- A condição é sempre verdadeira, permitindo ver todas as linhas
```

**b) Leitura Autenticada:** Permitir que apenas usuários logados leiam os dados.

```sql
      -- Exemplo (Não aplicável diretamente ao nosso schema público, mas ilustrativo)
-- CREATE POLICY "Permitir leitura apenas para usuários logados"
-- ON alguma_tabela_privada
-- FOR SELECT
-- USING (auth.role() = 'authenticated'); -- Permite SELECT se o role do usuário for 'authenticated'
```

**c) Leitura Pública Condicional:** Permitir que qualquer pessoa leia *apenas algumas* linhas que atendam a certas condições.

```sql
      -- Exemplo: Permitir leitura pública de artigos publicados e dentro da data
CREATE POLICY "Permitir leitura publica de artigos publicados"
ON artigos
FOR SELECT
USING (
  status = 'publicado' AND                  -- A linha deve ter status 'publicado'
  data_publicacao IS NOT NULL AND           -- A data de publicação não pode ser nula
  data_publicacao <= now()                  -- A data de publicação deve ser no passado ou agora
);
```

**d) Escrita Restrita (Ex: Apenas Editores/Admins):** Permitir operações de escrita apenas para usuários com um role específico (ou ID específico). *Nota: Supabase por padrão não tem roles 'editor' ou 'admin'. Você precisaria gerenciar isso, talvez com uma tabela de usuários/roles customizada ou usando metadados no auth.users.* Uma abordagem simples é restringir ao role authenticated e confiar que apenas usuários confiáveis (você, colaboradores) terão contas e acesso à interface de gerenciamento.

```sql
      -- Exemplo SIMPLIFICADO: Permitir escrita em categorias APENAS para usuários logados
-- (Pressupõe que SÓ usuários confiáveis podem se logar e acessar a interface de admin)
CREATE POLICY "Permitir escrita em categorias para usuarios logados"
ON categorias
FOR ALL -- Aplica-se a INSERT, UPDATE, DELETE
USING (auth.role() = 'authenticated')     -- Condição para UPDATE/DELETE (só pode modificar/deletar se estiver logado)
WITH CHECK (auth.role() = 'authenticated'); -- Condição para INSERT/UPDATE (só pode inserir/modificar se estiver logado)

-- Abordagem mais robusta envolveria verificar um role customizado ou ID específico.
```

**e) Políticas Super Restritas (Ex: Newsletter):** Bloquear quase todo o acesso direto.

```sql
      -- Exemplo: Política para newsletter_assinantes
-- 1. Bloquear TODA leitura via API pública
CREATE POLICY "Bloquear leitura publica de assinantes"
ON newsletter_assinantes
FOR SELECT
USING (false); -- Nenhuma linha satisfaz 'false', bloqueando SELECTs públicos

-- 2. Bloquear TODA escrita direta via API pública (INSERT/UPDATE/DELETE)
-- (Não é estritamente necessário se não houver política de INSERT/UPDATE/DELETE, mas explícito)
CREATE POLICY "Bloquear escrita publica de assinantes"
ON newsletter_assinantes
FOR ALL -- INSERT, UPDATE, DELETE
USING (false)
WITH CHECK (false);

-- NOTA: A inserção de novos assinantes DEVE ser feita através de:
--   a) Uma Edge Function do Supabase que use a 'service_role' key (que ignora RLS).
--   b) Uma API backend sua que use a 'service_role' key.
--   c) Funções PostgreSQL com `SECURITY DEFINER` (mais avançado).
```

### 5. Aplicando Políticas ao Esquema do Blog "Florescer Humano"

Aqui está um conjunto sugerido de políticas iniciais para o seu esquema. **Adapte conforme sua necessidade de roles específicos (admin/editor) se for o caso.**

```sql
      -- HABILITE RLS EM TODAS AS TABELAS PRIMEIRO!

-- === Políticas para Tabelas de Conteúdo Público ===

-- categorias, subcategorias, autores, tags: Leitura pública, escrita restrita a usuários logados (simplificado)
-- (Repetir para cada tabela: categorias, subcategorias, autores, tags)
CREATE POLICY "Permitir leitura publica" ON categorias FOR SELECT USING (true);
CREATE POLICY "Permitir escrita para logados" ON categorias FOR ALL USING (auth.role() = 'authenticated') WITH CHECK (auth.role() = 'authenticated');

CREATE POLICY "Permitir leitura publica" ON subcategorias FOR SELECT USING (true);
CREATE POLICY "Permitir escrita para logados" ON subcategorias FOR ALL USING (auth.role() = 'authenticated') WITH CHECK (auth.role() = 'authenticated');

CREATE POLICY "Permitir leitura publica" ON autores FOR SELECT USING (true);
CREATE POLICY "Permitir escrita para logados" ON autores FOR ALL USING (auth.role() = 'authenticated') WITH CHECK (auth.role() = 'authenticated');

CREATE POLICY "Permitir leitura publica" ON tags FOR SELECT USING (true);
CREATE POLICY "Permitir escrita para logados" ON tags FOR ALL USING (auth.role() = 'authenticated') WITH CHECK (auth.role() = 'authenticated');

-- artigos: Leitura pública condicional, escrita restrita a usuários logados (simplificado)
CREATE POLICY "Permitir leitura publica de artigos publicados" ON artigos FOR SELECT USING (status = 'publicado' AND data_publicacao IS NOT NULL AND data_publicacao <= now());
CREATE POLICY "Permitir escrita para logados" ON artigos FOR ALL USING (auth.role() = 'authenticated') WITH CHECK (auth.role() = 'authenticated');
-- Opcional: Permitir que usuários logados (editores) vejam rascunhos
-- CREATE POLICY "Permitir leitura de rascunhos para logados" ON artigos FOR SELECT USING (auth.role() = 'authenticated');

-- artigos_tags: Acesso espelha 'artigos', escrita restrita
-- (Política de SELECT aqui pode ser complexa se precisar verificar o status do artigo relacionado)
-- Abordagem simples: Permitir leitura se logado (assumindo que a API filtra quais artigos mostrar)
CREATE POLICY "Permitir leitura para logados" ON artigos_tags FOR SELECT USING (auth.role() = 'authenticated');
-- Abordagem mais segura (requer consulta):
-- CREATE POLICY "Permitir leitura se artigo publico" ON artigos_tags FOR SELECT
-- USING (
--  EXISTS (
--    SELECT 1 FROM artigos a
--    WHERE a.id = artigos_tags.artigo_id
--    AND a.status = 'publicado'
--    AND a.data_publicacao IS NOT NULL
--    AND a.data_publicacao <= now()
--  )
-- );
CREATE POLICY "Permitir escrita para logados" ON artigos_tags FOR ALL USING (auth.role() = 'authenticated') WITH CHECK (auth.role() = 'authenticated');

-- === Políticas para Tabelas Sensíveis ===

-- newsletter_assinantes: SEM acesso público direto
CREATE POLICY "Bloquear leitura publica" ON newsletter_assinantes FOR SELECT USING (false);
CREATE POLICY "Bloquear escrita publica" ON newsletter_assinantes FOR ALL USING (false) WITH CHECK (false);
-- (Lembre-se: Operações nesta tabela via backend/functions com service_role)
-- Opcional: Permitir que um admin leia
-- CREATE POLICY "Permitir leitura para admin" ON newsletter_assinantes FOR SELECT USING (auth.role() = 'admin'); -- Requer role 'admin'
```

### 6. Como Criar as Políticas no Supabase

1. **Use o SQL Editor:**
    - Vá para a seção "SQL Editor" no painel do Supabase.
    - Clique em "+ New query".
    - Cole os comandos CREATE POLICY desejados.
    - Execute a query. Repita para todas as políticas.
2. **Use a Interface Gráfica (para políticas simples):**
    - Vá para "Authentication" -> "Policies".
    - Selecione a tabela.
    - Clique em "+ New Policy".
    - Escolha "Create policy from scratch" ou um template.
    - Preencha os campos: Nome, Target roles, Command, USING expression, WITH CHECK expression.
    - Clique em "Review" e depois "Save policy".

### 7. Testando Suas Políticas RLS

**É VITAL TESTAR SUAS POLÍTICAS!**

1. **SQL Editor com Impersonificação:**
    - No SQL Editor, você pode executar queries como se fosse um usuário específico. Use set role ou configure a sessão para simular anon ou authenticated.
    - Exemplo:
        
        ```sql
              -- Simular usuário anônimo
        set role anon;
        select * from artigos; -- Deve retornar apenas artigos publicados
        
        -- Simular usuário autenticado (sem role específico)
        set role authenticated;
        select * from artigos; -- Deve retornar publicados (e rascunhos se a política opcional existir)
        insert into categorias (nome, slug) values ('Teste', 'teste'); -- Deve funcionar
        select * from newsletter_assinantes; -- NÃO DEVE RETORNAR NADA
        
        -- Voltar ao normal
        reset role;
        ```
        
2. **Testes de API:**
    - Use ferramentas como Postman, curl, ou a própria biblioteca cliente do Supabase (supabase-js) no seu console do navegador/Node.js.
    - Faça chamadas à API **sem** um token de autenticação (simula anon). Verifique se você só vê dados públicos.
    - Faça chamadas à API **com** um token JWT de um usuário logado (simula authenticated). Verifique o acesso permitido.
    - Tente realizar operações de escrita proibidas e verifique se elas falham com um erro de permissão.

### 8. Boas Práticas e Considerações

- **Comece Restritivo:** É mais seguro começar negando todo o acesso (habilitando RLS) e depois adicionar permissões explícitas com políticas USING (true) ou condições específicas.
- **Teste Exaustivamente:** Teste todos os cenários de usuário (anônimo, logado, diferentes roles se houver) e todas as operações (SELECT, INSERT, UPDATE, DELETE).
- **Performance:** Políticas muito complexas, especialmente aquelas com subconsultas (EXISTS), podem impactar o desempenho. Monitore suas queries e adicione índices onde necessário.
- **Funções PostgreSQL:** Para lógica de política complexa ou reutilizável, considere criar funções PostgreSQL e chamá-las dentro das expressões USING ou WITH CHECK. Use SECURITY DEFINER com cautela para funções que precisam de privilégios elevados (como inserir na tabela de newsletter).
- **Separação de Interesses:** Mantenha a lógica de *autorização* (quem pode fazer o quê) nas políticas RLS. A lógica de *negócios* deve permanecer na sua aplicação ou em funções do banco de dados.
- **Documente Suas Políticas:** Mantenha um registro do propósito de cada política.

Ótima pergunta! É fundamental entender *quando* e *por que* aplicar RLS. Mesmo com o seu fluxo de trabalho específico (sem login no blog, gerenciamento via dashboard Supabase), a resposta é:

**Sim, você ainda precisa de RLS, e ela continua sendo crucial, principalmente para proteger o ACESSO DE LEITURA da sua aplicação front-end.**

Vamos detalhar o porquê:

1. **Sua Aplicação Front-end (Next.js) Precisa Ler Dados:**
    - Para exibir os artigos, categorias, autores, etc., no seu blog florescerhumano.danieldantas.com, sua aplicação Next.js **precisará se conectar ao Supabase para buscar (SELECT) esses dados**.
    - Essa conexão do front-end **utilizará a chave pública de API do Supabase (a anon key)**. Essa chave é considerada segura para expor no código do navegador.
2. **RLS Controla o que a anon key Pode Ver:**
    - **Sem RLS:** Se você desabilitar RLS, qualquer pessoa com a sua anon key (que está no código do seu site) poderia, teoricamente, ler **TODAS** as linhas de **TODAS** as tabelas, incluindo:
        - Artigos com status = 'rascunho'.
        - Artigos com data_publicacao futura.
        - **Toda a tabela newsletter_assinantes**, expondo os e-mails dos seus assinantes! (Gravíssimo!)
        - Quaisquer outros dados que você possa adicionar no futuro.
    - **Com RLS:** Você define políticas que dizem explicitamente o que a anon key (ou seja, qualquer visitante do seu site através da aplicação Next.js) tem permissão para ler. Por exemplo:
        - Na tabela artigos: "Permitir SELECT apenas se status = 'publicado' E data_publicacao <= now()". Isso garante que rascunhos e posts agendados não sejam lidos pela API pública.
        - Na tabela newsletter_assinantes: "Permitir SELECT apenas se false". Isso **bloqueia completamente** qualquer tentativa de leitura dessa tabela usando a anon key.
3. **Gerenciamento via Dashboard vs. Acesso via API:**
    - Quando **VOCÊ** acessa o Supabase através do painel de controle (dashboard) ou do SQL Editor, você está autenticado como um **usuário do projeto Supabase** (com seu login e senha do Supabase). Suas permissões dentro do dashboard são diferentes e geralmente mais elevadas (você é o dono/admin do projeto). Você *consegue* ver e editar rascunhos e outros dados diretamente ali.
    - Quando a **APLICAÇÃO FRONT-END** acessa o Supabase, ela usa a anon key, que tem privilégios muito menores e **está sujeita às regras RLS** que você definir.
4. **Defesa em Profundidade:**
    - RLS atua como uma camada de segurança essencial no nível do banco de dados. Mesmo que haja uma falha lógica ou uma vulnerabilidade na sua aplicação front-end no futuro, RLS impede o acesso não autorizado aos dados na fonte.

**Em Resumo:**

Você precisa de RLS não para controlar o login *no seu blog* (pois não haverá), nem primariamente para controlar o *seu* acesso via dashboard, mas sim para **controlar rigorosamente o que a sua aplicação front-end Next.js (usando a chave pública anon) pode ler do banco de dados Supabase**. É a principal linha de defesa para garantir que apenas dados públicos sejam expostos aos visitantes do seu site e que dados sensíveis (como e-mails da newsletter) permaneçam completamente inacessíveis via API pública.

Portanto, habilite RLS em todas as tabelas e defina as políticas de SELECT (leitura) cuidadosamente, especialmente a política de bloqueio total de leitura para newsletter_assinantes e a política condicional para artigos. As políticas de escrita (INSERT, UPDATE, DELETE) também são importantes para garantir que a anon key não possa modificar dados acidentalmente.

---

Ao seguir estas etapas e aplicar as políticas sugeridas (adaptando-as se necessário), você garantirá um nível robusto de segurança para os dados do seu blog "Florescer Humano" diretamente na camada do banco de dados Supabase.

# Tabelas comentadas

```sql
Perfeito! Entendi a necessidade de adicionar comentários mais 
detalhados diretamente no código SQL para explicar por que cada 
tabela e coluna existe e como elas se encaixam na arquitetura 
geral do blog, especialmente considerando a decisão de usar a pasta 
public para imagens.

Aqui está a versão reescrita dos esquemas SQL, com comentários explicativos expandidos para cada tabela e coluna relevante:

Definição dos Esquemas das Tabelas Supabase (SQL) - Imagens na Pasta public (Com Comentários Detalhados)

Observações Importantes:

RLS (Row Level Security): ESSENCIAL habilitar RLS para TODAS as tabelas. As políticas de segurança devem ser definidas cuidadosamente após a criação das tabelas para controlar o acesso (leitura pública para conteúdo publicado, escrita restrita a administradores/editores, acesso ultra-restrito a dados de newsletter).
Tipos de Dados: bigint generated by default as identity para chaves primárias auto-incrementais; timestamptz para timestamps com fuso horário; text para strings de comprimento variável; jsonb como alternativa para conteúdo estruturado; check para validação de dados em colunas específicas.
Índices: Recomenda-se criar índices em colunas frequentemente usadas em cláusulas WHERE ou JOIN (ex: slug, status, categoria_id, autor_id, data_publicacao) para otimizar o desempenho das consultas. Supabase cria índices para chaves primárias e estrangeiras automaticamente.

Imagens na Pasta public: As colunas foto_arquivo (autores) e imagem_capa_arquivo (artigos) não armazenam a imagem em si. Elas armazenam apenas o nome do arquivo (ex: "meu-artigo.png") que reside na pasta /public/ do projeto Next.js. A aplicação front-end será responsável por construir o caminho completo (ex: /blogflorescerhumano/meu-artigo.png) para exibir a imagem usando next/image.

```

```sql

-- ## TABELAS PRINCIPAIS DE CONTEÚDO ##

-- Tabela: categorias
-- Propósito: Armazena as categorias principais do blog, usadas para organizar
--            os artigos tematicamente e facilitar a navegação do usuário.
CREATE TABLE categorias (
  id bigint generated by default as identity primary key, -- Identificador único da categoria.
  nome text not null unique,                              -- Nome da categoria exibido ao usuário (ex: "Autoconhecimento"). Deve ser único.
  slug text not null unique,                              -- Versão do nome amigável para URLs (ex: "autoconhecimento"). Deve ser único e usado nas rotas dinâmicas.
  descricao text,                                         -- Descrição opcional da categoria (pode ser usada em páginas de categoria ou para SEO).
  data_criacao timestamptz default now() not null,        -- Timestamp de quando a categoria foi criada.
  data_atualizacao timestamptz default now() not null     -- Timestamp da última atualização da categoria (atualizado automaticamente via trigger).
);
-- Comentário: Estrutura base da organização temática do blog.
-- RLS: Habilitar. Política padrão: Leitura pública (SELECT permitido para todos). Escrita (INSERT, UPDATE, DELETE) restrita a roles específicas (ex: 'authenticated', 'admin').
-- Índices: Recomendado índice em 'slug' para buscas rápidas por URL.

-- Tabela: subcategorias
-- Propósito: Permite uma organização mais granular dentro de uma categoria principal,
--            oferecendo um segundo nível de classificação temática.
CREATE TABLE subcategorias (
  id bigint generated by default as identity primary key, -- Identificador único da subcategoria.
  nome text not null,                                     -- Nome da subcategoria exibido ao usuário (ex: "Mindfulness"). Não precisa ser único globalmente, mas idealmente único dentro de uma categoria pai.
  slug text not null unique,                              -- Versão do nome amigável para URLs (ex: "mindfulness"). Deve ser único globalmente para evitar conflitos de rota.
  categoria_id bigint not null references categorias(id) on delete cascade, -- Chave estrangeira ligando à categoria pai. 'on delete cascade' significa que se a categoria pai for deletada, todas as suas subcategorias também serão (cuidado com esta opção, 'on delete restrict' ou 'on delete set null' podem ser mais seguros dependendo do caso de uso).
  descricao text,                                         -- Descrição opcional da subcategoria.
  data_criacao timestamptz default now() not null,        -- Timestamp de criação.
  data_atualizacao timestamptz default now() not null     -- Timestamp da última atualização (atualizado automaticamente via trigger).
);
-- Comentário: Aprofunda a organização do conteúdo.
-- RLS: Habilitar. Política padrão: Leitura pública. Escrita restrita.
-- Índices: Recomendado índice em 'slug' e 'categoria_id'.

-- Tabela: autores
-- Propósito: Armazena informações sobre os autores dos artigos, permitindo
--            atribuição e criação de páginas de perfil de autor (se necessário).
CREATE TABLE autores (
  id bigint generated by default as identity primary key, -- Identificador único do autor.
  nome text not null,                                     -- Nome completo do autor.
  biografia text,                                         -- Texto descritivo sobre o autor.
  foto_arquivo text,                                      -- **APENAS o nome do arquivo** da foto do autor (ex: "daniel-dantas.jpg"). A imagem reside em /public/psidanieldantas/ ou /public/blogflorescerhumano/. A aplicação constrói o path completo.
  perfil_academico_url text,                              -- URL opcional para um perfil externo (Lattes, LinkedIn, etc.).
  data_criacao timestamptz default now() not null,        -- Timestamp de criação.
  data_atualizacao timestamptz default now() not null     -- Timestamp da última atualização (atualizado automaticamente via trigger).
);
-- Comentário: Essencial para atribuição de conteúdo. A coluna 'foto_arquivo' é a chave para vincular o registro ao arquivo de imagem estático.
-- RLS: Habilitar. Política padrão: Leitura pública. Escrita restrita.

-- Tabela: tags
-- Propósito: Permite uma organização flexível e multifacetada dos artigos,
--            agrupando posts por tópicos específicos que podem cruzar categorias.
CREATE TABLE tags (
  id bigint generated by default as identity primary key, -- Identificador único da tag.
  nome text not null unique,                              -- Nome da tag exibido (ex: "Carl Rogers"). Deve ser único.
  slug text not null unique,                              -- Versão do nome amigável para URLs/filtros (ex: "carl-rogers"). Deve ser único.
  data_criacao timestamptz default now() not null        -- Timestamp de criação.
);
-- Comentário: Complementa as categorias para melhor descoberta de conteúdo.
-- RLS: Habilitar. Política padrão: Leitura pública. Escrita restrita.
-- Índices: Recomendado índice em 'slug'.

```

```sql
-- Tabela: artigos
-- Propósito: Tabela central do blog, armazena o conteúdo principal de cada post.
CREATE TABLE artigos (
  id bigint generated by default as identity primary key, -- Identificador único do artigo.
  titulo text not null,                                   -- Título principal do artigo, exibido na página e usado em metadados (SEO).
  slug text not null unique,                              -- Identificador único para a URL do artigo (ex: "entendendo-a-autoestima"). Essencial para rotas dinâmicas e SEO.
  conteudo text not null,                                 -- Conteúdo principal do artigo. Pode ser Markdown, HTML, ou texto simples. Considerar 'jsonb' se usar um editor baseado em blocos (ex: Editor.js, Tiptap) para armazenar conteúdo estruturado.
  resumo text,                                            -- Pequeno trecho ou resumo do artigo, usado em listagens (cards) e metadados (SEO meta description).
  imagem_capa_arquivo text,                               -- **APENAS o nome do arquivo** da imagem de capa (ex: "importancia-empatia.png"). A imagem reside em /public/blogflorescerhumano/. A aplicação constrói o path completo.
  categoria_id bigint not null references categorias(id) on delete restrict, -- Chave estrangeira para a categoria principal. 'on delete restrict' impede que uma categoria seja deletada se houver artigos nela.
  subcategoria_id bigint references subcategorias(id) on delete set null, -- Chave estrangeira opcional para a subcategoria. 'on delete set null' define o campo como nulo se a subcategoria for deletada.
  autor_id bigint not null references autores(id) on delete restrict, -- Chave estrangeira para o autor. 'on delete restrict' impede que um autor seja deletado se tiver artigos associados.
  data_publicacao timestamptz,                            -- Data e hora em que o artigo deve se tornar público. Permite agendar publicações e manter artigos como rascunhos. Se for nulo, pode ser considerado não publicado ainda.
  status text not null default 'rascunho'                 -- Status do artigo, controla sua visibilidade.
    check (status in ('rascunho', 'publicado', 'arquivado')), -- Restrição para garantir que o status seja um dos valores permitidos.
  data_criacao timestamptz default now() not null,        -- Timestamp de quando o registro do artigo foi criado no banco.
  data_atualizacao timestamptz default now() not null     -- Timestamp da última atualização do artigo (atualizado automaticamente via trigger).
);
-- Comentário: Coração do conteúdo do blog. A combinação de 'status' e 'data_publicacao' controla a visibilidade pública.
-- RLS: Habilitar. Política de leitura pública complexa: SELECT permitido para todos APENAS SE (status = 'publicado' AND data_publicacao IS NOT NULL AND data_publicacao <= now()). Política de leitura para rascunhos/arquivados restrita a autores/admins. Escrita (INSERT, UPDATE, DELETE) restrita.
-- Índices: Recomendados índices em 'slug', 'status', 'data_publicacao', 'categoria_id', 'subcategoria_id', 'autor_id'.

-- Tabela: artigos_tags
-- Propósito: Tabela de junção (linking table) para implementar a relação
--            muitos-para-muitos entre artigos e tags.
CREATE TABLE artigos_tags (
  artigo_id bigint not null references artigos(id) on delete cascade, -- Chave estrangeira para o artigo. 'on delete cascade' remove a associação se o artigo for deletado.
  tag_id bigint not null references tags(id) on delete cascade,       -- Chave estrangeira para a tag. 'on delete cascade' remove a associação se a tag for deletada.
  primary key (artigo_id, tag_id)                                    -- Chave primária composta para garantir que a combinação artigo/tag seja única.
);
-- Comentário: Permite que um artigo tenha várias tags e uma tag seja associada a vários artigos.
-- RLS: Habilitar. Política de leitura deve geralmente espelhar a política de leitura da tabela 'artigos' (só mostrar associações de artigos públicos). Escrita restrita.

```

```sql

-- ## TABELA DE FUNCIONALIDADES ADICIONAIS ##

-- Tabela: newsletter_assinantes
-- Propósito: Armazena os endereços de e-mail dos usuários que se inscreveram
--            na newsletter. Requer tratamento cuidadoso devido à privacidade.
CREATE TABLE newsletter_assinantes (
  id bigint generated by default as identity primary key, -- Identificador único do assinante.
  email text not null unique                              -- Endereço de e-mail do assinante. Deve ser único.
    check (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'), -- Validação básica do formato do e-mail.
  data_inscricao timestamptz default now() not null,      -- Timestamp de quando o usuário se inscreveu.
  status_confirmacao text not null default 'pendente'     -- Status da confirmação do e-mail (para implementar Double Opt-In).
    check (status_confirmacao in ('pendente', 'confirmado')), -- Garante que o status seja um dos valores permitidos.
  token_confirmacao text unique,                          -- Token único enviado por e-mail para o usuário confirmar a inscrição. Nulo após confirmação.
  data_confirmacao timestamptz                            -- Timestamp de quando o usuário confirmou o e-mail.
);
-- Comentário: Dados sensíveis. Implementar Double Opt-In é recomendado para conformidade e qualidade da lista.
-- RLS: Habilitar. **POLÍTICAS EXTREMAMENTE RESTRITAS**. Nenhuma leitura pública. Escrita (INSERT) permitida apenas via funções seguras (Security Definer) ou API Keys de backend, NUNCA diretamente pelo cliente anônimo. Leitura (SELECT) restrita a administradores ou roles específicas de backend.

-- ## Funções Auxiliares (Opcional, mas recomendado para `data_atualizacao`) ##

-- Função: trigger_set_timestamp
-- Propósito: Atualiza automaticamente o campo 'data_atualizacao' para o timestamp
--            atual sempre que uma linha em uma tabela associada for atualizada.
create or replace function trigger_set_timestamp()
returns trigger as $$
begin
  -- Define o valor da coluna 'data_atualizacao' da linha que está sendo atualizada (NEW)
  -- para o timestamp atual da transação (now()).
  new.data_atualizacao = now();
  -- Retorna a linha modificada para que a operação UPDATE prossiga.
  return new;
end;
$$ language plpgsql;

-- Triggers: Associam a função 'trigger_set_timestamp' ao evento UPDATE
--           nas tabelas que possuem a coluna 'data_atualizacao'.
--           Isso garante que o timestamp seja atualizado automaticamente.

create trigger set_timestamp_categorias
before update on categorias -- Antes de cada UPDATE na tabela 'categorias'
for each row             -- Para cada linha que for atualizada
execute procedure trigger_set_timestamp(); -- Execute a função definida acima.

create trigger set_timestamp_subcategorias
before update on subcategorias
for each row
execute procedure trigger_set_timestamp();

create trigger set_timestamp_autores
before update on autores
for each row
execute procedure trigger_set_timestamp();

create trigger set_timestamp_artigos
before update on artigos
for each row
execute procedure trigger_set_timestamp();

```

# Primeiras Tabalas de Exemplo no banco de dados:

```sql
-- Script SQL para Povoar as Tabelas do Blog "Florescer Humano" (Exemplo)

-- Observações:
-- 1. IDs: Os IDs são definidos como 'bigint generated by default as identity', então o banco de dados os gerará automaticamente.
--    Não precisamos especificá-los nos inserts, a menos que queiramos referenciá-los em tabelas dependentes logo em seguida.
--    Para simplicidade e clareza neste exemplo, vamos assumir que sabemos os IDs gerados (1, 2, 3...) para criar os relacionamentos.
--    Em um script real, você pode usar `RETURNING id` nos inserts para capturar os IDs gerados.
-- 2. Datas: Usamos `now()` para datas de criação/atualização. Para `data_publicacao`, definimos uma data no passado para que os artigos sejam visíveis com as políticas RLS.
-- 3. Imagens: As colunas `foto_arquivo` e `imagem_capa_arquivo` contêm apenas NOMES de arquivos. As imagens reais devem existir em `public/blogflorescerhumano/` ou `public/psicologodanieldantas/`.

-- ## Povoar Tabela: categorias ##
INSERT INTO categorias (nome, slug, descricao) VALUES
('Autoconhecimento e Desenvolvimento Pessoal', 'autoconhecimento-desenvolvimento-pessoal', 'Explore ferramentas e reflexões para sua jornada de crescimento interior.'),
('Psicologia Humanista e Abordagens Relacionadas', 'psicologia-humanista-abordagens', 'Aprofunde-se nos conceitos e práticas da Psicologia Humanista, ACP, Focalização e Mindfulness.'),
('Bem-Estar Emocional e Saúde Mental', 'bem-estar-emocional-saude-mental', 'Conteúdos sobre como lidar com emoções, estresse, ansiedade e cultivar a saúde mental.'),
('Relacionamentos e Conexões Humanas', 'relacionamentos-conexoes-humanas', 'Reflexões sobre a importância e a dinâmica das relações interpessoais.'),
('Florescer na Vida', 'florescer-na-vida', 'Espaço para inspiração, histórias, poemas e reflexões sobre a busca por sentido e autenticidade.');

-- ## Povoar Tabela: subcategorias ##
-- Assumindo que 'Psicologia Humanista...' é a categoria com id=2
INSERT INTO subcategorias (nome, slug, categoria_id, descricao) VALUES
('Abordagem Centrada na Pessoa (ACP)', 'abordagem-centrada-pessoa-acp', 2, 'Princípios e práticas da ACP de Carl Rogers.'),
('Focalização (Focusing)', 'focalizacao-focusing', 2, 'Explore a técnica de Eugene Gendlin para acessar a sabedoria corporal.'),
('Mindfulness e Atenção Plena', 'mindfulness-atencao-plena', 2, 'Práticas de atenção plena e sua integração com a psicologia humanista.'),
('Diálogos Interdisciplinares', 'dialogos-interdisciplinares', 2, 'Conexões da psicologia humanista com filosofia, neurociência e artes.');

-- ## Povoar Tabela: autores ##
INSERT INTO autores (nome, biografia, foto_arquivo, perfil_academico_url) VALUES
('Daniel Dantas', 'Psicólogo clínico com abordagem humanista, focado em ACP, Focalização e Mindfulness. Autor do blog Florescer Humano.', 'daniel-dantas-profile.jpg', 'https://www.linkedin.com/in/danieldantaspsi/');
-- Adicione outros autores se necessário

-- ## Povoar Tabela: tags ##
INSERT INTO tags (nome, slug) VALUES
('Carl Rogers', 'carl-rogers'),
('Empatia', 'empatia'),
('Congruência', 'congruencia'),
('Aceitação Incondicional', 'aceitacao-incondicional'),
('Felt Sense', 'felt-sense'),
('Eugene Gendlin', 'eugene-gendlin'),
('Mindfulness para Iniciantes', 'mindfulness-iniciantes'),
('Ansiedade', 'ansiedade'),
('Autocompaixão', 'autocompaixao'),
('Propósito de Vida', 'proposito-vida'),
('Relacionamento Terapêutico', 'relacionamento-terapeutico'),
('Técnicas Práticas', 'tecnicas-praticas'),
('Para Estudantes', 'para-estudantes'),
('Prática Clínica', 'pratica-clinica'),
('Criatividade', 'criatividade');

-- ## Povoar Tabela: artigos ##
-- Assumindo IDs: Categoria 1='Autoconhecimento...', 2='Psicologia Humanista...', 3='Bem-Estar...', 4='Relacionamentos...', 5='Florescer...'
-- Assumindo IDs: Subcategoria 1='ACP', 2='Focalização', 3='Mindfulness'
-- Assumindo ID: Autor 1='Daniel Dantas'
INSERT INTO artigos (titulo, slug, conteudo, resumo, imagem_capa_arquivo, categoria_id, subcategoria_id, autor_id, data_publicacao, status) VALUES
(
  'A Importância da Empatia nas Relações Humanas',
  'importancia-empatia-relacoes-humanas',
  '<p>A empatia, a capacidade de se colocar no lugar do outro, é fundamental...</p> (Conteúdo completo em HTML ou Markdown)',
  'Entenda por que a empatia é crucial para construir conexões mais profundas e significativas em todas as áreas da vida.',
  'importancia-empatia-image-blog.png',
  4, -- Relacionamentos e Conexões Humanas
  NULL,
  1, -- Daniel Dantas
  '2023-10-26 10:00:00+00', -- Data no passado
  'publicado'
),
(
  'Introdução à Abordagem Centrada na Pessoa (ACP)',
  'introducao-abordagem-centrada-pessoa-acp',
  '<h1>O que é ACP?</h1><p>Desenvolvida por Carl Rogers, a ACP parte do princípio...</p> (Conteúdo completo)',
  'Conheça os fundamentos da Abordagem Centrada na Pessoa de Carl Rogers e sua visão otimista sobre o potencial humano.',
  'acp-rogers-capa-blog.jpg',
  2, -- Psicologia Humanista...
  1, -- ACP
  1, -- Daniel Dantas
  '2023-11-15 09:00:00+00',
  'publicado'
),
(
  '5 Exercícios Simples de Mindfulness para o Dia a Dia',
  'exercicios-simples-mindfulness-dia-a-dia',
  '<p>Mindfulness não precisa ser complicado. Aqui estão 5 práticas que você pode incorporar...</p> (Conteúdo completo)',
  'Aprenda exercícios práticos e rápidos de atenção plena para reduzir o estresse e aumentar a presença no cotidiano.',
  'mindfulness-exercicios-blog.webp',
  3, -- Bem-Estar Emocional...
  3, -- Mindfulness
  1, -- Daniel Dantas
  '2024-01-10 14:30:00+00',
  'publicado'
),
(
  'Cultivando a Autocompaixão: Um Caminho Gentil',
  'cultivando-autocompaixao-caminho-gentil',
  '<p>Ser gentil consigo mesmo, especialmente em momentos difíceis, é essencial...</p> (Conteúdo completo)',
  'Descubra o que é autocompaixão e como práticas simples podem transformar sua relação consigo mesmo.',
  'autocompaixao-blog.jpg',
  1, -- Autoconhecimento...
  NULL,
  1, -- Daniel Dantas
  '2024-02-01 11:00:00+00',
  'publicado'
),
(
  'Rascunho: Explorando a Focalização', -- Artigo não publicado
  'rascunho-explorando-focalizacao',
  '<p>Conteúdo inicial sobre Focalização...</p>',
  'Um olhar sobre a técnica de Gendlin.',
  NULL, -- Sem imagem ainda
  2, -- Psicologia Humanista...
  2, -- Focalização
  1, -- Daniel Dantas
  NULL, -- Sem data de publicação
  'rascunho' -- Status rascunho
);

-- ## Povoar Tabela: artigos_tags ##
-- Assumindo IDs dos artigos criados acima: 1, 2, 3, 4, 5
-- Assumindo IDs das tags criadas acima
INSERT INTO artigos_tags (artigo_id, tag_id) VALUES
(1, 2), -- Artigo 1 (Empatia) -> Tag Empatia
(1, 11), -- Artigo 1 (Empatia) -> Tag Relacionamento Terapêutico (se aplicável ao contexto)
(2, 1), -- Artigo 2 (ACP) -> Tag Carl Rogers
(2, 2), -- Artigo 2 (ACP) -> Tag Empatia
(2, 3), -- Artigo 2 (ACP) -> Tag Congruência
(2, 4), -- Artigo 2 (ACP) -> Tag Aceitação Incondicional
(2, 13), -- Artigo 2 (ACP) -> Tag Para Estudantes
(3, 7), -- Artigo 3 (Mindfulness) -> Tag Mindfulness para Iniciantes
(3, 8), -- Artigo 3 (Mindfulness) -> Tag Ansiedade
(3, 12), -- Artigo 3 (Mindfulness) -> Tag Técnicas Práticas
(4, 9), -- Artigo 4 (Autocompaixão) -> Tag Autocompaixão
(4, 12); -- Artigo 4 (Autocompaixão) -> Tag Técnicas Práticas
-- Nenhuma tag para o artigo 5 (rascunho) ainda.

-- ## Povoar Tabela: newsletter_assinantes ##
INSERT INTO newsletter_assinantes (email, status_confirmacao, token_confirmacao, data_confirmacao) VALUES
('usuario.confirmado@email.com', 'confirmado', NULL, now() - interval '2 day'), -- Assinante confirmado há 2 dias
('usuario.pendente@email.com', 'pendente', 'token_unico_para_confirmacao_123abc', NULL), -- Assinante aguardando confirmação
('outro.confirmado@provider.net', 'confirmado', NULL, now() - interval '1 month'); -- Assinante confirmado há 1 mês

-- Fim do Script de Exemplo --
```
